/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/lib/_version.js":
/*!*********************************************!*\
  !*** ./node_modules/ethers/lib/_version.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"ethers/5.5.3\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliL192ZXJzaW9uLmpzPzZmYzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSBcImV0aGVycy81LjUuM1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib/ethers.js":
/*!*******************************************!*\
  !*** ./node_modules/ethers/lib/ethers.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = void 0;\nvar contracts_1 = __webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib/index.js\");\nObject.defineProperty(exports, \"BaseContract\", ({ enumerable: true, get: function () { return contracts_1.BaseContract; } }));\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return contracts_1.Contract; } }));\nObject.defineProperty(exports, \"ContractFactory\", ({ enumerable: true, get: function () { return contracts_1.ContractFactory; } }));\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nObject.defineProperty(exports, \"BigNumber\", ({ enumerable: true, get: function () { return bignumber_1.BigNumber; } }));\nObject.defineProperty(exports, \"FixedNumber\", ({ enumerable: true, get: function () { return bignumber_1.FixedNumber; } }));\nvar abstract_signer_1 = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/index.js\");\nObject.defineProperty(exports, \"Signer\", ({ enumerable: true, get: function () { return abstract_signer_1.Signer; } }));\nObject.defineProperty(exports, \"VoidSigner\", ({ enumerable: true, get: function () { return abstract_signer_1.VoidSigner; } }));\nvar wallet_1 = __webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib/index.js\");\nObject.defineProperty(exports, \"Wallet\", ({ enumerable: true, get: function () { return wallet_1.Wallet; } }));\nvar constants = __importStar(__webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js\"));\nexports.constants = constants;\nvar providers = __importStar(__webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/index.js\"));\nexports.providers = providers;\nvar providers_1 = __webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/index.js\");\nObject.defineProperty(exports, \"getDefaultProvider\", ({ enumerable: true, get: function () { return providers_1.getDefaultProvider; } }));\nvar wordlists_1 = __webpack_require__(/*! @ethersproject/wordlists */ \"(ssr)/./node_modules/@ethersproject/wordlists/lib/index.js\");\nObject.defineProperty(exports, \"Wordlist\", ({ enumerable: true, get: function () { return wordlists_1.Wordlist; } }));\nObject.defineProperty(exports, \"wordlists\", ({ enumerable: true, get: function () { return wordlists_1.wordlists; } }));\nvar utils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/ethers/lib/utils.js\"));\nexports.utils = utils;\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nObject.defineProperty(exports, \"errors\", ({ enumerable: true, get: function () { return logger_1.ErrorCode; } }));\n////////////////////////\n// Compile-Time Constants\n// This is generated by \"npm run dist\"\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/lib/_version.js\");\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return _version_1.version; } }));\nvar logger = new logger_1.Logger(_version_1.version);\nexports.logger = logger;\n//# sourceMappingURL=ethers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi9ldGhlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsdUJBQXVCLEdBQUcsZ0JBQWdCLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsMEJBQTBCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDbFYsa0JBQWtCLG1CQUFPLENBQUMsNEZBQTBCO0FBQ3BELGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbkgsbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILHdCQUF3QixtQkFBTyxDQUFDLDRIQUFnQztBQUNoRSwwQ0FBeUMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDckgsOENBQTZDLEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQzdILGVBQWUsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDOUMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLDZCQUE2QixtQkFBTyxDQUFDLGdIQUEwQjtBQUMvRCxpQkFBaUI7QUFDakIsNkJBQTZCLG1CQUFPLENBQUMsZ0hBQTBCO0FBQy9ELGlCQUFpQjtBQUNqQixrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDcEQsc0RBQXFELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3ZJLGtCQUFrQixtQkFBTyxDQUFDLDRGQUEwQjtBQUNwRCw0Q0FBMkMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbkgsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILHlCQUF5QixtQkFBTyxDQUFDLHlEQUFTO0FBQzFDLGFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywrREFBWTtBQUNyQywyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEg7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIvZXRoZXJzLmpzP2YwMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29yZGxpc3QgPSBleHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLndvcmRsaXN0cyA9IGV4cG9ydHMudXRpbHMgPSBleHBvcnRzLmxvZ2dlciA9IGV4cG9ydHMuZXJyb3JzID0gZXhwb3J0cy5jb25zdGFudHMgPSBleHBvcnRzLkZpeGVkTnVtYmVyID0gZXhwb3J0cy5CaWdOdW1iZXIgPSBleHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IGV4cG9ydHMuQ29udHJhY3QgPSBleHBvcnRzLkJhc2VDb250cmFjdCA9IGV4cG9ydHMucHJvdmlkZXJzID0gZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBleHBvcnRzLlZvaWRTaWduZXIgPSBleHBvcnRzLldhbGxldCA9IGV4cG9ydHMuU2lnbmVyID0gdm9pZCAwO1xudmFyIGNvbnRyYWN0c18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2NvbnRyYWN0c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RzXzEuQmFzZUNvbnRyYWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0c18xLkNvbnRyYWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cmFjdHNfMS5Db250cmFjdEZhY3Rvcnk7IH0gfSk7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJfMS5CaWdOdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZE51bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyXzEuRml4ZWROdW1iZXI7IH0gfSk7XG52YXIgYWJzdHJhY3Rfc2lnbmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9zaWduZXJfMS5TaWduZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWb2lkU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9zaWduZXJfMS5Wb2lkU2lnbmVyOyB9IH0pO1xudmFyIHdhbGxldF8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dhbGxldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2FsbGV0XzEuV2FsbGV0OyB9IH0pO1xudmFyIGNvbnN0YW50cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCIpKTtcbmV4cG9ydHMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xudmFyIHByb3ZpZGVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzXCIpKTtcbmV4cG9ydHMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xudmFyIHByb3ZpZGVyc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3ZpZGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERlZmF1bHRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJzXzEuZ2V0RGVmYXVsdFByb3ZpZGVyOyB9IH0pO1xudmFyIHdvcmRsaXN0c18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dvcmRsaXN0c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3b3JkbGlzdHNfMS5Xb3JkbGlzdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndvcmRsaXN0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd29yZGxpc3RzXzEud29yZGxpc3RzOyB9IH0pO1xudmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmV4cG9ydHMudXRpbHMgPSB1dGlscztcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlcnJvcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2dlcl8xLkVycm9yQ29kZTsgfSB9KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ29tcGlsZS1UaW1lIENvbnN0YW50c1xuLy8gVGhpcyBpcyBnZW5lcmF0ZWQgYnkgXCJucG0gcnVuIGRpc3RcIlxudmFyIF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF92ZXJzaW9uXzEudmVyc2lvbjsgfSB9KTtcbnZhciBsb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKF92ZXJzaW9uXzEudmVyc2lvbik7XG5leHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib/ethers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/ethers/lib/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = exports.ethers = void 0;\n// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\nvar ethers = __importStar(__webpack_require__(/*! ./ethers */ \"(ssr)/./node_modules/ethers/lib/ethers.js\"));\nexports.ethers = ethers;\ntry {\n    var anyGlobal = window;\n    if (anyGlobal._ethers == null) {\n        anyGlobal._ethers = ethers;\n    }\n}\ncatch (error) { }\nvar ethers_1 = __webpack_require__(/*! ./ethers */ \"(ssr)/./node_modules/ethers/lib/ethers.js\");\nObject.defineProperty(exports, \"Signer\", ({ enumerable: true, get: function () { return ethers_1.Signer; } }));\nObject.defineProperty(exports, \"Wallet\", ({ enumerable: true, get: function () { return ethers_1.Wallet; } }));\nObject.defineProperty(exports, \"VoidSigner\", ({ enumerable: true, get: function () { return ethers_1.VoidSigner; } }));\nObject.defineProperty(exports, \"getDefaultProvider\", ({ enumerable: true, get: function () { return ethers_1.getDefaultProvider; } }));\nObject.defineProperty(exports, \"providers\", ({ enumerable: true, get: function () { return ethers_1.providers; } }));\nObject.defineProperty(exports, \"BaseContract\", ({ enumerable: true, get: function () { return ethers_1.BaseContract; } }));\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return ethers_1.Contract; } }));\nObject.defineProperty(exports, \"ContractFactory\", ({ enumerable: true, get: function () { return ethers_1.ContractFactory; } }));\nObject.defineProperty(exports, \"BigNumber\", ({ enumerable: true, get: function () { return ethers_1.BigNumber; } }));\nObject.defineProperty(exports, \"FixedNumber\", ({ enumerable: true, get: function () { return ethers_1.FixedNumber; } }));\nObject.defineProperty(exports, \"constants\", ({ enumerable: true, get: function () { return ethers_1.constants; } }));\nObject.defineProperty(exports, \"errors\", ({ enumerable: true, get: function () { return ethers_1.errors; } }));\nObject.defineProperty(exports, \"logger\", ({ enumerable: true, get: function () { return ethers_1.logger; } }));\nObject.defineProperty(exports, \"utils\", ({ enumerable: true, get: function () { return ethers_1.utils; } }));\nObject.defineProperty(exports, \"wordlists\", ({ enumerable: true, get: function () { return ethers_1.wordlists; } }));\n////////////////////////\n// Compile-Time Constants\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return ethers_1.version; } }));\nObject.defineProperty(exports, \"Wordlist\", ({ enumerable: true, get: function () { return ethers_1.Wordlist; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDblc7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQywyREFBVTtBQUM1QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1Ryw4Q0FBNkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDcEgsc0RBQXFELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ3BJLDZDQUE0QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNsSCxnREFBK0MsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDeEgsNENBQTJDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2hILG1EQUFrRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM5SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbEgsK0NBQThDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3RILDZDQUE0QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNsSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLHlDQUF3QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUMxRyw2Q0FBNEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbEg7QUFDQTtBQUNBLDJDQUEwQyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM5Ryw0Q0FBMkMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDaEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIvaW5kZXguanM/MWM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JkbGlzdCA9IGV4cG9ydHMudmVyc2lvbiA9IGV4cG9ydHMud29yZGxpc3RzID0gZXhwb3J0cy51dGlscyA9IGV4cG9ydHMubG9nZ2VyID0gZXhwb3J0cy5lcnJvcnMgPSBleHBvcnRzLmNvbnN0YW50cyA9IGV4cG9ydHMuRml4ZWROdW1iZXIgPSBleHBvcnRzLkJpZ051bWJlciA9IGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gZXhwb3J0cy5Db250cmFjdCA9IGV4cG9ydHMuQmFzZUNvbnRyYWN0ID0gZXhwb3J0cy5wcm92aWRlcnMgPSBleHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGV4cG9ydHMuVm9pZFNpZ25lciA9IGV4cG9ydHMuV2FsbGV0ID0gZXhwb3J0cy5TaWduZXIgPSBleHBvcnRzLmV0aGVycyA9IHZvaWQgMDtcbi8vIFRvIG1vZGlmeSB0aGlzIGZpbGUsIHlvdSBtdXN0IHVwZGF0ZSAuL21pc2MvYWRtaW4vbGliL2NtZHMvdXBkYXRlLWV4cG9ydHMuanNcbnZhciBldGhlcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZXRoZXJzXCIpKTtcbmV4cG9ydHMuZXRoZXJzID0gZXRoZXJzO1xudHJ5IHtcbiAgICB2YXIgYW55R2xvYmFsID0gd2luZG93O1xuICAgIGlmIChhbnlHbG9iYWwuX2V0aGVycyA9PSBudWxsKSB7XG4gICAgICAgIGFueUdsb2JhbC5fZXRoZXJzID0gZXRoZXJzO1xuICAgIH1cbn1cbmNhdGNoIChlcnJvcikgeyB9XG52YXIgZXRoZXJzXzEgPSByZXF1aXJlKFwiLi9ldGhlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLlNpZ25lcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuV2FsbGV0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVm9pZFNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuVm9pZFNpZ25lcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERlZmF1bHRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuZ2V0RGVmYXVsdFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvdmlkZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5wcm92aWRlcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLkJhc2VDb250cmFjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5Db250cmFjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuQ29udHJhY3RGYWN0b3J5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5CaWdOdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZE51bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuRml4ZWROdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zdGFudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLmNvbnN0YW50czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVycm9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEuZXJyb3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5sb2dnZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dGlsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEudXRpbHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3b3JkbGlzdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyc18xLndvcmRsaXN0czsgfSB9KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ29tcGlsZS1UaW1lIENvbnN0YW50c1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzXzEudmVyc2lvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldGhlcnNfMS5Xb3JkbGlzdDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/ethers/lib/utils.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;\nexports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.parseBytes32String = void 0;\nvar abi_1 = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib/index.js\");\nObject.defineProperty(exports, \"AbiCoder\", ({ enumerable: true, get: function () { return abi_1.AbiCoder; } }));\nObject.defineProperty(exports, \"checkResultErrors\", ({ enumerable: true, get: function () { return abi_1.checkResultErrors; } }));\nObject.defineProperty(exports, \"ConstructorFragment\", ({ enumerable: true, get: function () { return abi_1.ConstructorFragment; } }));\nObject.defineProperty(exports, \"defaultAbiCoder\", ({ enumerable: true, get: function () { return abi_1.defaultAbiCoder; } }));\nObject.defineProperty(exports, \"ErrorFragment\", ({ enumerable: true, get: function () { return abi_1.ErrorFragment; } }));\nObject.defineProperty(exports, \"EventFragment\", ({ enumerable: true, get: function () { return abi_1.EventFragment; } }));\nObject.defineProperty(exports, \"FormatTypes\", ({ enumerable: true, get: function () { return abi_1.FormatTypes; } }));\nObject.defineProperty(exports, \"Fragment\", ({ enumerable: true, get: function () { return abi_1.Fragment; } }));\nObject.defineProperty(exports, \"FunctionFragment\", ({ enumerable: true, get: function () { return abi_1.FunctionFragment; } }));\nObject.defineProperty(exports, \"Indexed\", ({ enumerable: true, get: function () { return abi_1.Indexed; } }));\nObject.defineProperty(exports, \"Interface\", ({ enumerable: true, get: function () { return abi_1.Interface; } }));\nObject.defineProperty(exports, \"LogDescription\", ({ enumerable: true, get: function () { return abi_1.LogDescription; } }));\nObject.defineProperty(exports, \"ParamType\", ({ enumerable: true, get: function () { return abi_1.ParamType; } }));\nObject.defineProperty(exports, \"TransactionDescription\", ({ enumerable: true, get: function () { return abi_1.TransactionDescription; } }));\nvar address_1 = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/index.js\");\nObject.defineProperty(exports, \"getAddress\", ({ enumerable: true, get: function () { return address_1.getAddress; } }));\nObject.defineProperty(exports, \"getCreate2Address\", ({ enumerable: true, get: function () { return address_1.getCreate2Address; } }));\nObject.defineProperty(exports, \"getContractAddress\", ({ enumerable: true, get: function () { return address_1.getContractAddress; } }));\nObject.defineProperty(exports, \"getIcapAddress\", ({ enumerable: true, get: function () { return address_1.getIcapAddress; } }));\nObject.defineProperty(exports, \"isAddress\", ({ enumerable: true, get: function () { return address_1.isAddress; } }));\nvar base64 = __importStar(__webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib/index.js\"));\nexports.base64 = base64;\nvar basex_1 = __webpack_require__(/*! @ethersproject/basex */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/basex/lib/index.js\");\nObject.defineProperty(exports, \"base58\", ({ enumerable: true, get: function () { return basex_1.Base58; } }));\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nObject.defineProperty(exports, \"arrayify\", ({ enumerable: true, get: function () { return bytes_1.arrayify; } }));\nObject.defineProperty(exports, \"concat\", ({ enumerable: true, get: function () { return bytes_1.concat; } }));\nObject.defineProperty(exports, \"hexConcat\", ({ enumerable: true, get: function () { return bytes_1.hexConcat; } }));\nObject.defineProperty(exports, \"hexDataSlice\", ({ enumerable: true, get: function () { return bytes_1.hexDataSlice; } }));\nObject.defineProperty(exports, \"hexDataLength\", ({ enumerable: true, get: function () { return bytes_1.hexDataLength; } }));\nObject.defineProperty(exports, \"hexlify\", ({ enumerable: true, get: function () { return bytes_1.hexlify; } }));\nObject.defineProperty(exports, \"hexStripZeros\", ({ enumerable: true, get: function () { return bytes_1.hexStripZeros; } }));\nObject.defineProperty(exports, \"hexValue\", ({ enumerable: true, get: function () { return bytes_1.hexValue; } }));\nObject.defineProperty(exports, \"hexZeroPad\", ({ enumerable: true, get: function () { return bytes_1.hexZeroPad; } }));\nObject.defineProperty(exports, \"isBytes\", ({ enumerable: true, get: function () { return bytes_1.isBytes; } }));\nObject.defineProperty(exports, \"isBytesLike\", ({ enumerable: true, get: function () { return bytes_1.isBytesLike; } }));\nObject.defineProperty(exports, \"isHexString\", ({ enumerable: true, get: function () { return bytes_1.isHexString; } }));\nObject.defineProperty(exports, \"joinSignature\", ({ enumerable: true, get: function () { return bytes_1.joinSignature; } }));\nObject.defineProperty(exports, \"zeroPad\", ({ enumerable: true, get: function () { return bytes_1.zeroPad; } }));\nObject.defineProperty(exports, \"splitSignature\", ({ enumerable: true, get: function () { return bytes_1.splitSignature; } }));\nObject.defineProperty(exports, \"stripZeros\", ({ enumerable: true, get: function () { return bytes_1.stripZeros; } }));\nvar hash_1 = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/index.js\");\nObject.defineProperty(exports, \"_TypedDataEncoder\", ({ enumerable: true, get: function () { return hash_1._TypedDataEncoder; } }));\nObject.defineProperty(exports, \"hashMessage\", ({ enumerable: true, get: function () { return hash_1.hashMessage; } }));\nObject.defineProperty(exports, \"id\", ({ enumerable: true, get: function () { return hash_1.id; } }));\nObject.defineProperty(exports, \"isValidName\", ({ enumerable: true, get: function () { return hash_1.isValidName; } }));\nObject.defineProperty(exports, \"namehash\", ({ enumerable: true, get: function () { return hash_1.namehash; } }));\nvar hdnode_1 = __webpack_require__(/*! @ethersproject/hdnode */ \"(ssr)/./node_modules/@ethersproject/hdnode/lib/index.js\");\nObject.defineProperty(exports, \"defaultPath\", ({ enumerable: true, get: function () { return hdnode_1.defaultPath; } }));\nObject.defineProperty(exports, \"entropyToMnemonic\", ({ enumerable: true, get: function () { return hdnode_1.entropyToMnemonic; } }));\nObject.defineProperty(exports, \"getAccountPath\", ({ enumerable: true, get: function () { return hdnode_1.getAccountPath; } }));\nObject.defineProperty(exports, \"HDNode\", ({ enumerable: true, get: function () { return hdnode_1.HDNode; } }));\nObject.defineProperty(exports, \"isValidMnemonic\", ({ enumerable: true, get: function () { return hdnode_1.isValidMnemonic; } }));\nObject.defineProperty(exports, \"mnemonicToEntropy\", ({ enumerable: true, get: function () { return hdnode_1.mnemonicToEntropy; } }));\nObject.defineProperty(exports, \"mnemonicToSeed\", ({ enumerable: true, get: function () { return hdnode_1.mnemonicToSeed; } }));\nvar json_wallets_1 = __webpack_require__(/*! @ethersproject/json-wallets */ \"(ssr)/./node_modules/@ethersproject/json-wallets/lib/index.js\");\nObject.defineProperty(exports, \"getJsonWalletAddress\", ({ enumerable: true, get: function () { return json_wallets_1.getJsonWalletAddress; } }));\nvar keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\");\nObject.defineProperty(exports, \"keccak256\", ({ enumerable: true, get: function () { return keccak256_1.keccak256; } }));\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nObject.defineProperty(exports, \"Logger\", ({ enumerable: true, get: function () { return logger_1.Logger; } }));\nvar sha2_1 = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/index.js\");\nObject.defineProperty(exports, \"computeHmac\", ({ enumerable: true, get: function () { return sha2_1.computeHmac; } }));\nObject.defineProperty(exports, \"ripemd160\", ({ enumerable: true, get: function () { return sha2_1.ripemd160; } }));\nObject.defineProperty(exports, \"sha256\", ({ enumerable: true, get: function () { return sha2_1.sha256; } }));\nObject.defineProperty(exports, \"sha512\", ({ enumerable: true, get: function () { return sha2_1.sha512; } }));\nvar solidity_1 = __webpack_require__(/*! @ethersproject/solidity */ \"(ssr)/./node_modules/@ethersproject/solidity/lib/index.js\");\nObject.defineProperty(exports, \"solidityKeccak256\", ({ enumerable: true, get: function () { return solidity_1.keccak256; } }));\nObject.defineProperty(exports, \"solidityPack\", ({ enumerable: true, get: function () { return solidity_1.pack; } }));\nObject.defineProperty(exports, \"soliditySha256\", ({ enumerable: true, get: function () { return solidity_1.sha256; } }));\nvar random_1 = __webpack_require__(/*! @ethersproject/random */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/index.js\");\nObject.defineProperty(exports, \"randomBytes\", ({ enumerable: true, get: function () { return random_1.randomBytes; } }));\nObject.defineProperty(exports, \"shuffled\", ({ enumerable: true, get: function () { return random_1.shuffled; } }));\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nObject.defineProperty(exports, \"checkProperties\", ({ enumerable: true, get: function () { return properties_1.checkProperties; } }));\nObject.defineProperty(exports, \"deepCopy\", ({ enumerable: true, get: function () { return properties_1.deepCopy; } }));\nObject.defineProperty(exports, \"defineReadOnly\", ({ enumerable: true, get: function () { return properties_1.defineReadOnly; } }));\nObject.defineProperty(exports, \"getStatic\", ({ enumerable: true, get: function () { return properties_1.getStatic; } }));\nObject.defineProperty(exports, \"resolveProperties\", ({ enumerable: true, get: function () { return properties_1.resolveProperties; } }));\nObject.defineProperty(exports, \"shallowCopy\", ({ enumerable: true, get: function () { return properties_1.shallowCopy; } }));\nvar RLP = __importStar(__webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/index.js\"));\nexports.RLP = RLP;\nvar signing_key_1 = __webpack_require__(/*! @ethersproject/signing-key */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/index.js\");\nObject.defineProperty(exports, \"computePublicKey\", ({ enumerable: true, get: function () { return signing_key_1.computePublicKey; } }));\nObject.defineProperty(exports, \"recoverPublicKey\", ({ enumerable: true, get: function () { return signing_key_1.recoverPublicKey; } }));\nObject.defineProperty(exports, \"SigningKey\", ({ enumerable: true, get: function () { return signing_key_1.SigningKey; } }));\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nObject.defineProperty(exports, \"formatBytes32String\", ({ enumerable: true, get: function () { return strings_1.formatBytes32String; } }));\nObject.defineProperty(exports, \"nameprep\", ({ enumerable: true, get: function () { return strings_1.nameprep; } }));\nObject.defineProperty(exports, \"parseBytes32String\", ({ enumerable: true, get: function () { return strings_1.parseBytes32String; } }));\nObject.defineProperty(exports, \"_toEscapedUtf8String\", ({ enumerable: true, get: function () { return strings_1._toEscapedUtf8String; } }));\nObject.defineProperty(exports, \"toUtf8Bytes\", ({ enumerable: true, get: function () { return strings_1.toUtf8Bytes; } }));\nObject.defineProperty(exports, \"toUtf8CodePoints\", ({ enumerable: true, get: function () { return strings_1.toUtf8CodePoints; } }));\nObject.defineProperty(exports, \"toUtf8String\", ({ enumerable: true, get: function () { return strings_1.toUtf8String; } }));\nObject.defineProperty(exports, \"Utf8ErrorFuncs\", ({ enumerable: true, get: function () { return strings_1.Utf8ErrorFuncs; } }));\nvar transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/index.js\");\nObject.defineProperty(exports, \"accessListify\", ({ enumerable: true, get: function () { return transactions_1.accessListify; } }));\nObject.defineProperty(exports, \"computeAddress\", ({ enumerable: true, get: function () { return transactions_1.computeAddress; } }));\nObject.defineProperty(exports, \"parseTransaction\", ({ enumerable: true, get: function () { return transactions_1.parse; } }));\nObject.defineProperty(exports, \"recoverAddress\", ({ enumerable: true, get: function () { return transactions_1.recoverAddress; } }));\nObject.defineProperty(exports, \"serializeTransaction\", ({ enumerable: true, get: function () { return transactions_1.serialize; } }));\nObject.defineProperty(exports, \"TransactionTypes\", ({ enumerable: true, get: function () { return transactions_1.TransactionTypes; } }));\nvar units_1 = __webpack_require__(/*! @ethersproject/units */ \"(ssr)/./node_modules/@ethersproject/units/lib/index.js\");\nObject.defineProperty(exports, \"commify\", ({ enumerable: true, get: function () { return units_1.commify; } }));\nObject.defineProperty(exports, \"formatEther\", ({ enumerable: true, get: function () { return units_1.formatEther; } }));\nObject.defineProperty(exports, \"parseEther\", ({ enumerable: true, get: function () { return units_1.parseEther; } }));\nObject.defineProperty(exports, \"formatUnits\", ({ enumerable: true, get: function () { return units_1.formatUnits; } }));\nObject.defineProperty(exports, \"parseUnits\", ({ enumerable: true, get: function () { return units_1.parseUnits; } }));\nvar wallet_1 = __webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib/index.js\");\nObject.defineProperty(exports, \"verifyMessage\", ({ enumerable: true, get: function () { return wallet_1.verifyMessage; } }));\nObject.defineProperty(exports, \"verifyTypedData\", ({ enumerable: true, get: function () { return wallet_1.verifyTypedData; } }));\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js\");\nObject.defineProperty(exports, \"_fetchData\", ({ enumerable: true, get: function () { return web_1._fetchData; } }));\nObject.defineProperty(exports, \"fetchJson\", ({ enumerable: true, get: function () { return web_1.fetchJson; } }));\nObject.defineProperty(exports, \"poll\", ({ enumerable: true, get: function () { return web_1.poll; } }));\n////////////////////////\n// Enums\nvar sha2_2 = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/index.js\");\nObject.defineProperty(exports, \"SupportedAlgorithm\", ({ enumerable: true, get: function () { return sha2_2.SupportedAlgorithm; } }));\nvar strings_2 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nObject.defineProperty(exports, \"UnicodeNormalizationForm\", ({ enumerable: true, get: function () { return strings_2.UnicodeNormalizationForm; } }));\nObject.defineProperty(exports, \"Utf8ErrorReason\", ({ enumerable: true, get: function () { return strings_2.Utf8ErrorReason; } }));\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLDRCQUE0QixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLDhCQUE4QixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0I7QUFDMWtDLGVBQWUsR0FBRyx1QkFBdUIsR0FBRyxnQ0FBZ0MsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyw0QkFBNEIsR0FBRyx3QkFBd0IsR0FBRyw0QkFBNEIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxtQkFBbUIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRyxVQUFVLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsMEJBQTBCO0FBQ2pvQyxZQUFZLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ3hDLDRDQUEyQyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUM3RyxxREFBb0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDL0gsdURBQXNELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQ25JLG1EQUFrRCxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUMzSCxpREFBZ0QsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDdkgsaURBQWdELEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3ZILCtDQUE4QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNuSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDN0csb0RBQW1ELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzdILDJDQUEwQyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUMzRyw2Q0FBNEMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDL0csa0RBQWlELEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3pILDZDQUE0QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMvRywwREFBeUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDekksZ0JBQWdCLG1CQUFPLENBQUMsNEdBQXdCO0FBQ2hELDhDQUE2QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNySCxxREFBb0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDbkksc0RBQXFELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3JJLGtEQUFpRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM3SCw2Q0FBNEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbkgsMEJBQTBCLG1CQUFPLENBQUMsMEdBQXVCO0FBQ3pELGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLDBDQUF5QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUMzRyxjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLDRDQUEyQyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUMvRywwQ0FBeUMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDM0csNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pILGdEQUErQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN2SCxpREFBZ0QsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDekgsMkNBQTBDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzdHLGlEQUFnRCxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN6SCw0Q0FBMkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDL0csOENBQTZDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ25ILDJDQUEwQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM3RywrQ0FBOEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDckgsK0NBQThDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3JILGlEQUFnRCxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN6SCwyQ0FBMEMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDN0csa0RBQWlELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzNILDhDQUE2QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNuSCxhQUFhLG1CQUFPLENBQUMsc0dBQXFCO0FBQzFDLHFEQUFvRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUNoSSwrQ0FBOEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDcEgsc0NBQXFDLEVBQUUscUNBQXFDLHFCQUFxQixFQUFDO0FBQ2xHLCtDQUE4QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNwSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDOUcsZUFBZSxtQkFBTyxDQUFDLHNGQUF1QjtBQUM5QywrQ0FBOEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdEgscURBQW9ELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ2xJLGtEQUFpRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM1SCwwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsbURBQWtELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzlILHFEQUFvRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNsSSxrREFBaUQsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDNUgscUJBQXFCLG1CQUFPLENBQUMsa0dBQTZCO0FBQzFELHdEQUF1RCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUM5SSxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDcEQsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLGFBQWEsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDMUMsK0NBQThDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ3BILDZDQUE0QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUNoSCwwQ0FBeUMsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDMUcsMENBQXlDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQzFHLGlCQUFpQixtQkFBTyxDQUFDLDBGQUF5QjtBQUNsRCxxREFBb0QsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDNUgsZ0RBQStDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQ2xILGtEQUFpRCxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUN0SCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLCtDQUE4QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN0SCw0Q0FBMkMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDaEgsbUJBQW1CLG1CQUFPLENBQUMsa0hBQTJCO0FBQ3RELG1EQUFrRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNsSSw0Q0FBMkMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDcEgsa0RBQWlELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2hJLDZDQUE0QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN0SCxxREFBb0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDdEksK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFILHVCQUF1QixtQkFBTyxDQUFDLG9HQUFvQjtBQUNuRCxXQUFXO0FBQ1gsb0JBQW9CLG1CQUFPLENBQUMsb0hBQTRCO0FBQ3hELG9EQUFtRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUNySSxvREFBbUQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDckksOENBQTZDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3pILGdCQUFnQixtQkFBTyxDQUFDLDRHQUF3QjtBQUNoRCx1REFBc0QsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDdkksNENBQTJDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2pILHNEQUFxRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNySSx3REFBdUQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDekksK0NBQThDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3ZILG9EQUFtRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNqSSxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsa0RBQWlELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzdILHFCQUFxQixtQkFBTyxDQUFDLHNIQUE2QjtBQUMxRCxpREFBZ0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDaEksa0RBQWlELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2xJLG9EQUFtRCxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUMzSCxrREFBaUQsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDbEksd0RBQXVELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ25JLG9EQUFtRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN0SSxjQUFjLG1CQUFPLENBQUMsb0ZBQXNCO0FBQzVDLDJDQUEwQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM3RywrQ0FBOEMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDckgsOENBQTZDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ25ILCtDQUE4QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNySCw4Q0FBNkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbkgsZUFBZSxtQkFBTyxDQUFDLHNGQUF1QjtBQUM5QyxpREFBZ0QsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDMUgsbURBQWtELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzlILFlBQVksbUJBQU8sQ0FBQyxvR0FBb0I7QUFDeEMsOENBQTZDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQ2pILDZDQUE0QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMvRyx3Q0FBdUMsRUFBRSxxQ0FBcUMsc0JBQXNCLEVBQUM7QUFDckc7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDMUMsc0RBQXFELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQ2xJLGdCQUFnQixtQkFBTyxDQUFDLDRHQUF3QjtBQUNoRCw0REFBMkQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDakosbURBQWtELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliL3V0aWxzLmpzPzMzM2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0Qnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSBleHBvcnRzLnRvVXRmOFN0cmluZyA9IGV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IGV4cG9ydHMudG9VdGY4Qnl0ZXMgPSBleHBvcnRzLl90b0VzY2FwZWRVdGY4U3RyaW5nID0gZXhwb3J0cy5uYW1lcHJlcCA9IGV4cG9ydHMuaGV4RGF0YVNsaWNlID0gZXhwb3J0cy5oZXhEYXRhTGVuZ3RoID0gZXhwb3J0cy5oZXhaZXJvUGFkID0gZXhwb3J0cy5oZXhWYWx1ZSA9IGV4cG9ydHMuaGV4U3RyaXBaZXJvcyA9IGV4cG9ydHMuaGV4Q29uY2F0ID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuaGV4bGlmeSA9IGV4cG9ydHMuYmFzZTY0ID0gZXhwb3J0cy5iYXNlNTggPSBleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gZXhwb3J0cy5JbnRlcmZhY2UgPSBleHBvcnRzLlNpZ25pbmdLZXkgPSBleHBvcnRzLkhETm9kZSA9IGV4cG9ydHMuZGVmYXVsdFBhdGggPSBleHBvcnRzLmlzQnl0ZXNMaWtlID0gZXhwb3J0cy5pc0J5dGVzID0gZXhwb3J0cy56ZXJvUGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZXhwb3J0cy5jb25jYXQgPSBleHBvcnRzLmFycmF5aWZ5ID0gZXhwb3J0cy5zaGFsbG93Q29weSA9IGV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSBleHBvcnRzLmdldFN0YXRpYyA9IGV4cG9ydHMuZGVmaW5lUmVhZE9ubHkgPSBleHBvcnRzLmRlZXBDb3B5ID0gZXhwb3J0cy5jaGVja1Byb3BlcnRpZXMgPSBleHBvcnRzLnBvbGwgPSBleHBvcnRzLmZldGNoSnNvbiA9IGV4cG9ydHMuX2ZldGNoRGF0YSA9IGV4cG9ydHMuUkxQID0gZXhwb3J0cy5Mb2dnZXIgPSBleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gZXhwb3J0cy5Gb3JtYXRUeXBlcyA9IGV4cG9ydHMuUGFyYW1UeXBlID0gZXhwb3J0cy5GdW5jdGlvbkZyYWdtZW50ID0gZXhwb3J0cy5FdmVudEZyYWdtZW50ID0gZXhwb3J0cy5FcnJvckZyYWdtZW50ID0gZXhwb3J0cy5Db25zdHJ1Y3RvckZyYWdtZW50ID0gZXhwb3J0cy5GcmFnbWVudCA9IGV4cG9ydHMuZGVmYXVsdEFiaUNvZGVyID0gZXhwb3J0cy5BYmlDb2RlciA9IHZvaWQgMDtcbmV4cG9ydHMuSW5kZXhlZCA9IGV4cG9ydHMuVXRmOEVycm9yUmVhc29uID0gZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSBleHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSA9IGV4cG9ydHMubW5lbW9uaWNUb1NlZWQgPSBleHBvcnRzLmlzVmFsaWRNbmVtb25pYyA9IGV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSBleHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGV4cG9ydHMudmVyaWZ5VHlwZWREYXRhID0gZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gZXhwb3J0cy5jb21wdXRlUHVibGljS2V5ID0gZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBleHBvcnRzLmdldEpzb25XYWxsZXRBZGRyZXNzID0gZXhwb3J0cy5UcmFuc2FjdGlvblR5cGVzID0gZXhwb3J0cy5zZXJpYWxpemVUcmFuc2FjdGlvbiA9IGV4cG9ydHMucGFyc2VUcmFuc2FjdGlvbiA9IGV4cG9ydHMuYWNjZXNzTGlzdGlmeSA9IGV4cG9ydHMuam9pblNpZ25hdHVyZSA9IGV4cG9ydHMuc3BsaXRTaWduYXR1cmUgPSBleHBvcnRzLnNvbGlkaXR5U2hhMjU2ID0gZXhwb3J0cy5zb2xpZGl0eUtlY2NhazI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrID0gZXhwb3J0cy5zaHVmZmxlZCA9IGV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMuY29tcHV0ZUhtYWMgPSBleHBvcnRzLmNvbW1pZnkgPSBleHBvcnRzLnBhcnNlVW5pdHMgPSBleHBvcnRzLmZvcm1hdFVuaXRzID0gZXhwb3J0cy5wYXJzZUV0aGVyID0gZXhwb3J0cy5mb3JtYXRFdGhlciA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q29udHJhY3RBZGRyZXNzID0gZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGV4cG9ydHMuZ2V0QWRkcmVzcyA9IGV4cG9ydHMuX1R5cGVkRGF0YUVuY29kZXIgPSBleHBvcnRzLmlkID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMubmFtZWhhc2ggPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gZXhwb3J0cy5wYXJzZUJ5dGVzMzJTdHJpbmcgPSB2b2lkIDA7XG52YXIgYWJpXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYWJpXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJpQ29kZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFiaV8xLkFiaUNvZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tSZXN1bHRFcnJvcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFiaV8xLmNoZWNrUmVzdWx0RXJyb3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29uc3RydWN0b3JGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpXzEuQ29uc3RydWN0b3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRBYmlDb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpXzEuZGVmYXVsdEFiaUNvZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpXzEuRXJyb3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50RnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFiaV8xLkV2ZW50RnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb3JtYXRUeXBlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpXzEuRm9ybWF0VHlwZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpXzEuRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbkZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmlfMS5GdW5jdGlvbkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5kZXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpXzEuSW5kZXhlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyZmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpXzEuSW50ZXJmYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFiaV8xLkxvZ0Rlc2NyaXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyYW1UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmlfMS5QYXJhbVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmlfMS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uOyB9IH0pO1xudmFyIGFkZHJlc3NfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmdldEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDcmVhdGUyQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmdldENyZWF0ZTJBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q29udHJhY3RBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzXzEuZ2V0Q29udHJhY3RBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SWNhcEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS5nZXRJY2FwQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmlzQWRkcmVzczsgfSB9KTtcbnZhciBiYXNlNjQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiKSk7XG5leHBvcnRzLmJhc2U2NCA9IGJhc2U2NDtcbnZhciBiYXNleF8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Jhc2V4XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmFzZTU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNleF8xLkJhc2U1ODsgfSB9KTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXJyYXlpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzXzEuYXJyYXlpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzXzEuY29uY2F0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4Q29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLmhleENvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleERhdGFTbGljZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXNfMS5oZXhEYXRhU2xpY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhEYXRhTGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLmhleERhdGFMZW5ndGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhsaWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLmhleGxpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhTdHJpcFplcm9zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLmhleFN0cmlwWmVyb3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXNfMS5oZXhWYWx1ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhleFplcm9QYWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzXzEuaGV4WmVyb1BhZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzXzEuaXNCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnl0ZXNMaWtlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLmlzQnl0ZXNMaWtlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzXzEuaXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJqb2luU2lnbmF0dXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLmpvaW5TaWduYXR1cmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ6ZXJvUGFkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlc18xLnplcm9QYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzcGxpdFNpZ25hdHVyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXNfMS5zcGxpdFNpZ25hdHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmlwWmVyb3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzXzEuc3RyaXBaZXJvczsgfSB9KTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9UeXBlZERhdGFFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoXzEuX1R5cGVkRGF0YUVuY29kZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYXNoTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF8xLmhhc2hNZXNzYWdlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hfMS5pZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWROYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoXzEuaXNWYWxpZE5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1laGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaF8xLm5hbWVoYXNoOyB9IH0pO1xudmFyIGhkbm9kZV8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2hkbm9kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZG5vZGVfMS5kZWZhdWx0UGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVudHJvcHlUb01uZW1vbmljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZG5vZGVfMS5lbnRyb3B5VG9NbmVtb25pYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEFjY291bnRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZG5vZGVfMS5nZXRBY2NvdW50UGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkhETm9kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGRub2RlXzEuSEROb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZE1uZW1vbmljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZG5vZGVfMS5pc1ZhbGlkTW5lbW9uaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtbmVtb25pY1RvRW50cm9weVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGRub2RlXzEubW5lbW9uaWNUb0VudHJvcHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtbmVtb25pY1RvU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGRub2RlXzEubW5lbW9uaWNUb1NlZWQ7IH0gfSk7XG52YXIganNvbl93YWxsZXRzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvanNvbi13YWxsZXRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SnNvbldhbGxldEFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fd2FsbGV0c18xLmdldEpzb25XYWxsZXRBZGRyZXNzOyB9IH0pO1xudmFyIGtlY2NhazI1Nl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImtlY2NhazI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2VjY2FrMjU2XzEua2VjY2FrMjU2OyB9IH0pO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ2dlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2VyXzEuTG9nZ2VyOyB9IH0pO1xudmFyIHNoYTJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9zaGEyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZUhtYWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYTJfMS5jb21wdXRlSG1hYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcGVtZDE2MFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl8xLnJpcGVtZDE2MDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl8xLnNoYTI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTUxMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl8xLnNoYTUxMjsgfSB9KTtcbnZhciBzb2xpZGl0eV8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3NvbGlkaXR5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlLZWNjYWsyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvbGlkaXR5XzEua2VjY2FrMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2xpZGl0eV8xLnBhY2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29saWRpdHlfMS5zaGEyNTY7IH0gfSk7XG52YXIgcmFuZG9tXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcmFuZG9tXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmFuZG9tQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmRvbV8xLnJhbmRvbUJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2h1ZmZsZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhbmRvbV8xLnNodWZmbGVkOyB9IH0pO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tQcm9wZXJ0aWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wZXJ0aWVzXzEuY2hlY2tQcm9wZXJ0aWVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVlcENvcHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BlcnRpZXNfMS5kZWVwQ29weTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmluZVJlYWRPbmx5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRTdGF0aWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BlcnRpZXNfMS5nZXRTdGF0aWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlUHJvcGVydGllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhbGxvd0NvcHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weTsgfSB9KTtcbnZhciBSTFAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3JscFwiKSk7XG5leHBvcnRzLlJMUCA9IFJMUDtcbnZhciBzaWduaW5nX2tleV8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZVB1YmxpY0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmluZ19rZXlfMS5jb21wdXRlUHVibGljS2V5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVjb3ZlclB1YmxpY0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmluZ19rZXlfMS5yZWNvdmVyUHVibGljS2V5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmluZ0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmluZ19rZXlfMS5TaWduaW5nS2V5OyB9IH0pO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0Qnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nc18xLmZvcm1hdEJ5dGVzMzJTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1lcHJlcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nc18xLm5hbWVwcmVwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzXzEucGFyc2VCeXRlczMyU3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX3RvRXNjYXBlZFV0ZjhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ3NfMS5fdG9Fc2NhcGVkVXRmOFN0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzXzEudG9VdGY4Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhDb2RlUG9pbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzXzEudG9VdGY4Q29kZVBvaW50czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5nc18xLnRvVXRmOFN0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0ZjhFcnJvckZ1bmNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzXzEuVXRmOEVycm9yRnVuY3M7IH0gfSk7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWNjZXNzTGlzdGlmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNhY3Rpb25zXzEuYWNjZXNzTGlzdGlmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXB1dGVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc2FjdGlvbnNfMS5jb21wdXRlQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uc18xLnBhcnNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVjb3ZlckFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uc18xLnJlY292ZXJBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VyaWFsaXplVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uc18xLnNlcmlhbGl6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uVHlwZXM7IH0gfSk7XG52YXIgdW5pdHNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC91bml0c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbW1pZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzXzEuY29tbWlmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdEV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c18xLmZvcm1hdEV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHNfMS5wYXJzZUV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0VW5pdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzXzEuZm9ybWF0VW5pdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVVuaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c18xLnBhcnNlVW5pdHM7IH0gfSk7XG52YXIgd2FsbGV0XzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qvd2FsbGV0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5TWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2FsbGV0XzEudmVyaWZ5TWVzc2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcmlmeVR5cGVkRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2FsbGV0XzEudmVyaWZ5VHlwZWREYXRhOyB9IH0pO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9mZXRjaERhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYl8xLl9mZXRjaERhdGE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmZXRjaEpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYl8xLmZldGNoSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBvbGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYl8xLnBvbGw7IH0gfSk7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEVudW1zXG52YXIgc2hhMl8yID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3NoYTJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdXBwb3J0ZWRBbGdvcml0aG1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYTJfMi5TdXBwb3J0ZWRBbGdvcml0aG07IH0gfSk7XG52YXIgc3RyaW5nc18yID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ3NfMi5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGY4RXJyb3JSZWFzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ3NfMi5VdGY4RXJyb3JSZWFzb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/_version.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/_version.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"abstract-provider/5.5.1\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIvX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIvX3ZlcnNpb24uanM/MzRjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbmV4cG9ydHMudmVyc2lvbiA9IFwiYWJzdHJhY3QtcHJvdmlkZXIvNS41LjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/index.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Provider = exports.TransactionOrderForkEvent = exports.TransactionForkEvent = exports.BlockForkEvent = exports.ForkEvent = void 0;\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nvar ForkEvent = /** @class */ (function (_super) {\n    __extends(ForkEvent, _super);\n    function ForkEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ForkEvent.isForkEvent = function (value) {\n        return !!(value && value._isForkEvent);\n    };\n    return ForkEvent;\n}(properties_1.Description));\nexports.ForkEvent = ForkEvent;\nvar BlockForkEvent = /** @class */ (function (_super) {\n    __extends(BlockForkEvent, _super);\n    function BlockForkEvent(blockHash, expiry) {\n        var _this = this;\n        if (!(0, bytes_1.isHexString)(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        _this = _super.call(this, {\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        }) || this;\n        return _this;\n    }\n    return BlockForkEvent;\n}(ForkEvent));\nexports.BlockForkEvent = BlockForkEvent;\nvar TransactionForkEvent = /** @class */ (function (_super) {\n    __extends(TransactionForkEvent, _super);\n    function TransactionForkEvent(hash, expiry) {\n        var _this = this;\n        if (!(0, bytes_1.isHexString)(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        _this = _super.call(this, {\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        }) || this;\n        return _this;\n    }\n    return TransactionForkEvent;\n}(ForkEvent));\nexports.TransactionForkEvent = TransactionForkEvent;\nvar TransactionOrderForkEvent = /** @class */ (function (_super) {\n    __extends(TransactionOrderForkEvent, _super);\n    function TransactionOrderForkEvent(beforeHash, afterHash, expiry) {\n        var _this = this;\n        if (!(0, bytes_1.isHexString)(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!(0, bytes_1.isHexString)(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        _this = _super.call(this, {\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        }) || this;\n        return _this;\n    }\n    return TransactionOrderForkEvent;\n}(ForkEvent));\nexports.TransactionOrderForkEvent = TransactionOrderForkEvent;\n///////////////////////////////\n// Exported Abstracts\nvar Provider = /** @class */ (function () {\n    function Provider() {\n        var _newTarget = this.constructor;\n        logger.checkAbstract(_newTarget, Provider);\n        (0, properties_1.defineReadOnly)(this, \"_isProvider\", true);\n    }\n    Provider.prototype.getFeeData = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, block, gasPrice, maxFeePerGas, maxPriorityFeePerGas;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                            block: this.getBlock(\"latest\"),\n                            gasPrice: this.getGasPrice().catch(function (error) {\n                                // @TODO: Why is this now failing on Calaveras?\n                                //console.log(error);\n                                return null;\n                            })\n                        })];\n                    case 1:\n                        _a = _b.sent(), block = _a.block, gasPrice = _a.gasPrice;\n                        maxFeePerGas = null, maxPriorityFeePerGas = null;\n                        if (block && block.baseFeePerGas) {\n                            // We may want to compute this more accurately in the future,\n                            // using the formula \"check if the base fee is correct\".\n                            // See: https://eips.ethereum.org/EIPS/eip-1559\n                            maxPriorityFeePerGas = bignumber_1.BigNumber.from(\"2500000000\");\n                            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n                        }\n                        return [2 /*return*/, { maxFeePerGas: maxFeePerGas, maxPriorityFeePerGas: maxPriorityFeePerGas, gasPrice: gasPrice }];\n                }\n            });\n        });\n    };\n    // Alias for \"on\"\n    Provider.prototype.addListener = function (eventName, listener) {\n        return this.on(eventName, listener);\n    };\n    // Alias for \"off\"\n    Provider.prototype.removeListener = function (eventName, listener) {\n        return this.off(eventName, listener);\n    };\n    Provider.isProvider = function (value) {\n        return !!(value && value._isProvider);\n    };\n    return Provider;\n}());\nexports.Provider = Provider;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGlDQUFpQyxHQUFHLDRCQUE0QixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQjtBQUNoSSxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLDBHQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyw2R0FBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRGQUE0RjtBQUM1STtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyL2xpYi9pbmRleC5qcz8wNzhjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb3ZpZGVyID0gZXhwb3J0cy5UcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50ID0gZXhwb3J0cy5UcmFuc2FjdGlvbkZvcmtFdmVudCA9IGV4cG9ydHMuQmxvY2tGb3JrRXZlbnQgPSBleHBvcnRzLkZvcmtFdmVudCA9IHZvaWQgMDtcbnZhciBiaWdudW1iZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbjtcbjtcbi8vZXhwb3J0IHR5cGUgQ2FsbFRyYW5zYWN0aW9uYWJsZSA9IHtcbi8vICAgIGNhbGwodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8VHJhbnNhY3Rpb25SZXNwb25zZT47XG4vL307XG52YXIgRm9ya0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGb3JrRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ya0V2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEZvcmtFdmVudC5pc0ZvcmtFdmVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRm9ya0V2ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBGb3JrRXZlbnQ7XG59KHByb3BlcnRpZXNfMS5EZXNjcmlwdGlvbikpO1xuZXhwb3J0cy5Gb3JrRXZlbnQgPSBGb3JrRXZlbnQ7XG52YXIgQmxvY2tGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrRm9ya0V2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrRm9ya0V2ZW50KGJsb2NrSGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGJsb2NrSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIiwgXCJibG9ja0hhc2hcIiwgYmxvY2tIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc0Jsb2NrRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBibG9ja0hhc2hcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQmxvY2tGb3JrRXZlbnQ7XG59KEZvcmtFdmVudCkpO1xuZXhwb3J0cy5CbG9ja0ZvcmtFdmVudCA9IEJsb2NrRm9ya0V2ZW50O1xudmFyIFRyYW5zYWN0aW9uRm9ya0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFuc2FjdGlvbkZvcmtFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkZvcmtFdmVudChoYXNoLCBleHBpcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoaGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiaGFzaFwiLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc1RyYW5zYWN0aW9uRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgaGFzaDogaGFzaFxuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2FjdGlvbkZvcmtFdmVudDtcbn0oRm9ya0V2ZW50KSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uRm9ya0V2ZW50ID0gVHJhbnNhY3Rpb25Gb3JrRXZlbnQ7XG52YXIgVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50KGJlZm9yZUhhc2gsIGFmdGVySGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGJlZm9yZUhhc2gsIDMyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24gaGFzaFwiLCBcImJlZm9yZUhhc2hcIiwgYmVmb3JlSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoYWZ0ZXJIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJhZnRlckhhc2hcIiwgYWZ0ZXJIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc1RyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBleHBpcnk6IChleHBpcnkgfHwgMCksXG4gICAgICAgICAgICBiZWZvcmVIYXNoOiBiZWZvcmVIYXNoLFxuICAgICAgICAgICAgYWZ0ZXJIYXNoOiBhZnRlckhhc2hcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDtcbn0oRm9ya0V2ZW50KSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgPSBUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXhwb3J0ZWQgQWJzdHJhY3RzXG52YXIgUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXIoKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QoX25ld1RhcmdldCwgUHJvdmlkZXIpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9pc1Byb3ZpZGVyXCIsIHRydWUpO1xuICAgIH1cbiAgICBQcm92aWRlci5wcm90b3R5cGUuZ2V0RmVlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBibG9jaywgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jazogdGhpcy5nZXRCbG9jayhcImxhdGVzdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nZXRHYXNQcmljZSgpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2h5IGlzIHRoaXMgbm93IGZhaWxpbmcgb24gQ2FsYXZlcmFzP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIGJsb2NrID0gX2EuYmxvY2ssIGdhc1ByaWNlID0gX2EuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSBudWxsLCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1heSB3YW50IHRvIGNvbXB1dGUgdGhpcyBtb3JlIGFjY3VyYXRlbHkgaW4gdGhlIGZ1dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyB0aGUgZm9ybXVsYSBcImNoZWNrIGlmIHRoZSBiYXNlIGZlZSBpcyBjb3JyZWN0XCIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKFwiMjUwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSBibG9jay5iYXNlRmVlUGVyR2FzLm11bCgyKS5hZGQobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhcywgZ2FzUHJpY2U6IGdhc1ByaWNlIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBQcm92aWRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgUHJvdmlkZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gICAgUHJvdmlkZXIuaXNQcm92aWRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzUHJvdmlkZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvdmlkZXIgPSBQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/_version.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/_version.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"abstract-signer/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi9fdmVyc2lvbi5qcz84ZTRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJhYnN0cmFjdC1zaWduZXIvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/index.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VoidSigner = exports.Signer = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar allowedTransactionKeys = [\n    \"accessList\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\nvar forwardErrors = [\n    logger_1.Logger.errors.INSUFFICIENT_FUNDS,\n    logger_1.Logger.errors.NONCE_EXPIRED,\n    logger_1.Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n;\n;\nvar Signer = /** @class */ (function () {\n    ///////////////////\n    // Sub-classes MUST call super\n    function Signer() {\n        var _newTarget = this.constructor;\n        logger.checkAbstract(_newTarget, Signer);\n        (0, properties_1.defineReadOnly)(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    Signer.prototype.getBalance = function (blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"getBalance\");\n                        return [4 /*yield*/, this.provider.getBalance(this.getAddress(), blockTag)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    Signer.prototype.getTransactionCount = function (blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"getTransactionCount\");\n                        return [4 /*yield*/, this.provider.getTransactionCount(this.getAddress(), blockTag)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    Signer.prototype.estimateGas = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"estimateGas\");\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];\n                    case 1:\n                        tx = _a.sent();\n                        return [4 /*yield*/, this.provider.estimateGas(tx)];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    // Populates \"from\" if unspecified, and calls with the transaction\n    Signer.prototype.call = function (transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"call\");\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];\n                    case 1:\n                        tx = _a.sent();\n                        return [4 /*yield*/, this.provider.call(tx, blockTag)];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    // Populates all fields in a transaction, signs it and sends it to the network\n    Signer.prototype.sendTransaction = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, signedTx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"sendTransaction\");\n                        return [4 /*yield*/, this.populateTransaction(transaction)];\n                    case 1:\n                        tx = _a.sent();\n                        return [4 /*yield*/, this.signTransaction(tx)];\n                    case 2:\n                        signedTx = _a.sent();\n                        return [4 /*yield*/, this.provider.sendTransaction(signedTx)];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    Signer.prototype.getChainId = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var network;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"getChainId\");\n                        return [4 /*yield*/, this.provider.getNetwork()];\n                    case 1:\n                        network = _a.sent();\n                        return [2 /*return*/, network.chainId];\n                }\n            });\n        });\n    };\n    Signer.prototype.getGasPrice = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"getGasPrice\");\n                        return [4 /*yield*/, this.provider.getGasPrice()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    Signer.prototype.getFeeData = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"getFeeData\");\n                        return [4 /*yield*/, this.provider.getFeeData()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    Signer.prototype.resolveName = function (name) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._checkProvider(\"resolveName\");\n                        return [4 /*yield*/, this.provider.resolveName(name)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    Signer.prototype.checkTransaction = function (transaction) {\n        for (var key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        var tx = (0, properties_1.shallowCopy)(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        }\n        else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then(function (result) {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    };\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    Signer.prototype.populateTransaction = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, hasEip1559, feeData, gasPrice;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];\n                    case 1:\n                        tx = _a.sent();\n                        if (tx.to != null) {\n                            tx.to = Promise.resolve(tx.to).then(function (to) { return __awaiter(_this, void 0, void 0, function () {\n                                var address;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            if (to == null) {\n                                                return [2 /*return*/, null];\n                                            }\n                                            return [4 /*yield*/, this.resolveName(to)];\n                                        case 1:\n                                            address = _a.sent();\n                                            if (address == null) {\n                                                logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                                            }\n                                            return [2 /*return*/, address];\n                                    }\n                                });\n                            }); });\n                            // Prevent this error from causing an UnhandledPromiseException\n                            tx.to.catch(function (error) { });\n                        }\n                        hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n                        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n                        }\n                        else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n                        }\n                        if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null))) return [3 /*break*/, 2];\n                        // Fully-formed EIP-1559 transaction (skip getFeeData)\n                        tx.type = 2;\n                        return [3 /*break*/, 5];\n                    case 2:\n                        if (!(tx.type === 0 || tx.type === 1)) return [3 /*break*/, 3];\n                        // Explicit Legacy or EIP-2930 transaction\n                        // Populate missing gasPrice\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = this.getGasPrice();\n                        }\n                        return [3 /*break*/, 5];\n                    case 3: return [4 /*yield*/, this.getFeeData()];\n                    case 4:\n                        feeData = _a.sent();\n                        if (tx.type == null) {\n                            // We need to auto-detect the intended type of this transaction...\n                            if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                                // The network supports EIP-1559!\n                                // Upgrade transaction from null to eip-1559\n                                tx.type = 2;\n                                if (tx.gasPrice != null) {\n                                    gasPrice = tx.gasPrice;\n                                    delete tx.gasPrice;\n                                    tx.maxFeePerGas = gasPrice;\n                                    tx.maxPriorityFeePerGas = gasPrice;\n                                }\n                                else {\n                                    // Populate missing fee data\n                                    if (tx.maxFeePerGas == null) {\n                                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                                    }\n                                    if (tx.maxPriorityFeePerGas == null) {\n                                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                                    }\n                                }\n                            }\n                            else if (feeData.gasPrice != null) {\n                                // Network doesn't support EIP-1559...\n                                // ...but they are trying to use EIP-1559 properties\n                                if (hasEip1559) {\n                                    logger.throwError(\"network does not support EIP-1559\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                        operation: \"populateTransaction\"\n                                    });\n                                }\n                                // Populate missing fee data\n                                if (tx.gasPrice == null) {\n                                    tx.gasPrice = feeData.gasPrice;\n                                }\n                                // Explicitly set untyped transaction to legacy\n                                tx.type = 0;\n                            }\n                            else {\n                                // getFeeData has failed us.\n                                logger.throwError(\"failed to get consistent fee data\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                    operation: \"signer.getFeeData\"\n                                });\n                            }\n                        }\n                        else if (tx.type === 2) {\n                            // Explicitly using EIP-1559\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                        _a.label = 5;\n                    case 5:\n                        if (tx.nonce == null) {\n                            tx.nonce = this.getTransactionCount(\"pending\");\n                        }\n                        if (tx.gasLimit == null) {\n                            tx.gasLimit = this.estimateGas(tx).catch(function (error) {\n                                if (forwardErrors.indexOf(error.code) >= 0) {\n                                    throw error;\n                                }\n                                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                                    error: error,\n                                    tx: tx\n                                });\n                            });\n                        }\n                        if (tx.chainId == null) {\n                            tx.chainId = this.getChainId();\n                        }\n                        else {\n                            tx.chainId = Promise.all([\n                                Promise.resolve(tx.chainId),\n                                this.getChainId()\n                            ]).then(function (results) {\n                                if (results[1] !== 0 && results[0] !== results[1]) {\n                                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                                }\n                                return results[0];\n                            });\n                        }\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)(tx)];\n                    case 6: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    Signer.prototype._checkProvider = function (operation) {\n        if (!this.provider) {\n            logger.throwError(\"missing provider\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: (operation || \"_checkProvider\")\n            });\n        }\n    };\n    Signer.isSigner = function (value) {\n        return !!(value && value._isSigner);\n    };\n    return Signer;\n}());\nexports.Signer = Signer;\nvar VoidSigner = /** @class */ (function (_super) {\n    __extends(VoidSigner, _super);\n    function VoidSigner(address, provider) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, VoidSigner);\n        _this = _super.call(this) || this;\n        (0, properties_1.defineReadOnly)(_this, \"address\", address);\n        (0, properties_1.defineReadOnly)(_this, \"provider\", provider || null);\n        return _this;\n    }\n    VoidSigner.prototype.getAddress = function () {\n        return Promise.resolve(this.address);\n    };\n    VoidSigner.prototype._fail = function (message, operation) {\n        return Promise.resolve().then(function () {\n            logger.throwError(message, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    };\n    VoidSigner.prototype.signMessage = function (message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    };\n    VoidSigner.prototype.signTransaction = function (transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    };\n    VoidSigner.prototype._signTypedData = function (domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    };\n    VoidSigner.prototype.connect = function (provider) {\n        return new VoidSigner(this.address, provider);\n    };\n    return VoidSigner;\n}(Signer));\nexports.VoidSigner = VoidSigner;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxjQUFjO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLGtIQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLElBQUk7QUFDakM7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixzQkFBc0I7QUFDN0csU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIvaW5kZXguanM/OWUzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXhwb3J0cy5TaWduZXIgPSB2b2lkIDA7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCIpO1xudmFyIF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvblwiKTtcbnZhciBsb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKF92ZXJzaW9uXzEudmVyc2lvbik7XG52YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IFtcbiAgICBcImFjY2Vzc0xpc3RcIiwgXCJjaGFpbklkXCIsIFwiY3VzdG9tRGF0YVwiLCBcImRhdGFcIiwgXCJmcm9tXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ0b1wiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiXG5dO1xudmFyIGZvcndhcmRFcnJvcnMgPSBbXG4gICAgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsXG4gICAgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELFxuICAgIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsXG5dO1xuO1xuO1xudmFyIFNpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTVVTVCBjYWxsIHN1cGVyXG4gICAgZnVuY3Rpb24gU2lnbmVyKCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KF9uZXdUYXJnZXQsIFNpZ25lcik7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2lzU2lnbmVyXCIsIHRydWUpO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTUFZIG92ZXJyaWRlIHRoZXNlXG4gICAgU2lnbmVyLnByb3RvdHlwZS5nZXRCYWxhbmNlID0gZnVuY3Rpb24gKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb25Db3VudCA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBlc3RpbWF0ZXMgdGhlIGdhcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgU2lnbmVyLnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHg7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh0eCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGNhbGxzIHdpdGggdGhlIHRyYW5zYWN0aW9uXG4gICAgU2lnbmVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHg7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiY2FsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmNhbGwodHgsIGJsb2NrVGFnKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gUG9wdWxhdGVzIGFsbCBmaWVsZHMgaW4gYSB0cmFuc2FjdGlvbiwgc2lnbnMgaXQgYW5kIHNlbmRzIGl0IHRvIHRoZSBuZXR3b3JrXG4gICAgU2lnbmVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHR4LCBzaWduZWRUeDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduZWRUeCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2lnbmVyLnByb3RvdHlwZS5nZXRDaGFpbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV0d29yaztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRDaGFpbklkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldHdvcmsuY2hhaW5JZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2lnbmVyLnByb3RvdHlwZS5nZXRHYXNQcmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEdhc1ByaWNlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLmdldEZlZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRGZWVEYXRhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5nZXRGZWVEYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUucmVzb2x2ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBDaGVja3MgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBjb250YWluIGludmFsaWQga2V5cyBhbmQgaWZcbiAgICAvLyBubyBcImZyb21cIiBpcyBwcm92aWRlZCwgcG9wdWxhdGVzIGl0LlxuICAgIC8vIC0gZG9lcyBOT1QgcmVxdWlyZSBhIHByb3ZpZGVyXG4gICAgLy8gLSBhZGRzIFwiZnJvbVwiIGlzIG5vdCBwcmVzZW50XG4gICAgLy8gLSByZXR1cm5zIGEgQ09QWSAoc2FmZSB0byBtdXRhdGUgdGhlIHJlc3VsdClcbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gY2FsbFxuICAgIC8vICAgLSBlc3RpbWF0ZUdhc1xuICAgIC8vICAgLSBwb3B1bGF0ZVRyYW5zYWN0aW9uIChhbmQgdGhlcmVmb3Igc2VuZFRyYW5zYWN0aW9uKVxuICAgIFNpZ25lci5wcm90b3R5cGUuY2hlY2tUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkVHJhbnNhY3Rpb25LZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBrZXk6IFwiICsga2V5LCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHggPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmICh0eC5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgcHJvdmlkZWQgYWRkcmVzcyBtYXRjaGVzIHRoaXMgc2lnbmVyXG4gICAgICAgICAgICB0eC5mcm9tID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5mcm9tKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEFkZHJlc3MoKVxuICAgICAgICAgICAgXSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFswXS50b0xvd2VyQ2FzZSgpICE9PSByZXN1bHRbMV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH07XG4gICAgLy8gUG9wdWxhdGVzIEFMTCBrZXlzIGZvciBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja3MgdGhhdCBcImZyb21cIiBtYXRjaGVzXG4gICAgLy8gdGhpcyBTaWduZXIuIFNob3VsZCBiZSB1c2VkIGJ5IHNlbmRUcmFuc2FjdGlvbiBidXQgTk9UIGJ5IHNpZ25UcmFuc2FjdGlvbi5cbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gc2VuZFRyYW5zYWN0aW9uXG4gICAgLy9cbiAgICAvLyBOb3RlczpcbiAgICAvLyAgLSBXZSBhbGxvdyBnYXNQcmljZSBmb3IgRUlQLTE1NTkgYXMgbG9uZyBhcyBpdCBtYXRjaGVzIG1heEZlZVBlckdhc1xuICAgIFNpZ25lci5wcm90b3R5cGUucG9wdWxhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHgsIGhhc0VpcDE1NTksIGZlZURhdGEsIGdhc1ByaWNlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykodGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgudG8gPSBQcm9taXNlLnJlc29sdmUodHgudG8pLnRoZW4oZnVuY3Rpb24gKHRvKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUodG8pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhZGRyZXNzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdGhpcyBlcnJvciBmcm9tIGNhdXNpbmcgYW4gVW5oYW5kbGVkUHJvbWlzZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LnRvLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0VpcDE1NTkgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCAmJiAodHgudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0eC50eXBlID09PSAwIHx8IHR4LnR5cGUgPT09IDEpICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCh0eC50eXBlID09PSAyIHx8IHR4LnR5cGUgPT0gbnVsbCkgJiYgKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LnR5cGUgPT09IDAgfHwgdHgudHlwZSA9PT0gMSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGdhc1ByaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gdGhpcy5nZXRHYXNQcmljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRGZWVEYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWVEYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgRUlQLTE1NTkuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubm9uY2UgPSB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQoXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IHRoaXMuZXN0aW1hdGVHYXModHgpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZEVycm9ycy5pbmRleE9mKGVycm9yLmNvZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHg6IHR4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpbklkKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzWzFdICE9PSAwICYmIHJlc3VsdHNbMF0gIT09IHJlc3VsdHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh0eCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBTdWItY2xhc3NlcyBTSE9VTEQgbGVhdmUgdGhlc2UgYWxvbmVcbiAgICBTaWduZXIucHJvdG90eXBlLl9jaGVja1Byb3ZpZGVyID0gZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogKG9wZXJhdGlvbiB8fCBcIl9jaGVja1Byb3ZpZGVyXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2lnbmVyLmlzU2lnbmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNTaWduZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFNpZ25lcjtcbn0oKSk7XG5leHBvcnRzLlNpZ25lciA9IFNpZ25lcjtcbnZhciBWb2lkU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWb2lkU2lnbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZvaWRTaWduZXIoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgVm9pZFNpZ25lcik7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVm9pZFNpZ25lci5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFkZHJlc3MpO1xuICAgIH07XG4gICAgVm9pZFNpZ25lci5wcm90b3R5cGUuX2ZhaWwgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogb3BlcmF0aW9uIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZvaWRTaWduZXIucHJvdG90eXBlLnNpZ25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIG1lc3NhZ2VzXCIsIFwic2lnbk1lc3NhZ2VcIik7XG4gICAgfTtcbiAgICBWb2lkU2lnbmVyLnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIHRyYW5zYWN0aW9uc1wiLCBcInNpZ25UcmFuc2FjdGlvblwiKTtcbiAgICB9O1xuICAgIFZvaWRTaWduZXIucHJvdG90eXBlLl9zaWduVHlwZWREYXRhID0gZnVuY3Rpb24gKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0eXBlZCBkYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9O1xuICAgIFZvaWRTaWduZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFZvaWRTaWduZXI7XG59KFNpZ25lcikpO1xuZXhwb3J0cy5Wb2lkU2lnbmVyID0gVm9pZFNpZ25lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/_version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/address/lib/_version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"address/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hZGRyZXNzL2xpYi9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliL192ZXJzaW9uLmpzPzVmNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSBcImFkZHJlc3MvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/address/lib/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\");\nvar rlp_1 = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction getChecksumAddress(address) {\n    if (!(0, bytes_1.isHexString)(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    var chars = address.substring(2).split(\"\");\n    var expanded = new Uint8Array(40);\n    for (var i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));\n    for (var i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nvar ibanLookup = {};\nfor (var i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (var i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    var expanded = address.split(\"\").map(function (c) { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        var block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    var checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    var result = null;\n    if (typeof (address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (0, bignumber_1._base36To16)(address.substring(4));\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nexports.getAddress = getAddress;\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isAddress = isAddress;\nfunction getIcapAddress(address) {\n    var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\nexports.getIcapAddress = getIcapAddress;\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    var from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));\n}\nexports.getContractAddress = getContractAddress;\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if ((0, bytes_1.hexDataLength)(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\nexports.getCreate2Address = getCreate2Address;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hZGRyZXNzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0I7QUFDeEgsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMsZ0hBQTBCO0FBQ3BELFlBQVksbUJBQU8sQ0FBQyxvR0FBb0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLDBHQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxtR0FBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRSxZQUFZLE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hZGRyZXNzL2xpYi9pbmRleC5qcz82ZDRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q29udHJhY3RBZGRyZXNzID0gZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5nZXRBZGRyZXNzID0gdm9pZCAwO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGtlY2NhazI1Nl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiKTtcbnZhciBybHBfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ybHBcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCIpO1xudmFyIF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvblwiKTtcbnZhciBsb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKF92ZXJzaW9uXzEudmVyc2lvbik7XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICghKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGFkZHJlc3MsIDIwKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICB2YXIgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIGV4cGFuZGVkW2ldID0gY2hhcnNbaV0uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgdmFyIGhhc2hlZCA9ICgwLCBieXRlc18xLmFycmF5aWZ5KSgoMCwga2VjY2FrMjU2XzEua2VjY2FrMjU2KShleHBhbmRlZCkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTaGltcyBmb3IgZW52aXJvbm1lbnRzIHRoYXQgYXJlIG1pc3Npbmcgc29tZSByZXF1aXJlZCBjb25zdGFudHMgYW5kIGZ1bmN0aW9uc1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmO1xuZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIGlmIChNYXRoLmxvZzEwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzEwKHgpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxudmFyIGliYW5Mb29rdXAgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAodmFyIGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxudmFyIHNhZmVEaWdpdHMgPSBNYXRoLmZsb29yKGxvZzEwKE1BWF9TQUZFX0lOVEVHRVIpKTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICB2YXIgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5mdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgJiYgcmVzdWx0ICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZHJlc3MubWF0Y2goL15YRVswLTldezJ9WzAtOUEtWmEtel17MzAsMzF9JC8pKSB7XG4gICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSAhPT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9ICgwLCBiaWdudW1iZXJfMS5fYmFzZTM2VG8xNikoYWRkcmVzcy5zdWJzdHJpbmcoNCkpO1xuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDQwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRBZGRyZXNzID0gZ2V0QWRkcmVzcztcbmZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0FkZHJlc3MgPSBpc0FkZHJlc3M7XG5mdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdmFyIGJhc2UzNiA9ICgwLCBiaWdudW1iZXJfMS5fYmFzZTE2VG8zNikoZ2V0QWRkcmVzcyhhZGRyZXNzKS5zdWJzdHJpbmcoMikpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG5leHBvcnRzLmdldEljYXBBZGRyZXNzID0gZ2V0SWNhcEFkZHJlc3M7XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbmZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgIHZhciBmcm9tID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBmcm9tID0gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgdmFyIG5vbmNlID0gKDAsIGJ5dGVzXzEuc3RyaXBaZXJvcykoKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLm5vbmNlKS50b0hleFN0cmluZygpKSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoKDAsIGJ5dGVzXzEuaGV4RGF0YVNsaWNlKSgoMCwga2VjY2FrMjU2XzEua2VjY2FrMjU2KSgoMCwgcmxwXzEuZW5jb2RlKShbZnJvbSwgbm9uY2VdKSksIDEyKSk7XG59XG5leHBvcnRzLmdldENvbnRyYWN0QWRkcmVzcyA9IGdldENvbnRyYWN0QWRkcmVzcztcbmZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaCkge1xuICAgIGlmICgoMCwgYnl0ZXNfMS5oZXhEYXRhTGVuZ3RoKShzYWx0KSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgc2FsdCk7XG4gICAgfVxuICAgIGlmICgoMCwgYnl0ZXNfMS5oZXhEYXRhTGVuZ3RoKShpbml0Q29kZUhhc2gpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJpbml0Q29kZUhhc2hcIiwgaW5pdENvZGVIYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoKDAsIGJ5dGVzXzEuaGV4RGF0YVNsaWNlKSgoMCwga2VjY2FrMjU2XzEua2VjY2FrMjU2KSgoMCwgYnl0ZXNfMS5jb25jYXQpKFtcIjB4ZmZcIiwgZ2V0QWRkcmVzcyhmcm9tKSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGdldENyZWF0ZTJBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib/base64.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/base64/lib/base64.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nfunction decode(textData) {\n    return (0, bytes_1.arrayify)(new Uint8Array(Buffer.from(textData, \"base64\")));\n}\nexports.decode = decode;\n;\nfunction encode(data) {\n    return Buffer.from((0, bytes_1.arrayify)(data)).toString(\"base64\");\n}\nexports.encode = encode;\n//# sourceMappingURL=base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNlNjQvbGliL2Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNlNjQvbGliL2Jhc2U2NC5qcz85ZDY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xuZnVuY3Rpb24gZGVjb2RlKHRleHREYXRhKSB7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmFycmF5aWZ5KShuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSh0ZXh0RGF0YSwgXCJiYXNlNjRcIikpKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGRhdGEpKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/base64/lib/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = void 0;\nvar base64_1 = __webpack_require__(/*! ./base64 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib/base64.js\");\nObject.defineProperty(exports, \"decode\", ({ enumerable: true, get: function () { return base64_1.decode; } }));\nObject.defineProperty(exports, \"encode\", ({ enumerable: true, get: function () { return base64_1.encode; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNlNjQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyw4RkFBVTtBQUNqQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2U2NC9saWIvaW5kZXguanM/OWNiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5kZWNvZGUgPSB2b2lkIDA7XG52YXIgYmFzZTY0XzEgPSByZXF1aXJlKFwiLi9iYXNlNjRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2U2NF8xLmRlY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTY0XzEuZW5jb2RlOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/basex/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/basex/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Base58 = exports.Base32 = exports.BaseX = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar BaseX = /** @class */ (function () {\n    function BaseX(alphabet) {\n        (0, properties_1.defineReadOnly)(this, \"alphabet\", alphabet);\n        (0, properties_1.defineReadOnly)(this, \"base\", alphabet.length);\n        (0, properties_1.defineReadOnly)(this, \"_alphabetMap\", {});\n        (0, properties_1.defineReadOnly)(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (var i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    BaseX.prototype.encode = function (value) {\n        var source = (0, bytes_1.arrayify)(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        var digits = [0];\n        for (var i = 0; i < source.length; ++i) {\n            var carry = source[i];\n            for (var j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        var string = \"\";\n        // deal with leading zeros\n        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (var q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    };\n    BaseX.prototype.decode = function (value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        var bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (var i = 0; i < value.length; i++) {\n            var byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            var carry = byte;\n            for (var j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return (0, bytes_1.arrayify)(new Uint8Array(bytes.reverse()));\n    };\n    return BaseX;\n}());\nexports.BaseX = BaseX;\nvar Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nexports.Base32 = Base32;\nvar Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexports.Base58 = Base58;\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNleC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWE7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQ0FBMEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1EQUFtRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZXgvbGliL2luZGV4LmpzPzdiOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIHZhciBiYXNleCA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGJhc2VkIG9uIGJhc2UteC4gVGhlIG1haW4gcmVhc29uIHRvXG4gKiBkZXZpYXRlIHdhcyB0byBwcmV2ZW50IHRoZSBkZXBlbmRlbmN5IG9mIEJ1ZmZlci5cbiAqXG4gKiBDb250cmlidXRvcnM6XG4gKlxuICogYmFzZS14IGVuY29kaW5nXG4gKiBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JzNThcbiAqIE9yaWdpbmFsbHkgd3JpdHRlbiBieSBNaWtlIEhlYXJuIGZvciBCaXRjb2luSlxuICogQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcbiAqIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IFN0ZWZhbiBUaG9tYXNcbiAqIE1lcmdlZCBCdWZmZXIgcmVmYWN0b3JpbmdzIGZyb20gYmFzZTU4LW5hdGl2ZSBieSBTdGVwaGVuIFBhaXJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IGJhc2UteCBjb250cmlidXRvcnMgKGMpIDIwMTZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAqIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZTU4ID0gZXhwb3J0cy5CYXNlMzIgPSBleHBvcnRzLkJhc2VYID0gdm9pZCAwO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgQmFzZVggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVgoYWxwaGFiZXQpIHtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJhbHBoYWJldFwiLCBhbHBoYWJldCk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiYmFzZVwiLCBhbHBoYWJldC5sZW5ndGgpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9hbHBoYWJldE1hcFwiLCB7fSk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX2xlYWRlclwiLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xuICAgICAgICAvLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFiZXRNYXBbYWxwaGFiZXQuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQmFzZVgucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc291cmNlID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKHZhbHVlKTtcbiAgICAgICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWdpdHMgPSBbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2FycnkgPSBzb3VyY2VbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICAgICAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgdGhpcy5iYXNlO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSB0aGlzLmJhc2UpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZyA9IFwiXCI7XG4gICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBzb3VyY2Vba10gPT09IDAgJiYgayA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLl9sZWFkZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICAgICAgZm9yICh2YXIgcSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBxID49IDA7IC0tcSkge1xuICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuYWxwaGFiZXRbZGlnaXRzW3FdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgQmFzZVgucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJ5dGUgPSB0aGlzLl9hbHBoYWJldE1hcFt2YWx1ZVtpXV07XG4gICAgICAgICAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIiArIHRoaXMuYmFzZSArIFwiIGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYXJyeSA9IGJ5dGU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgYnl0ZXNbal0gPSBjYXJyeSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyB2YWx1ZVtrXSA9PT0gdGhpcy5fbGVhZGVyICYmIGsgPCB2YWx1ZS5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmFycmF5aWZ5KShuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlWDtcbn0oKSk7XG5leHBvcnRzLkJhc2VYID0gQmFzZVg7XG52YXIgQmFzZTMyID0gbmV3IEJhc2VYKFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIik7XG5leHBvcnRzLkJhc2UzMiA9IEJhc2UzMjtcbnZhciBCYXNlNTggPSBuZXcgQmFzZVgoXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIpO1xuZXhwb3J0cy5CYXNlNTggPSBCYXNlNTg7XG4vL2NvbnNvbGUubG9nKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKVxuLy9jb25zb2xlLmxvZyhCYXNlNTguZW5jb2RlKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/basex/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/_version.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/_version.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"bignumber/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi9fdmVyc2lvbi5qcz8zMzQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJiaWdudW1iZXIvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/bignumber.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/bignumber.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = void 0;\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\nvar bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/ethers/node_modules/bn.js/lib/bn.js\"));\nvar BN = bn_js_1.default.BN;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar _constructorGuard = {};\nvar MAX_SAFE = 0x1fffffffffffff;\nfunction isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        (0, bytes_1.isHexString)(value) ||\n        (typeof (value) === \"bigint\") ||\n        (0, bytes_1.isBytes)(value));\n}\nexports.isBigNumberish = isBigNumberish;\n// Only warn about passing 10 into radix once\nvar _warnedToStringRadix = false;\nvar BigNumber = /** @class */ (function () {\n    function BigNumber(constructorGuard, hex) {\n        var _newTarget = this.constructor;\n        logger.checkNew(_newTarget, BigNumber);\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    BigNumber.prototype.fromTwos = function (value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    };\n    BigNumber.prototype.toTwos = function (value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    };\n    BigNumber.prototype.abs = function () {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    };\n    BigNumber.prototype.add = function (other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    };\n    BigNumber.prototype.sub = function (other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    };\n    BigNumber.prototype.div = function (other) {\n        var o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division by zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    };\n    BigNumber.prototype.mul = function (other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    };\n    BigNumber.prototype.mod = function (other) {\n        var value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"cannot modulo negative values\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    };\n    BigNumber.prototype.pow = function (other) {\n        var value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"cannot raise to negative values\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    };\n    BigNumber.prototype.and = function (other) {\n        var value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'and' negative values\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    };\n    BigNumber.prototype.or = function (other) {\n        var value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'or' negative values\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    };\n    BigNumber.prototype.xor = function (other) {\n        var value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'xor' negative values\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    };\n    BigNumber.prototype.mask = function (value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot mask negative values\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    };\n    BigNumber.prototype.shl = function (value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    };\n    BigNumber.prototype.shr = function (value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    };\n    BigNumber.prototype.eq = function (other) {\n        return toBN(this).eq(toBN(other));\n    };\n    BigNumber.prototype.lt = function (other) {\n        return toBN(this).lt(toBN(other));\n    };\n    BigNumber.prototype.lte = function (other) {\n        return toBN(this).lte(toBN(other));\n    };\n    BigNumber.prototype.gt = function (other) {\n        return toBN(this).gt(toBN(other));\n    };\n    BigNumber.prototype.gte = function (other) {\n        return toBN(this).gte(toBN(other));\n    };\n    BigNumber.prototype.isNegative = function () {\n        return (this._hex[0] === \"-\");\n    };\n    BigNumber.prototype.isZero = function () {\n        return toBN(this).isZero();\n    };\n    BigNumber.prototype.toNumber = function () {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    };\n    BigNumber.prototype.toBigInt = function () {\n        try {\n            return BigInt(this.toString());\n        }\n        catch (e) { }\n        return logger.throwError(\"this platform does not support BigInt\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    };\n    BigNumber.prototype.toString = function () {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            }\n            else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n            else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    };\n    BigNumber.prototype.toHexString = function () {\n        return this._hex;\n    };\n    BigNumber.prototype.toJSON = function (key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    };\n    BigNumber.from = function (value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        var anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if ((0, bytes_1.isBytes)(anyValue)) {\n            return BigNumber.from((0, bytes_1.hexlify)(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                var hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                var hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if ((0, bytes_1.isHexString)(hex) || (hex[0] === \"-\" && (0, bytes_1.isHexString)(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    };\n    BigNumber.isBigNumber = function (value) {\n        return !!(value && value._isBigNumber);\n    };\n    return BigNumber;\n}());\nexports.BigNumber = BigNumber;\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    var hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    var params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nfunction _base36To16(value) {\n    return (new BN(value, 36)).toString(16);\n}\nexports._base36To16 = _base36To16;\n// value should have no prefix\nfunction _base16To36(value) {\n    return (new BN(value, 16)).toString(36);\n}\nexports._base16To36 = _base16To36;\n//# sourceMappingURL=bignumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliL2JpZ251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLHVFQUFPO0FBQzdDO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiw0RUFBNEU7QUFDbEs7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi9iaWdudW1iZXIuanM/M2ZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX2Jhc2UxNlRvMzYgPSBleHBvcnRzLl9iYXNlMzZUbzE2ID0gZXhwb3J0cy5CaWdOdW1iZXIgPSBleHBvcnRzLmlzQmlnTnVtYmVyaXNoID0gdm9pZCAwO1xuLyoqXG4gKiAgQmlnTnVtYmVyXG4gKlxuICogIEEgd3JhcHBlciBhcm91bmQgdGhlIEJOLmpzIG9iamVjdC4gV2UgdXNlIHRoZSBCTi5qcyBsaWJyYXJ5XG4gKiAgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IGVsbGlwdGljLCBzbyBpdCBpcyByZXF1aXJlZCByZWdhcmRsZXNzLlxuICpcbiAqL1xudmFyIGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbnZhciBCTiA9IGJuX2pzXzEuZGVmYXVsdC5CTjtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG52YXIgTUFYX1NBRkUgPSAweDFmZmZmZmZmZmZmZmZmO1xuZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmICEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkgfHxcbiAgICAgICAgKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHZhbHVlKSB8fFxuICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHx8XG4gICAgICAgICgwLCBieXRlc18xLmlzQnl0ZXMpKHZhbHVlKSk7XG59XG5leHBvcnRzLmlzQmlnTnVtYmVyaXNoID0gaXNCaWdOdW1iZXJpc2g7XG4vLyBPbmx5IHdhcm4gYWJvdXQgcGFzc2luZyAxMCBpbnRvIHJhZGl4IG9uY2VcbnZhciBfd2FybmVkVG9TdHJpbmdSYWRpeCA9IGZhbHNlO1xudmFyIEJpZ051bWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIoY29uc3RydWN0b3JHdWFyZCwgaGV4KSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEJpZ051bWJlcik7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgY2FsbCBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIEJpZ051bWJlci5mcm9tXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyAoQmlnTnVtYmVyKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZXggPSBoZXg7XG4gICAgICAgIHRoaXMuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXguc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJpZ051bWJlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgbyA9IEJpZ051bWJlci5mcm9tKG90aGVyKTtcbiAgICAgICAgaWYgKG8uaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiZGl2XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmRpdih0b0JOKG90aGVyKSkpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubXVsKHRvQk4ob3RoZXIpKSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgbW9kdWxvIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm1vZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS51bW9kKHZhbHVlKSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgcmFpc2UgdG8gbmVnYXRpdmUgdmFsdWVzXCIsIFwicG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90ICdhbmQnIG5lZ2F0aXZlIHZhbHVlc1wiLCBcImFuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5hbmQodmFsdWUpKTtcbiAgICB9O1xuICAgIEJpZ051bWJlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90ICdvcicgbmVnYXRpdmUgdmFsdWVzXCIsIFwib3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykub3IodmFsdWUpKTtcbiAgICB9O1xuICAgIEJpZ051bWJlci5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCAneG9yJyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJ4b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLm1hc2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCBtYXNrIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm1hc2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubWFza24odmFsdWUpKTtcbiAgICB9O1xuICAgIEJpZ051bWJlci5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsIFwic2hsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcbiAgICB9O1xuICAgIEJpZ051bWJlci5wcm90b3R5cGUuc2hyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsIFwic2hyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNocm4odmFsdWUpKTtcbiAgICB9O1xuICAgIEJpZ051bWJlci5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZXEodG9CTihvdGhlcikpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdCh0b0JOKG90aGVyKSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdGUodG9CTihvdGhlcikpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndCh0b0JOKG90aGVyKSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndGUodG9CTihvdGhlcikpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hleFswXSA9PT0gXCItXCIpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmlzWmVybygpO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJ0b051bWJlclwiLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS50b0JpZ0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInRoaXMgcGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBCaWdJbnRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBMb3RzIG9mIHBlb3BsZSBleHBlY3QgdGhpcywgd2hpY2ggd2UgZG8gbm90IHN1cHBvcnQsIHNvIGNoZWNrIChTZWU6ICM4ODkpXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoIV93YXJuZWRUb1N0cmluZ1JhZGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIF93YXJuZWRUb1N0cmluZ1JhZGl4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzOyBiYXNlLTEwIGlzIGFzc3VtZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdID09PSAxNikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgdXNlIGJpZ051bWJlci50b0hleFN0cmluZygpXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlcnNcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9TdHJpbmcoMTApO1xuICAgIH07XG4gICAgQmlnTnVtYmVyLnByb3RvdHlwZS50b0hleFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcbiAgICB9O1xuICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkJpZ051bWJlclwiLCBoZXg6IHRoaXMudG9IZXhTdHJpbmcoKSB9O1xuICAgIH07XG4gICAgQmlnTnVtYmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tPzB4WzAtOWEtZl0rJC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgobmV3IEJOKHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuZGVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBNQVhfU0FGRSB8fCB2YWx1ZSA8PSAtTUFYX1NBRkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFueVZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgKGFueVZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGFueVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgYnl0ZXNfMS5pc0J5dGVzKShhbnlWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSgoMCwgYnl0ZXNfMS5oZXhsaWZ5KShhbnlWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSGV4YWJsZSBpbnRlcmZhY2UgKHRha2VzIHByaW9yaXR5KVxuICAgICAgICAgICAgaWYgKGFueVZhbHVlLnRvSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhleCA9IGFueVZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCBoYW5kbGUgbGVnYWN5IEpTT04taWZpZWQgdmFsdWVzIChnb2VzIGF3YXkgaW4gdjYpXG4gICAgICAgICAgICAgICAgdmFyIGhleCA9IGFueVZhbHVlLl9oZXg7XG4gICAgICAgICAgICAgICAgLy8gTmV3LWZvcm0gSlNPTlxuICAgICAgICAgICAgICAgIGlmIChoZXggPT0gbnVsbCAmJiBhbnlWYWx1ZS50eXBlID09PSBcIkJpZ051bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhleCA9IGFueVZhbHVlLmhleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGhleCkgfHwgKGhleFswXSA9PT0gXCItXCIgJiYgKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGhleC5zdWJzdHJpbmcoMSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9O1xuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzQmlnTnVtYmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBCaWdOdW1iZXI7XG59KCkpO1xuZXhwb3J0cy5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XG4vLyBOb3JtYWxpemUgdGhlIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgLy8gRm9yIEJOLCBjYWxsIG9uIHRoZSBoZXggc3RyaW5nXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB0b0hleCh2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICAvLyBJZiBuZWdhdGl2ZSwgcHJlcGVuZCB0aGUgbmVnYXRpdmUgc2lnbiB0byB0aGUgbm9ybWFsaXplZCBwb3NpdGl2ZSB2YWx1ZVxuICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBuZWdhdGl2ZSBzaWduXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAvLyBDYW5ub3QgaGF2ZSBtdWx0aXBsZSBuZWdhdGl2ZSBzaWducyAoZS5nLiBcIi0tMHgwNFwiKVxuICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0b0hleCBvbiB0aGUgcG9zaXRpdmUgY29tcG9uZW50XG4gICAgICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuICAgICAgICAvLyBEbyBub3QgYWxsb3cgXCItMHgwMFwiXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWdhdGUgdGhlIHZhbHVlXG4gICAgICAgIHJldHVybiBcIi1cIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBBZGQgYSBcIjB4XCIgcHJlZml4IGlmIG1pc3NpbmdcbiAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHplcm9cbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIC8vIE1ha2UgdGhlIHN0cmluZyBldmVuIGxlbmd0aFxuICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgLy8gVHJpbSB0byBzbWFsbGVzdCBldmVuLWxlbmd0aCBzdHJpbmdcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0JpZ051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gdG9CTih2YWx1ZSkge1xuICAgIHZhciBoZXggPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcbiAgICBpZiAoaGV4WzBdID09PSBcIi1cIikge1xuICAgICAgICByZXR1cm4gKG5ldyBCTihcIi1cIiArIGhleC5zdWJzdHJpbmcoMyksIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQk4oaGV4LnN1YnN0cmluZygyKSwgMTYpO1xufVxuZnVuY3Rpb24gdGhyb3dGYXVsdChmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuICAgIHZhciBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGZhdWx0LCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmZ1bmN0aW9uIF9iYXNlMzZUbzE2KHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQk4odmFsdWUsIDM2KSkudG9TdHJpbmcoMTYpO1xufVxuZXhwb3J0cy5fYmFzZTM2VG8xNiA9IF9iYXNlMzZUbzE2O1xuLy8gdmFsdWUgc2hvdWxkIGhhdmUgbm8gcHJlZml4XG5mdW5jdGlvbiBfYmFzZTE2VG8zNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAxNikpLnRvU3RyaW5nKDM2KTtcbn1cbmV4cG9ydHMuX2Jhc2UxNlRvMzYgPSBfYmFzZTE2VG8zNjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ251bWJlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/bignumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/fixednumber.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/fixednumber.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar bignumber_1 = __webpack_require__(/*! ./bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/bignumber.js\");\nvar _constructorGuard = {};\nvar Zero = bignumber_1.BigNumber.from(0);\nvar NegativeOne = bignumber_1.BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    var params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nvar zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = bignumber_1.BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nfunction formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    var multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = bignumber_1.BigNumber.from(value);\n    var negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    var fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    var whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    }\n    else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nexports.formatFixed = formatFixed;\nfunction parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    var multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    var negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    var comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    var whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    var wholeValue = bignumber_1.BigNumber.from(whole);\n    var fractionValue = bignumber_1.BigNumber.from(fraction);\n    var wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nexports.parseFixed = parseFixed;\nvar FixedFormat = /** @class */ (function () {\n    function FixedFormat(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    FixedFormat.from = function (value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof (value) === \"number\") {\n            value = \"fixed128x\" + value;\n        }\n        var signed = true;\n        var width = 128;\n        var decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else {\n                var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            var check = function (key, type, defaultValue) {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    };\n    return FixedFormat;\n}());\nexports.FixedFormat = FixedFormat;\nvar FixedNumber = /** @class */ (function () {\n    function FixedNumber(constructorGuard, hex, value, format) {\n        var _newTarget = this.constructor;\n        logger.checkNew(_newTarget, FixedNumber);\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    FixedNumber.prototype._checkFormat = function (other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    };\n    FixedNumber.prototype.addUnsafe = function (other) {\n        this._checkFormat(other);\n        var a = parseFixed(this._value, this.format.decimals);\n        var b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    };\n    FixedNumber.prototype.subUnsafe = function (other) {\n        this._checkFormat(other);\n        var a = parseFixed(this._value, this.format.decimals);\n        var b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    };\n    FixedNumber.prototype.mulUnsafe = function (other) {\n        this._checkFormat(other);\n        var a = parseFixed(this._value, this.format.decimals);\n        var b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    };\n    FixedNumber.prototype.divUnsafe = function (other) {\n        this._checkFormat(other);\n        var a = parseFixed(this._value, this.format.decimals);\n        var b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    };\n    FixedNumber.prototype.floor = function () {\n        var comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        var result = FixedNumber.from(comps[0], this.format);\n        var hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    };\n    FixedNumber.prototype.ceiling = function () {\n        var comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        var result = FixedNumber.from(comps[0], this.format);\n        var hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    };\n    // @TODO: Support other rounding algorithms\n    FixedNumber.prototype.round = function (decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        var comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        var factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        var bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    };\n    FixedNumber.prototype.isZero = function () {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    };\n    FixedNumber.prototype.isNegative = function () {\n        return (this._value[0] === \"-\");\n    };\n    FixedNumber.prototype.toString = function () { return this._value; };\n    FixedNumber.prototype.toHexString = function (width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return (0, bytes_1.hexZeroPad)(hex, width / 8);\n    };\n    FixedNumber.prototype.toUnsafeFloat = function () { return parseFloat(this.toString()); };\n    FixedNumber.prototype.toFormat = function (format) {\n        return FixedNumber.fromString(this._value, format);\n    };\n    FixedNumber.fromValue = function (value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    };\n    FixedNumber.fromString = function (value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        var fixedFormat = FixedFormat.from(format);\n        var numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        var hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = (0, bytes_1.hexZeroPad)(hex, fixedFormat.width / 8);\n        }\n        var decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    };\n    FixedNumber.fromBytes = function (value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        var fixedFormat = FixedFormat.from(format);\n        if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        var numeric = bignumber_1.BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        var decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    };\n    FixedNumber.from = function (value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if ((0, bytes_1.isBytes)(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    };\n    FixedNumber.isFixedNumber = function (value) {\n        return !!(value && value._isFixedNumber);\n    };\n    return FixedNumber;\n}());\nexports.FixedNumber = FixedNumber;\nvar ONE = FixedNumber.from(1);\nvar BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliL2ZpeGVkbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQjtBQUNwRixjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMscUdBQVk7QUFDckM7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIvZml4ZWRudW1iZXIuanM/OGY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRml4ZWROdW1iZXIgPSBleHBvcnRzLkZpeGVkRm9ybWF0ID0gZXhwb3J0cy5wYXJzZUZpeGVkID0gZXhwb3J0cy5mb3JtYXRGaXhlZCA9IHZvaWQgMDtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIGJpZ251bWJlcl8xID0gcmVxdWlyZShcIi4vYmlnbnVtYmVyXCIpO1xudmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG52YXIgWmVybyA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKDApO1xudmFyIE5lZ2F0aXZlT25lID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oLTEpO1xuZnVuY3Rpb24gdGhyb3dGYXVsdChtZXNzYWdlLCBmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuICAgIHZhciBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcbn1cbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbnZhciB6ZXJvcyA9IFwiMFwiO1xud2hpbGUgKHplcm9zLmxlbmd0aCA8IDI1Nikge1xuICAgIHplcm9zICs9IHplcm9zO1xufVxuLy8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuZnVuY3Rpb24gZ2V0TXVsdGlwbGllcihkZWNpbWFscykge1xuICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShkZWNpbWFscykudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSA9PT0gXCJudW1iZXJcIiAmJiBkZWNpbWFscyA+PSAwICYmIGRlY2ltYWxzIDw9IDI1NiAmJiAhKGRlY2ltYWxzICUgMSkpIHtcbiAgICAgICAgcmV0dXJuIChcIjFcIiArIHplcm9zLnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBzaXplXCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xufVxuZnVuY3Rpb24gZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cbiAgICB2YXIgbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZWkgaXMgYSBiaWcgbnVtYmVyIChjb252ZXJ0IGFzIG5lY2Vzc2FyeSlcbiAgICB2YWx1ZSA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICB2YXIgbmVnYXRpdmUgPSB2YWx1ZS5sdChaZXJvKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tdWwoTmVnYXRpdmVPbmUpO1xuICAgIH1cbiAgICB2YXIgZnJhY3Rpb24gPSB2YWx1ZS5tb2QobXVsdGlwbGllcikudG9TdHJpbmcoKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgbXVsdGlwbGllci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGZyYWN0aW9uID0gXCIwXCIgKyBmcmFjdGlvbjtcbiAgICB9XG4gICAgLy8gU3RyaXAgdHJhaW5pbmcgMFxuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ubWF0Y2goL14oWzAtOV0qWzEtOV18MCkoMCopLylbMV07XG4gICAgdmFyIHdob2xlID0gdmFsdWUuZGl2KG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG4gICAgaWYgKG11bHRpcGxpZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhbHVlID0gd2hvbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHdob2xlICsgXCIuXCIgKyBmcmFjdGlvbjtcbiAgICB9XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gXCItXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5mb3JtYXRGaXhlZCA9IGZvcm1hdEZpeGVkO1xuZnVuY3Rpb24gcGFyc2VGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgfVxuICAgIHZhciBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXi0/WzAtOS5dKyQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBJcyBpdCBuZWdhdGl2ZT9cbiAgICB2YXIgbmVnYXRpdmUgPSAodmFsdWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIik7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IFwiLlwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBTcGxpdCBpdCBpbnRvIGEgd2hvbGUgYW5kIGZyYWN0aW9uYWwgcGFydFxuICAgIHZhciBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidG9vIG1hbnkgZGVjaW1hbCBwb2ludHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhciB3aG9sZSA9IGNvbXBzWzBdLCBmcmFjdGlvbiA9IGNvbXBzWzFdO1xuICAgIGlmICghd2hvbGUpIHtcbiAgICAgICAgd2hvbGUgPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKCFmcmFjdGlvbikge1xuICAgICAgICBmcmFjdGlvbiA9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBUcmltIHRyYWlsaW5nIHplcm9zXG4gICAgd2hpbGUgKGZyYWN0aW9uW2ZyYWN0aW9uLmxlbmd0aCAtIDFdID09PSBcIjBcIikge1xuICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnN1YnN0cmluZygwLCBmcmFjdGlvbi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhlIGZyYWN0aW9uIGRvZXNuJ3QgZXhjZWVkIG91ciBkZWNpbWFscyBzaXplXG4gICAgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvd0ZhdWx0KFwiZnJhY3Rpb25hbCBjb21wb25lbnQgZXhjZWVkcyBkZWNpbWFsc1wiLCBcInVuZGVyZmxvd1wiLCBcInBhcnNlRml4ZWRcIik7XG4gICAgfVxuICAgIC8vIElmIGRlY2ltYWxzIGlzIDAsIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGZvciBmcmFjdGlvblxuICAgIGlmIChmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgICAgICBmcmFjdGlvbiA9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBGdWxseSBwYWQgdGhlIHN0cmluZyB3aXRoIHplcm9zIHRvIGdldCB0byB3ZWlcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgbXVsdGlwbGllci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGZyYWN0aW9uICs9IFwiMFwiO1xuICAgIH1cbiAgICB2YXIgd2hvbGVWYWx1ZSA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHdob2xlKTtcbiAgICB2YXIgZnJhY3Rpb25WYWx1ZSA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKGZyYWN0aW9uKTtcbiAgICB2YXIgd2VpID0gKHdob2xlVmFsdWUubXVsKG11bHRpcGxpZXIpKS5hZGQoZnJhY3Rpb25WYWx1ZSk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHdlaSA9IHdlaS5tdWwoTmVnYXRpdmVPbmUpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpO1xufVxuZXhwb3J0cy5wYXJzZUZpeGVkID0gcGFyc2VGaXhlZDtcbnZhciBGaXhlZEZvcm1hdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaXhlZEZvcm1hdChjb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHVzZSBGaXhlZEZvcm1hdCBjb25zdHJ1Y3RvcjsgdXNlIEZpeGVkRm9ybWF0LmZyb21cIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZpeGVkRm9ybWF0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZGVjaW1hbHMgPSBkZWNpbWFscztcbiAgICAgICAgdGhpcy5uYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIEZpeGVkRm9ybWF0LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRml4ZWRGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJmaXhlZDEyOHhcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaWduZWQgPSB0cnVlO1xuICAgICAgICB2YXIgd2lkdGggPSAxMjg7XG4gICAgICAgIHZhciBkZWNpbWFscyA9IDE4O1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcInVmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsIFwiZm9ybWF0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uIChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWVba2V5XSkgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgICAgIHdpZHRoID0gY2hlY2soXCJ3aWR0aFwiLCBcIm51bWJlclwiLCB3aWR0aCk7XG4gICAgICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCAlIDgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNpbWFscyA+IDgwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKGRlY2ltYWxzIHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRGb3JtYXQoX2NvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKTtcbiAgICB9O1xuICAgIHJldHVybiBGaXhlZEZvcm1hdDtcbn0oKSk7XG5leHBvcnRzLkZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQ7XG52YXIgRml4ZWROdW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRml4ZWROdW1iZXIoY29uc3RydWN0b3JHdWFyZCwgaGV4LCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZpeGVkTnVtYmVyKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWROdW1iZXIgY29uc3RydWN0b3I7IHVzZSBGaXhlZE51bWJlci5mcm9tXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGaXhlZEZvcm1hdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy5faGV4ID0gaGV4O1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9pc0ZpeGVkTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgRml4ZWROdW1iZXIucHJvdG90eXBlLl9jaGVja0Zvcm1hdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQubmFtZSAhPT0gb3RoZXIuZm9ybWF0Lm5hbWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5hZGRVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICB2YXIgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLmFkZChiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9O1xuICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5zdWJVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICB2YXIgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLnN1YihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9O1xuICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5tdWxVbnNhZmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICB2YXIgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgdmFyIGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bChiKS5kaXYodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH07XG4gICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmRpdlVuc2FmZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICB2YXIgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKS5kaXYoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfTtcbiAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBGaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIHZhciBoYXNGcmFjdGlvbiA9ICFjb21wc1sxXS5tYXRjaCgvXigwKikkLyk7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YlVuc2FmZShPTkUudG9Gb3JtYXQocmVzdWx0LmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuY2VpbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IEZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgdmFyIGhhc0ZyYWN0aW9uID0gIWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZFVuc2FmZShPTkUudG9Gb3JtYXQocmVzdWx0LmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBAVE9ETzogU3VwcG9ydCBvdGhlciByb3VuZGluZyBhbGdvcml0aG1zXG4gICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24gKGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW4gcmFuZ2UsIHdlJ3JlIGRvbmVcbiAgICAgICAgdmFyIGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzIDwgMCB8fCBkZWNpbWFscyA+IDgwIHx8IChkZWNpbWFscyAlIDEpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIGNvdW50XCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wc1sxXS5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmYWN0b3IgPSBGaXhlZE51bWJlci5mcm9tKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICB2YXIgYnVtcCA9IEJVTVAudG9Gb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWxVbnNhZmUoZmFjdG9yKS5hZGRVbnNhZmUoYnVtcCkuZmxvb3IoKS5kaXZVbnNhZmUoZmFjdG9yKTtcbiAgICB9O1xuICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdmFsdWUgPT09IFwiMC4wXCIgfHwgdGhpcy5fdmFsdWUgPT09IFwiMFwiKTtcbiAgICB9O1xuICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlWzBdID09PSBcIi1cIik7XG4gICAgfTtcbiAgICBGaXhlZE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfTtcbiAgICBGaXhlZE51bWJlci5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZSB3aWR0aFwiLCBcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGV4ID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odGhpcy5faGV4KS5mcm9tVHdvcyh0aGlzLmZvcm1hdC53aWR0aCkudG9Ud29zKHdpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4WmVyb1BhZCkoaGV4LCB3aWR0aCAvIDgpO1xuICAgIH07XG4gICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvVW5zYWZlRmxvYXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSk7IH07XG4gICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh0aGlzLl92YWx1ZSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVjaW1hbHMsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiBkZWNpbWFscyBsb29rcyBtb3JlIGxpa2UgYSBmb3JtYXQsIGFuZCB0aGVyZSBpcyBubyBmb3JtYXQsIHNoaWZ0IHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCAmJiBkZWNpbWFscyAhPSBudWxsICYmICEoMCwgYmlnbnVtYmVyXzEuaXNCaWdOdW1iZXJpc2gpKGRlY2ltYWxzKSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZGVjaW1hbHM7XG4gICAgICAgICAgICBkZWNpbWFscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhmb3JtYXRGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpLCBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCkpO1xuICAgIH07XG4gICAgRml4ZWROdW1iZXIuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcbiAgICAgICAgdmFyIG51bWVyaWMgPSBwYXJzZUZpeGVkKHZhbHVlLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGlmICghZml4ZWRGb3JtYXQuc2lnbmVkICYmIG51bWVyaWMubHQoWmVybykpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bnNpZ25lZCB2YWx1ZSBjYW5ub3QgYmUgbmVnYXRpdmVcIiwgXCJvdmVyZmxvd1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGV4ID0gbnVsbDtcbiAgICAgICAgaWYgKGZpeGVkRm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b1R3b3MoZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZXggPSBudW1lcmljLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICBoZXggPSAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKShoZXgsIGZpeGVkRm9ybWF0LndpZHRoIC8gOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlY2ltYWwgPSBmb3JtYXRGaXhlZChudW1lcmljLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuICAgIH07XG4gICAgRml4ZWROdW1iZXIuZnJvbUJ5dGVzID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO1xuICAgICAgICBpZiAoKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKHZhbHVlKS5sZW5ndGggPiBmaXhlZEZvcm1hdC53aWR0aCAvIDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1lcmljID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICBpZiAoZml4ZWRGb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYy5mcm9tVHdvcyhmaXhlZEZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhleCA9IG51bWVyaWMudG9Ud29zKChmaXhlZEZvcm1hdC5zaWduZWQgPyAwIDogMSkgKyBmaXhlZEZvcm1hdC53aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgdmFyIGRlY2ltYWwgPSBmb3JtYXRGaXhlZChudW1lcmljLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuICAgIH07XG4gICAgRml4ZWROdW1iZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBieXRlc18xLmlzQnl0ZXMpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21CeXRlcyh2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgMCwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IE5VTUVSSUNfRkFVTFQgdG8gYnViYmxlIHVwXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH07XG4gICAgRml4ZWROdW1iZXIuaXNGaXhlZE51bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRml4ZWROdW1iZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpeGVkTnVtYmVyO1xufSgpKTtcbmV4cG9ydHMuRml4ZWROdW1iZXIgPSBGaXhlZE51bWJlcjtcbnZhciBPTkUgPSBGaXhlZE51bWJlci5mcm9tKDEpO1xudmFyIEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = void 0;\nvar bignumber_1 = __webpack_require__(/*! ./bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/bignumber.js\");\nObject.defineProperty(exports, \"BigNumber\", ({ enumerable: true, get: function () { return bignumber_1.BigNumber; } }));\nvar fixednumber_1 = __webpack_require__(/*! ./fixednumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/fixednumber.js\");\nObject.defineProperty(exports, \"formatFixed\", ({ enumerable: true, get: function () { return fixednumber_1.formatFixed; } }));\nObject.defineProperty(exports, \"FixedFormat\", ({ enumerable: true, get: function () { return fixednumber_1.FixedFormat; } }));\nObject.defineProperty(exports, \"FixedNumber\", ({ enumerable: true, get: function () { return fixednumber_1.FixedNumber; } }));\nObject.defineProperty(exports, \"parseFixed\", ({ enumerable: true, get: function () { return fixednumber_1.parseFixed; } }));\n// Internal methods used by address\nvar bignumber_2 = __webpack_require__(/*! ./bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/bignumber.js\");\nObject.defineProperty(exports, \"_base16To36\", ({ enumerable: true, get: function () { return bignumber_2._base16To36; } }));\nObject.defineProperty(exports, \"_base36To16\", ({ enumerable: true, get: function () { return bignumber_2._base36To16; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQjtBQUNwSixrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBYTtBQUN2Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsb0JBQW9CLG1CQUFPLENBQUMsMkdBQWU7QUFDM0MsK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILCtDQUE4QyxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUMzSCwrQ0FBOEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDM0gsOENBQTZDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3pIO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdUdBQWE7QUFDdkMsK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILCtDQUE4QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN6SCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliL2luZGV4LmpzPzQ0NTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9iYXNlMzZUbzE2ID0gZXhwb3J0cy5fYmFzZTE2VG8zNiA9IGV4cG9ydHMucGFyc2VGaXhlZCA9IGV4cG9ydHMuRml4ZWROdW1iZXIgPSBleHBvcnRzLkZpeGVkRm9ybWF0ID0gZXhwb3J0cy5mb3JtYXRGaXhlZCA9IGV4cG9ydHMuQmlnTnVtYmVyID0gdm9pZCAwO1xudmFyIGJpZ251bWJlcl8xID0gcmVxdWlyZShcIi4vYmlnbnVtYmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJfMS5CaWdOdW1iZXI7IH0gfSk7XG52YXIgZml4ZWRudW1iZXJfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkbnVtYmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0Rml4ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpeGVkbnVtYmVyXzEuZm9ybWF0Rml4ZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZEZvcm1hdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZml4ZWRudW1iZXJfMS5GaXhlZEZvcm1hdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpeGVkTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaXhlZG51bWJlcl8xLkZpeGVkTnVtYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VGaXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZml4ZWRudW1iZXJfMS5wYXJzZUZpeGVkOyB9IH0pO1xuLy8gSW50ZXJuYWwgbWV0aG9kcyB1c2VkIGJ5IGFkZHJlc3NcbnZhciBiaWdudW1iZXJfMiA9IHJlcXVpcmUoXCIuL2JpZ251bWJlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9iYXNlMTZUbzM2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJfMi5fYmFzZTE2VG8zNjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9iYXNlMzZUbzE2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaWdudW1iZXJfMi5fYmFzZTM2VG8xNjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/_version.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bytes/lib/_version.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"bytes/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIvX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIvX3ZlcnNpb24uanM/YTU4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbmV4cG9ydHMudmVyc2lvbiA9IFwiYnl0ZXMvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nexports.isBytesLike = isBytesLike;\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (var i = 0; i < value.length; i++) {\n        var v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isBytes = isBytes;\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        var result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        var hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0x0\" + hex.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        var result = [];\n        for (var i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexports.arrayify = arrayify;\nfunction concat(items) {\n    var objects = items.map(function (item) { return arrayify(item); });\n    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\n    var result = new Uint8Array(length);\n    objects.reduce(function (offset, object) {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n    var result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    var start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexports.stripZeros = stripZeros;\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    var result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nexports.zeroPad = zeroPad;\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        var hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        var result = \"0x\";\n        for (var i = 0; i < value.length; i++) {\n            var v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\nexports.hexlify = hexlify;\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexConcat(items) {\n    var result = \"0x\";\n    items.forEach(function (item) {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nexports.hexConcat = hexConcat;\nfunction hexValue(value) {\n    var trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nexports.hexValue = hexValue;\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    var offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction splitSignature(signature) {\n    var result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0\n    };\n    if (isBytesLike(signature)) {\n        var bytes = arrayify(signature);\n        if (bytes.length !== 65) {\n            logger.throwArgumentError(\"invalid signature string; must be 65 bytes\", \"signature\", signature);\n        }\n        // Get the r, s and v\n        result.r = hexlify(bytes.slice(0, 32));\n        result.s = hexlify(bytes.slice(32, 64));\n        result.v = bytes[64];\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            var vs_1 = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs_1);\n            // Set or check the recid\n            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs_1[0] &= 0x7f;\n            var s = hexlify(vs_1);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                var recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        var vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        var _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    return result;\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\nexports.joinSignature = joinSignature;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsc0JBQXNCLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLG1CQUFtQjtBQUM1VSxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSw4Q0FBOEMsd0JBQXdCO0FBQ3RFLHlEQUF5RCwrQkFBK0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliL2luZGV4LmpzPzAxNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmpvaW5TaWduYXR1cmUgPSBleHBvcnRzLnNwbGl0U2lnbmF0dXJlID0gZXhwb3J0cy5oZXhaZXJvUGFkID0gZXhwb3J0cy5oZXhTdHJpcFplcm9zID0gZXhwb3J0cy5oZXhWYWx1ZSA9IGV4cG9ydHMuaGV4Q29uY2F0ID0gZXhwb3J0cy5oZXhEYXRhU2xpY2UgPSBleHBvcnRzLmhleERhdGFMZW5ndGggPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy56ZXJvUGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZXhwb3J0cy5jb25jYXQgPSBleHBvcnRzLmFycmF5aWZ5ID0gZXhwb3J0cy5pc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzTGlrZSA9IHZvaWQgMDtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZS50b0hleFN0cmluZyk7XG59XG5mdW5jdGlvbiBhZGRTbGljZShhcnJheSkge1xuICAgIGlmIChhcnJheS5zbGljZSkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGFycmF5LnNsaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoKGlzSGV4U3RyaW5nKHZhbHVlKSAmJiAhKHZhbHVlLmxlbmd0aCAlIDIpKSB8fCBpc0J5dGVzKHZhbHVlKSk7XG59XG5leHBvcnRzLmlzQnl0ZXNMaWtlID0gaXNCeXRlc0xpa2U7XG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIHZhbHVlID09IHZhbHVlICYmICh2YWx1ZSAlIDEpID09PSAwKTtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0ludGVnZXIodmFsdWUubGVuZ3RoKSB8fCB2YWx1ZS5sZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdiA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoIWlzSW50ZWdlcih2KSB8fCB2IDwgMCB8fCB2ID49IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbmZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KFN0cmluZyh2YWx1ZSAvIDI1NikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGhleCA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIweDBcIiArIGhleC5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgaGV4ICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydHMuYXJyYXlpZnkgPSBhcnJheWlmeTtcbmZ1bmN0aW9uIGNvbmNhdChpdGVtcykge1xuICAgIHZhciBvYmplY3RzID0gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBhcnJheWlmeShpdGVtKTsgfSk7XG4gICAgdmFyIGxlbmd0aCA9IG9iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgaXRlbSkgeyByZXR1cm4gKGFjY3VtICsgaXRlbS5sZW5ndGgpOyB9LCAwKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBvYmplY3RzLnJlZHVjZShmdW5jdGlvbiAob2Zmc2V0LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0LnNldChvYmplY3QsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBvYmplY3QubGVuZ3RoO1xuICAgIH0sIDApO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5mdW5jdGlvbiBzdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBub24temVybyBlbnRyeVxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDwgcmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbc3RhcnRdID09PSAwKSB7XG4gICAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCB6ZXJvcywgc3RyaXAgdGhlbVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2Uoc3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zdHJpcFplcm9zID0gc3RyaXBaZXJvcztcbmZ1bmN0aW9uIHplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIHZhbHVlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUsIGxlbmd0aCAtIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIGFkZFNsaWNlKHJlc3VsdCk7XG59XG5leHBvcnRzLnplcm9QYWQgPSB6ZXJvUGFkO1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xudmFyIEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmZ1bmN0aW9uIGhleGxpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIik7XG4gICAgICAgIHZhciBoZXggPSBcIlwiO1xuICAgICAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGhleCA9IEhleENoYXJhY3RlcnNbdmFsdWUgJiAweGZdICsgaGV4O1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMTYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiMHgwXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd01pc3NpbmdQcmVmaXggJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzSGV4YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVbaV07XG4gICAgICAgICAgICByZXN1bHQgKz0gSGV4Q2hhcmFjdGVyc1sodiAmIDB4ZjApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMHgwZl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnRzLmhleGxpZnkgPSBoZXhsaWZ5O1xuLypcbmZ1bmN0aW9uIHVub2RkaWZ5KHZhbHVlOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyKTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlciB7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoICUgMiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuKi9cbmZ1bmN0aW9uIGhleERhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG59XG5leHBvcnRzLmhleERhdGFMZW5ndGggPSBoZXhEYXRhTGVuZ3RoO1xuZnVuY3Rpb24gaGV4RGF0YVNsaWNlKGRhdGEsIG9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhEYXRhXCIsIFwidmFsdWVcIiwgZGF0YSk7XG4gICAgfVxuICAgIG9mZnNldCA9IDIgKyAyICogb2Zmc2V0O1xuICAgIGlmIChlbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0LCAyICsgMiAqIGVuZE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuZXhwb3J0cy5oZXhEYXRhU2xpY2UgPSBoZXhEYXRhU2xpY2U7XG5mdW5jdGlvbiBoZXhDb25jYXQoaXRlbXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCIweFwiO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmVzdWx0ICs9IGhleGxpZnkoaXRlbSkuc3Vic3RyaW5nKDIpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmhleENvbmNhdCA9IGhleENvbmNhdDtcbmZ1bmN0aW9uIGhleFZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHRyaW1tZWQgPSBoZXhTdHJpcFplcm9zKGhleGxpZnkodmFsdWUsIHsgaGV4UGFkOiBcImxlZnRcIiB9KSk7XG4gICAgaWYgKHRyaW1tZWQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRyaW1tZWQ7XG59XG5leHBvcnRzLmhleFZhbHVlID0gaGV4VmFsdWU7XG5mdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5sZW5ndGggJiYgdmFsdWVbb2Zmc2V0XSA9PT0gXCIwXCIpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydHMuaGV4U3RyaXBaZXJvcyA9IGhleFN0cmlwWmVyb3M7XG5mdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAqIGxlbmd0aCArIDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG91dCBvZiByYW5nZVwiLCBcInZhbHVlXCIsIGFyZ3VtZW50c1sxXSk7XG4gICAgfVxuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCAyICogbGVuZ3RoICsgMikge1xuICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuaGV4WmVyb1BhZCA9IGhleFplcm9QYWQ7XG5mdW5jdGlvbiBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICByOiBcIjB4XCIsXG4gICAgICAgIHM6IFwiMHhcIixcbiAgICAgICAgX3ZzOiBcIjB4XCIsXG4gICAgICAgIHJlY292ZXJ5UGFyYW06IDAsXG4gICAgICAgIHY6IDBcbiAgICB9O1xuICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG4gICAgICAgIHZhciBieXRlcyA9IGFycmF5aWZ5KHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nOyBtdXN0IGJlIDY1IGJ5dGVzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSByLCBzIGFuZCB2XG4gICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICByZXN1bHQucyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgICAgIHJlc3VsdC52ID0gYnl0ZXNbNjRdO1xuICAgICAgICAvLyBBbGxvdyBhIHJlY2lkIHRvIGJlIHVzZWQgYXMgdGhlIHZcbiAgICAgICAgaWYgKHJlc3VsdC52IDwgMjcpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ICs9IDI3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIHYgYnl0ZVwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgcmVjb3ZlcnlQYXJhbSBmcm9tIHZcbiAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSAxIC0gKHJlc3VsdC52ICUgMik7XG4gICAgICAgIC8vIENvbXB1dGUgX3ZzIGZyb20gcmVjb3ZlcnlQYXJhbSBhbmQgc1xuICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgIGJ5dGVzWzMyXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5fdnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnIgPSBzaWduYXR1cmUucjtcbiAgICAgICAgcmVzdWx0LnMgPSBzaWduYXR1cmUucztcbiAgICAgICAgcmVzdWx0LnYgPSBzaWduYXR1cmUudjtcbiAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcbiAgICAgICAgcmVzdWx0Ll92cyA9IHNpZ25hdHVyZS5fdnM7XG4gICAgICAgIC8vIElmIHRoZSBfdnMgaXMgYXZhaWxhYmxlLCB1c2UgaXQgdG8gcG9wdWxhdGUgbWlzc2luZyBzLCB2IGFuZCByZWNvdmVyeVBhcmFtXG4gICAgICAgIC8vIGFuZCB2ZXJpZnkgbm9uLW1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuICAgICAgICBpZiAocmVzdWx0Ll92cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdnNfMSA9IHplcm9QYWQoYXJyYXlpZnkocmVzdWx0Ll92cyksIDMyKTtcbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhsaWZ5KHZzXzEpO1xuICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuICAgICAgICAgICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoKHZzXzFbMF0gPj0gMTI4KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcbiAgICAgICAgICAgIHZzXzFbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgIHZhciBzID0gaGV4bGlmeSh2c18xKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnMgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnMgIT09IHMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHJlY2lkIGFuZCB2IHRvIHBvcHVsYXRlIGVhY2ggb3RoZXJcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZXN1bHQudjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiA9IDI3ICsgcmVzdWx0LnJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjSWQgPSAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpID8gcmVzdWx0LnYgOiAoMSAtIChyZXN1bHQudiAlIDIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2cyA9IGFycmF5aWZ5KHJlc3VsdC5zKTtcbiAgICAgICAgaWYgKHZzWzBdID49IDEyOCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBzIG91dCBvZiByYW5nZVwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgdnNbMF0gfD0gMHg4MDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgIGlmIChyZXN1bHQuX3ZzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHJlc3VsdC5fdnMpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleFplcm9QYWQocmVzdWx0Ll92cywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgX3ZzXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBfdnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0Ll92cyAhPT0gX3ZzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc3BsaXRTaWduYXR1cmUgPSBzcGxpdFNpZ25hdHVyZTtcbmZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICBzaWduYXR1cmUucixcbiAgICAgICAgc2lnbmF0dXJlLnMsXG4gICAgICAgIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXG4gICAgXSkpO1xufVxuZXhwb3J0cy5qb2luU2lnbmF0dXJlID0gam9pblNpZ25hdHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/addresses.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib/addresses.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressZero = void 0;\nexports.AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliL2FkZHJlc3Nlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIvYWRkcmVzc2VzLmpzP2RmNjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZHJlc3NaZXJvID0gdm9pZCAwO1xuZXhwb3J0cy5BZGRyZXNzWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/addresses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/bignumbers.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib/bignumbers.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar NegativeOne = ( /*#__PURE__*/bignumber_1.BigNumber.from(-1));\nexports.NegativeOne = NegativeOne;\nvar Zero = ( /*#__PURE__*/bignumber_1.BigNumber.from(0));\nexports.Zero = Zero;\nvar One = ( /*#__PURE__*/bignumber_1.BigNumber.from(1));\nexports.One = One;\nvar Two = ( /*#__PURE__*/bignumber_1.BigNumber.from(2));\nexports.Two = Two;\nvar WeiPerEther = ( /*#__PURE__*/bignumber_1.BigNumber.from(\"1000000000000000000\"));\nexports.WeiPerEther = WeiPerEther;\nvar MaxUint256 = ( /*#__PURE__*/bignumber_1.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nexports.MaxUint256 = MaxUint256;\nvar MinInt256 = ( /*#__PURE__*/bignumber_1.BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nexports.MinInt256 = MinInt256;\nvar MaxInt256 = ( /*#__PURE__*/bignumber_1.BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nexports.MaxInt256 = MaxInt256;\n//# sourceMappingURL=bignumbers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliL2JpZ251bWJlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxZQUFZLEdBQUcsbUJBQW1CO0FBQ2pKLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliL2JpZ251bWJlcnMuanM/ZDVhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF4SW50MjU2ID0gZXhwb3J0cy5NaW5JbnQyNTYgPSBleHBvcnRzLk1heFVpbnQyNTYgPSBleHBvcnRzLldlaVBlckV0aGVyID0gZXhwb3J0cy5Ud28gPSBleHBvcnRzLk9uZSA9IGV4cG9ydHMuWmVybyA9IGV4cG9ydHMuTmVnYXRpdmVPbmUgPSB2b2lkIDA7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIE5lZ2F0aXZlT25lID0gKCAvKiNfX1BVUkVfXyovYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oLTEpKTtcbmV4cG9ydHMuTmVnYXRpdmVPbmUgPSBOZWdhdGl2ZU9uZTtcbnZhciBaZXJvID0gKCAvKiNfX1BVUkVfXyovYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oMCkpO1xuZXhwb3J0cy5aZXJvID0gWmVybztcbnZhciBPbmUgPSAoIC8qI19fUFVSRV9fKi9iaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSgxKSk7XG5leHBvcnRzLk9uZSA9IE9uZTtcbnZhciBUd28gPSAoIC8qI19fUFVSRV9fKi9iaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSgyKSk7XG5leHBvcnRzLlR3byA9IFR3bztcbnZhciBXZWlQZXJFdGhlciA9ICggLyojX19QVVJFX18qL2JpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSk7XG5leHBvcnRzLldlaVBlckV0aGVyID0gV2VpUGVyRXRoZXI7XG52YXIgTWF4VWludDI1NiA9ICggLyojX19QVVJFX18qL2JpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbmV4cG9ydHMuTWF4VWludDI1NiA9IE1heFVpbnQyNTY7XG52YXIgTWluSW50MjU2ID0gKCAvKiNfX1BVUkVfXyovYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oXCItMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmV4cG9ydHMuTWluSW50MjU2ID0gTWluSW50MjU2O1xudmFyIE1heEludDI1NiA9ICggLyojX19QVVJFX18qL2JpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbmV4cG9ydHMuTWF4SW50MjU2ID0gTWF4SW50MjU2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/bignumbers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/hashes.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib/hashes.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HashZero = void 0;\nexports.HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliL2hhc2hlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIvaGFzaGVzLmpzPzFmNDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc2haZXJvID0gdm9pZCAwO1xuZXhwb3J0cy5IYXNoWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = void 0;\nvar addresses_1 = __webpack_require__(/*! ./addresses */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/addresses.js\");\nObject.defineProperty(exports, \"AddressZero\", ({ enumerable: true, get: function () { return addresses_1.AddressZero; } }));\nvar bignumbers_1 = __webpack_require__(/*! ./bignumbers */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/bignumbers.js\");\nObject.defineProperty(exports, \"NegativeOne\", ({ enumerable: true, get: function () { return bignumbers_1.NegativeOne; } }));\nObject.defineProperty(exports, \"Zero\", ({ enumerable: true, get: function () { return bignumbers_1.Zero; } }));\nObject.defineProperty(exports, \"One\", ({ enumerable: true, get: function () { return bignumbers_1.One; } }));\nObject.defineProperty(exports, \"Two\", ({ enumerable: true, get: function () { return bignumbers_1.Two; } }));\nObject.defineProperty(exports, \"WeiPerEther\", ({ enumerable: true, get: function () { return bignumbers_1.WeiPerEther; } }));\nObject.defineProperty(exports, \"MaxUint256\", ({ enumerable: true, get: function () { return bignumbers_1.MaxUint256; } }));\nObject.defineProperty(exports, \"MinInt256\", ({ enumerable: true, get: function () { return bignumbers_1.MinInt256; } }));\nObject.defineProperty(exports, \"MaxInt256\", ({ enumerable: true, get: function () { return bignumbers_1.MaxInt256; } }));\nvar hashes_1 = __webpack_require__(/*! ./hashes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/hashes.js\");\nObject.defineProperty(exports, \"HashZero\", ({ enumerable: true, get: function () { return hashes_1.HashZero; } }));\nvar strings_1 = __webpack_require__(/*! ./strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/strings.js\");\nObject.defineProperty(exports, \"EtherSymbol\", ({ enumerable: true, get: function () { return strings_1.EtherSymbol; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsWUFBWSxHQUFHLG1CQUFtQixHQUFHLG1CQUFtQjtBQUNoTixrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBYTtBQUN2QywrQ0FBOEMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDekgsbUJBQW1CLG1CQUFPLENBQUMseUdBQWM7QUFDekMsK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFILHdDQUF1QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUM1Ryx1Q0FBc0MsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDMUcsdUNBQXNDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzFHLCtDQUE4QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMxSCw4Q0FBNkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDeEgsNkNBQTRDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3RILDZDQUE0QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN0SCxlQUFlLG1CQUFPLENBQUMsaUdBQVU7QUFDakMsNENBQTJDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2hILGdCQUFnQixtQkFBTyxDQUFDLG1HQUFXO0FBQ25DLCtDQUE4QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliL2luZGV4LmpzPzljM2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV0aGVyU3ltYm9sID0gZXhwb3J0cy5IYXNoWmVybyA9IGV4cG9ydHMuTWF4SW50MjU2ID0gZXhwb3J0cy5NaW5JbnQyNTYgPSBleHBvcnRzLk1heFVpbnQyNTYgPSBleHBvcnRzLldlaVBlckV0aGVyID0gZXhwb3J0cy5Ud28gPSBleHBvcnRzLk9uZSA9IGV4cG9ydHMuWmVybyA9IGV4cG9ydHMuTmVnYXRpdmVPbmUgPSBleHBvcnRzLkFkZHJlc3NaZXJvID0gdm9pZCAwO1xudmFyIGFkZHJlc3Nlc18xID0gcmVxdWlyZShcIi4vYWRkcmVzc2VzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWRkcmVzc1plcm9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3Nlc18xLkFkZHJlc3NaZXJvOyB9IH0pO1xudmFyIGJpZ251bWJlcnNfMSA9IHJlcXVpcmUoXCIuL2JpZ251bWJlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZWdhdGl2ZU9uZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyc18xLk5lZ2F0aXZlT25lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWmVyb1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyc18xLlplcm87IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPbmVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ251bWJlcnNfMS5PbmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUd29cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ251bWJlcnNfMS5Ud287IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWlQZXJFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyc18xLldlaVBlckV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWF4VWludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyc18xLk1heFVpbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaW5JbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ251bWJlcnNfMS5NaW5JbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYXhJbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpZ251bWJlcnNfMS5NYXhJbnQyNTY7IH0gfSk7XG52YXIgaGFzaGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIYXNoWmVyb1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGVzXzEuSGFzaFplcm87IH0gfSk7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4vc3RyaW5nc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyU3ltYm9sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzXzEuRXRoZXJTeW1ib2w7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/strings.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/constants/lib/strings.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EtherSymbol = void 0;\n// NFKC (composed)             // (decomposed)\nexports.EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi9zdHJpbmdzLmpzPzlhNjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV0aGVyU3ltYm9sID0gdm9pZCAwO1xuLy8gTkZLQyAoY29tcG9zZWQpICAgICAgICAgICAgIC8vIChkZWNvbXBvc2VkKVxuZXhwb3J0cy5FdGhlclN5bWJvbCA9IFwiXFx1MDM5ZVwiOyAvLyBcIlxcdUQ4MzVcXHVERjYzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/strings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/_version.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib/_version.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"hash/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliL192ZXJzaW9uLmpzPzRjODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSBcImhhc2gvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/id.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib/id.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.id = void 0;\nvar keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nfunction id(text) {\n    return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));\n}\nexports.id = id;\n//# sourceMappingURL=id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi9pZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxVQUFVO0FBQ1Ysa0JBQWtCLG1CQUFPLENBQUMsZ0hBQTBCO0FBQ3BELGdCQUFnQixtQkFBTyxDQUFDLDRHQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIvaWQuanM/Y2Q5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaWQgPSB2b2lkIDA7XG52YXIga2VjY2FrMjU2XzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCIpO1xuZnVuY3Rpb24gaWQodGV4dCkge1xuICAgIHJldHVybiAoMCwga2VjY2FrMjU2XzEua2VjY2FrMjU2KSgoMCwgc3RyaW5nc18xLnRvVXRmOEJ5dGVzKSh0ZXh0KSk7XG59XG5leHBvcnRzLmlkID0gaWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.isValidName = exports.namehash = exports.id = void 0;\nvar id_1 = __webpack_require__(/*! ./id */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/id.js\");\nObject.defineProperty(exports, \"id\", ({ enumerable: true, get: function () { return id_1.id; } }));\nvar namehash_1 = __webpack_require__(/*! ./namehash */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/namehash.js\");\nObject.defineProperty(exports, \"isValidName\", ({ enumerable: true, get: function () { return namehash_1.isValidName; } }));\nObject.defineProperty(exports, \"namehash\", ({ enumerable: true, get: function () { return namehash_1.namehash; } }));\nvar message_1 = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/message.js\");\nObject.defineProperty(exports, \"hashMessage\", ({ enumerable: true, get: function () { return message_1.hashMessage; } }));\nObject.defineProperty(exports, \"messagePrefix\", ({ enumerable: true, get: function () { return message_1.messagePrefix; } }));\nvar typed_data_1 = __webpack_require__(/*! ./typed-data */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/typed-data.js\");\nObject.defineProperty(exports, \"_TypedDataEncoder\", ({ enumerable: true, get: function () { return typed_data_1.TypedDataEncoder; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUIsR0FBRyxnQkFBZ0IsR0FBRyxVQUFVO0FBQzdILFdBQVcsbUJBQU8sQ0FBQyxvRkFBTTtBQUN6QixzQ0FBcUMsRUFBRSxxQ0FBcUMsbUJBQW1CLEVBQUM7QUFDaEcsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQVk7QUFDckMsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBVztBQUNuQywrQ0FBOEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDdkgsaURBQWdELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzNILG1CQUFtQixtQkFBTyxDQUFDLG9HQUFjO0FBQ3pDLHFEQUFvRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNySSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi9pbmRleC5qcz9jYmE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5fVHlwZWREYXRhRW5jb2RlciA9IGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBleHBvcnRzLm1lc3NhZ2VQcmVmaXggPSBleHBvcnRzLmlzVmFsaWROYW1lID0gZXhwb3J0cy5uYW1laGFzaCA9IGV4cG9ydHMuaWQgPSB2b2lkIDA7XG52YXIgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlkXzEuaWQ7IH0gfSk7XG52YXIgbmFtZWhhc2hfMSA9IHJlcXVpcmUoXCIuL25hbWVoYXNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZE5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWVoYXNoXzEuaXNWYWxpZE5hbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW1laGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZWhhc2hfMS5uYW1laGFzaDsgfSB9KTtcbnZhciBtZXNzYWdlXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VfMS5oYXNoTWVzc2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1lc3NhZ2VQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VfMS5tZXNzYWdlUHJlZml4OyB9IH0pO1xudmFyIHR5cGVkX2RhdGFfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWRhdGFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfVHlwZWREYXRhRW5jb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZWRfZGF0YV8xLlR5cGVkRGF0YUVuY29kZXI7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/message.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib/message.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashMessage = exports.messagePrefix = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nexports.messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\nfunction hashMessage(message) {\n    if (typeof (message) === \"string\") {\n        message = (0, strings_1.toUtf8Bytes)(message);\n    }\n    return (0, keccak256_1.keccak256)((0, bytes_1.concat)([\n        (0, strings_1.toUtf8Bytes)(exports.messagePrefix),\n        (0, strings_1.toUtf8Bytes)(String(message.length)),\n        message\n    ]));\n}\nexports.hashMessage = hashMessage;\n//# sourceMappingURL=message.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi9tZXNzYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHFCQUFxQjtBQUMzQyxjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBd0I7QUFDaEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliL21lc3NhZ2UuanM/YWFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBleHBvcnRzLm1lc3NhZ2VQcmVmaXggPSB2b2lkIDA7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBrZWNjYWsyNTZfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIik7XG5leHBvcnRzLm1lc3NhZ2VQcmVmaXggPSBcIlxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuXCI7XG5mdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9ICgwLCBzdHJpbmdzXzEudG9VdGY4Qnl0ZXMpKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGtlY2NhazI1Nl8xLmtlY2NhazI1NikoKDAsIGJ5dGVzXzEuY29uY2F0KShbXG4gICAgICAgICgwLCBzdHJpbmdzXzEudG9VdGY4Qnl0ZXMpKGV4cG9ydHMubWVzc2FnZVByZWZpeCksXG4gICAgICAgICgwLCBzdHJpbmdzXzEudG9VdGY4Qnl0ZXMpKFN0cmluZyhtZXNzYWdlLmxlbmd0aCkpLFxuICAgICAgICBtZXNzYWdlXG4gICAgXSkpO1xufVxuZXhwb3J0cy5oYXNoTWVzc2FnZSA9IGhhc2hNZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/namehash.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib/namehash.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.namehash = exports.isValidName = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nvar keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar Zeros = new Uint8Array(32);\nZeros.fill(0);\nvar Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nfunction isValidName(name) {\n    try {\n        var comps = name.split(\".\");\n        for (var i = 0; i < comps.length; i++) {\n            if ((0, strings_1.nameprep)(comps[i]).length === 0) {\n                throw new Error(\"empty\");\n            }\n        }\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isValidName = isValidName;\nfunction namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    var current = name;\n    var result = Zeros;\n    while (current.length) {\n        var partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        var label = (0, strings_1.toUtf8Bytes)((0, strings_1.nameprep)(partition[3]));\n        result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(label)]));\n        current = partition[2] || \"\";\n    }\n    return (0, bytes_1.hexlify)(result);\n}\nexports.namehash = namehash;\n//# sourceMappingURL=namehash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi9uYW1laGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxtQkFBbUI7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBd0I7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsZ0hBQTBCO0FBQ3BELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliL25hbWVoYXNoLmpzPzIxYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5hbWVoYXNoID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IHZvaWQgMDtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCIpO1xudmFyIGtlY2NhazI1Nl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBaZXJvcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcblplcm9zLmZpbGwoMCk7XG52YXIgUGFydGl0aW9uID0gbmV3IFJlZ0V4cChcIl4oKC4qKVxcXFwuKT8oW14uXSspJFwiKTtcbmZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgY29tcHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgwLCBzdHJpbmdzXzEubmFtZXByZXApKGNvbXBzW2ldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVmFsaWROYW1lID0gaXNWYWxpZE5hbWU7XG5mdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiAobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWU7IG5vdCBhIHN0cmluZ1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmFtZTtcbiAgICB2YXIgcmVzdWx0ID0gWmVyb3M7XG4gICAgd2hpbGUgKGN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXJ0aXRpb24gPSBjdXJyZW50Lm1hdGNoKFBhcnRpdGlvbik7XG4gICAgICAgIGlmIChwYXJ0aXRpb24gPT0gbnVsbCB8fCBwYXJ0aXRpb25bMl0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBhZGRyZXNzOyBtaXNzaW5nIGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhYmVsID0gKDAsIHN0cmluZ3NfMS50b1V0ZjhCeXRlcykoKDAsIHN0cmluZ3NfMS5uYW1lcHJlcCkocGFydGl0aW9uWzNdKSk7XG4gICAgICAgIHJlc3VsdCA9ICgwLCBrZWNjYWsyNTZfMS5rZWNjYWsyNTYpKCgwLCBieXRlc18xLmNvbmNhdCkoW3Jlc3VsdCwgKDAsIGtlY2NhazI1Nl8xLmtlY2NhazI1NikobGFiZWwpXSkpO1xuICAgICAgICBjdXJyZW50ID0gcGFydGl0aW9uWzJdIHx8IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KShyZXN1bHQpO1xufVxuZXhwb3J0cy5uYW1laGFzaCA9IG5hbWVoYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/namehash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/typed-data.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/hash/lib/typed-data.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypedDataEncoder = void 0;\nvar address_1 = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar id_1 = __webpack_require__(/*! ./id */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/id.js\");\nvar padding = new Uint8Array(32);\npadding.fill(0);\nvar NegativeOne = bignumber_1.BigNumber.from(-1);\nvar Zero = bignumber_1.BigNumber.from(0);\nvar One = bignumber_1.BigNumber.from(1);\nvar MaxUint256 = bignumber_1.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    var bytes = (0, bytes_1.arrayify)(value);\n    var padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0, bytes_1.hexConcat)([bytes, padding.slice(padOffset)]);\n    }\n    return (0, bytes_1.hexlify)(bytes);\n}\nvar hexTrue = (0, bytes_1.hexZeroPad)(One.toHexString(), 32);\nvar hexFalse = (0, bytes_1.hexZeroPad)(Zero.toHexString(), 32);\nvar domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nvar domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(\"invalid domain value for \" + JSON.stringify(key), \"domain.\" + key, value);\n        }\n        return value;\n    };\n}\nvar domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return bignumber_1.BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(\"invalid domain value for \\\"chainId\\\"\", \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return (0, address_1.getAddress)(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(\"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            var bytes = (0, bytes_1.arrayify)(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return (0, bytes_1.hexlify)(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(\"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        var match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            var signed = (match[1] === \"\");\n            var width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            var boundsUpper_1 = MaxUint256.mask(signed ? (width - 1) : width);\n            var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                var v = bignumber_1.BigNumber.from(value);\n                if (v.lt(boundsLower_1) || v.gt(boundsUpper_1)) {\n                    logger.throwArgumentError(\"value out-of-bounds for \" + type, \"value\", value);\n                }\n                return (0, bytes_1.hexZeroPad)(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        var match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            var width_1 = parseInt(match[1]);\n            if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                var bytes = (0, bytes_1.arrayify)(value);\n                if (bytes.length !== width_1) {\n                    logger.throwArgumentError(\"invalid length for \" + type, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return (0, keccak256_1.keccak256)(value);\n        };\n        case \"string\": return function (value) {\n            return (0, id_1.id)(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return name + \"(\" + fields.map(function (_a) {\n        var name = _a.name, type = _a.type;\n        return (type + \" \" + name);\n    }).join(\",\") + \")\";\n}\nvar TypedDataEncoder = /** @class */ (function () {\n    function TypedDataEncoder(types) {\n        (0, properties_1.defineReadOnly)(this, \"types\", Object.freeze((0, properties_1.deepCopy)(types)));\n        (0, properties_1.defineReadOnly)(this, \"_encoderCache\", {});\n        (0, properties_1.defineReadOnly)(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        var links = {};\n        // Link structs to structs which contain them as a child\n        var parents = {};\n        // Link all subtypes within a given struct\n        var subtypes = {};\n        Object.keys(types).forEach(function (type) {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        var _loop_1 = function (name_1) {\n            var uniqueNames = {};\n            types[name_1].forEach(function (field) {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(\"duplicate variable name \" + JSON.stringify(field.name) + \" in \" + JSON.stringify(name_1), \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                var baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name_1) {\n                    logger.throwArgumentError(\"circular type reference to \" + JSON.stringify(baseType), \"types\", types);\n                }\n                // Is this a base encoding type?\n                var encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(\"unknown type \" + JSON.stringify(baseType), \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name_1);\n                links[name_1][baseType] = true;\n            });\n        };\n        for (var name_1 in types) {\n            _loop_1(name_1);\n        }\n        // Deduce the primary type\n        var primaryTypes = Object.keys(parents).filter(function (n) { return (parents[n].length === 0); });\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(\"ambiguous primary types or unused types: \" + primaryTypes.map(function (t) { return (JSON.stringify(t)); }).join(\", \"), \"types\", types);\n        }\n        (0, properties_1.defineReadOnly)(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(\"circular type reference to \" + JSON.stringify(type), \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach(function (child) {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach(function (subtype) {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (var name_2 in subtypes) {\n            var st = Object.keys(subtypes[name_2]);\n            st.sort();\n            this._types[name_2] = encodeType(name_2, types[name_2]) + st.map(function (t) { return encodeType(t, types[t]); }).join(\"\");\n        }\n    }\n    TypedDataEncoder.prototype.getEncoder = function (type) {\n        var encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    };\n    TypedDataEncoder.prototype._getEncoder = function (type) {\n        var _this = this;\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            var encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            var subtype_1 = match[1];\n            var subEncoder_1 = this.getEncoder(subtype_1);\n            var length_1 = parseInt(match[3]);\n            return function (value) {\n                if (length_1 >= 0 && value.length !== length_1) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                var result = value.map(subEncoder_1);\n                if (_this._types[subtype_1]) {\n                    result = result.map(keccak256_1.keccak256);\n                }\n                return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));\n            };\n        }\n        // Struct\n        var fields = this.types[type];\n        if (fields) {\n            var encodedType_1 = (0, id_1.id)(this._types[type]);\n            return function (value) {\n                var values = fields.map(function (_a) {\n                    var name = _a.name, type = _a.type;\n                    var result = _this.getEncoder(type)(value[name]);\n                    if (_this._types[type]) {\n                        return (0, keccak256_1.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType_1);\n                return (0, bytes_1.hexConcat)(values);\n            };\n        }\n        return logger.throwArgumentError(\"unknown type: \" + type, \"type\", type);\n    };\n    TypedDataEncoder.prototype.encodeType = function (name) {\n        var result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(\"unknown type: \" + JSON.stringify(name), \"name\", name);\n        }\n        return result;\n    };\n    TypedDataEncoder.prototype.encodeData = function (type, value) {\n        return this.getEncoder(type)(value);\n    };\n    TypedDataEncoder.prototype.hashStruct = function (name, value) {\n        return (0, keccak256_1.keccak256)(this.encodeData(name, value));\n    };\n    TypedDataEncoder.prototype.encode = function (value) {\n        return this.encodeData(this.primaryType, value);\n    };\n    TypedDataEncoder.prototype.hash = function (value) {\n        return this.hashStruct(this.primaryType, value);\n    };\n    TypedDataEncoder.prototype._visit = function (type, value, callback) {\n        var _this = this;\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            var encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            var subtype_2 = match[1];\n            var length_2 = parseInt(match[3]);\n            if (length_2 >= 0 && value.length !== length_2) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map(function (v) { return _this._visit(subtype_2, v, callback); });\n        }\n        // Struct\n        var fields = this.types[type];\n        if (fields) {\n            return fields.reduce(function (accum, _a) {\n                var name = _a.name, type = _a.type;\n                accum[name] = _this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(\"unknown type: \" + type, \"type\", type);\n    };\n    TypedDataEncoder.prototype.visit = function (value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    };\n    TypedDataEncoder.from = function (types) {\n        return new TypedDataEncoder(types);\n    };\n    TypedDataEncoder.getPrimaryType = function (types) {\n        return TypedDataEncoder.from(types).primaryType;\n    };\n    TypedDataEncoder.hashStruct = function (name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    };\n    TypedDataEncoder.hashDomain = function (domain) {\n        var domainFields = [];\n        for (var name_3 in domain) {\n            var type = domainFieldTypes[name_3];\n            if (!type) {\n                logger.throwArgumentError(\"invalid typed-data domain key: \" + JSON.stringify(name_3), \"domain\", domain);\n            }\n            domainFields.push({ name: name_3, type: type });\n        }\n        domainFields.sort(function (a, b) {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    };\n    TypedDataEncoder.encode = function (domain, types, value) {\n        return (0, bytes_1.hexConcat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    };\n    TypedDataEncoder.hash = function (domain, types, value) {\n        return (0, keccak256_1.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    };\n    // Replaces all address types with ENS names with their looked up address\n    TypedDataEncoder.resolveNames = function (domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function () {\n            var ensCache, encoder, _a, _b, _i, name_4, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        // Make a copy to isolate it from the object passed in\n                        domain = (0, properties_1.shallowCopy)(domain);\n                        ensCache = {};\n                        // Do we need to look up the domain's verifyingContract?\n                        if (domain.verifyingContract && !(0, bytes_1.isHexString)(domain.verifyingContract, 20)) {\n                            ensCache[domain.verifyingContract] = \"0x\";\n                        }\n                        encoder = TypedDataEncoder.from(types);\n                        // Get a list of all the addresses\n                        encoder.visit(value, function (type, value) {\n                            if (type === \"address\" && !(0, bytes_1.isHexString)(value, 20)) {\n                                ensCache[value] = \"0x\";\n                            }\n                            return value;\n                        });\n                        _a = [];\n                        for (_b in ensCache)\n                            _a.push(_b);\n                        _i = 0;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        name_4 = _a[_i];\n                        _c = ensCache;\n                        _d = name_4;\n                        return [4 /*yield*/, resolveName(name_4)];\n                    case 2:\n                        _c[_d] = _e.sent();\n                        _e.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        // Replace the domain verifyingContract if needed\n                        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                            domain.verifyingContract = ensCache[domain.verifyingContract];\n                        }\n                        // Replace all ENS names with their address\n                        value = encoder.visit(value, function (type, value) {\n                            if (type === \"address\" && ensCache[value]) {\n                                return ensCache[value];\n                            }\n                            return value;\n                        });\n                        return [2 /*return*/, { domain: domain, value: value }];\n                }\n            });\n        });\n    };\n    TypedDataEncoder.getPayload = function (domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        var domainValues = {};\n        var domainTypes = [];\n        domainFieldNames.forEach(function (name) {\n            var value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name: name, type: domainFieldTypes[name] });\n        });\n        var encoder = TypedDataEncoder.from(types);\n        var typesWithDomain = (0, properties_1.shallowCopy)(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, function (type, value) {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return bignumber_1.BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(\"invalid string\", \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    };\n    return TypedDataEncoder;\n}());\nexports.TypedDataEncoder = TypedDataEncoder;\n//# sourceMappingURL=typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi90eXBlZC1kYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsZ0JBQWdCLG1CQUFPLENBQUMsNEdBQXdCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLDBHQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBWTtBQUNyQztBQUNBLFdBQVcsbUJBQU8sQ0FBQyxvRkFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLG1DQUFtQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCw2QkFBNkI7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixpQ0FBaUM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxtQkFBbUIsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1CQUFtQixhQUFhO0FBQ2xHO0FBQ0EsNENBQTRDLDhDQUE4QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkRBQTZELDRCQUE0QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGdEQUFnRCw4QkFBOEI7QUFDOUU7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBDQUEwQztBQUN6RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliL3R5cGVkLWRhdGEuanM/OWM0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGVkRGF0YUVuY29kZXIgPSB2b2lkIDA7XG52YXIgYWRkcmVzc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIga2VjY2FrMjU2XzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCIpO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIGlkXzEgPSByZXF1aXJlKFwiLi9pZFwiKTtcbnZhciBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xudmFyIE5lZ2F0aXZlT25lID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oLTEpO1xudmFyIFplcm8gPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSgwKTtcbnZhciBPbmUgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSgxKTtcbnZhciBNYXhVaW50MjU2ID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIHZhciBieXRlcyA9ICgwLCBieXRlc18xLmFycmF5aWZ5KSh2YWx1ZSk7XG4gICAgdmFyIHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmhleENvbmNhdCkoW2J5dGVzLCBwYWRkaW5nLnNsaWNlKHBhZE9mZnNldCldKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmhleGxpZnkpKGJ5dGVzKTtcbn1cbnZhciBoZXhUcnVlID0gKDAsIGJ5dGVzXzEuaGV4WmVyb1BhZCkoT25lLnRvSGV4U3RyaW5nKCksIDMyKTtcbnZhciBoZXhGYWxzZSA9ICgwLCBieXRlc18xLmhleFplcm9QYWQpKFplcm8udG9IZXhTdHJpbmcoKSwgMzIpO1xudmFyIGRvbWFpbkZpZWxkVHlwZXMgPSB7XG4gICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgIGNoYWluSWQ6IFwidWludDI1NlwiLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxufTtcbnZhciBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZG9tYWluIHZhbHVlIGZvciBcIiArIEpTT04uc3RyaW5naWZ5KGtleSksIFwiZG9tYWluLlwiICsga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG52YXIgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgXFxcImNoYWluSWRcXFwiXCIsIFwiZG9tYWluLmNoYWluSWRcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBhZGRyZXNzXzEuZ2V0QWRkcmVzcykodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcXFwidmVyaWZ5aW5nQ29udHJhY3RcXFwiXCIsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNhbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJ5dGVzID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcXFwic2FsdFxcXCJcIiwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcbiAgICAvLyBpbnRYWCBhbmQgdWludFhYXG4gICAge1xuICAgICAgICB2YXIgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQqKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgaWYgKHdpZHRoICUgOCAhPT0gMCB8fCB3aWR0aCA+IDI1NiB8fCAobWF0Y2hbMl0gJiYgbWF0Y2hbMl0gIT09IFN0cmluZyh3aWR0aCkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYm91bmRzVXBwZXJfMSA9IE1heFVpbnQyNTYubWFzayhzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIHZhciBib3VuZHNMb3dlcl8xID0gc2lnbmVkID8gYm91bmRzVXBwZXJfMS5hZGQoT25lKS5tdWwoTmVnYXRpdmVPbmUpIDogWmVybztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodi5sdChib3VuZHNMb3dlcl8xKSB8fCB2Lmd0KGJvdW5kc1VwcGVyXzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzIGZvciBcIiArIHR5cGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4WmVyb1BhZCkodi50b1R3b3MoMjU2KS50b0hleFN0cmluZygpLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIHZhciBtYXRjaCA9IHR5cGUubWF0Y2goL15ieXRlcyhcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGhfMSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmICh3aWR0aF8xID09PSAwIHx8IHdpZHRoXzEgPiAzMiB8fCBtYXRjaFsxXSAhPT0gU3RyaW5nKHdpZHRoXzEpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlcyA9ICgwLCBieXRlc18xLmFycmF5aWZ5KSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gd2lkdGhfMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgdHlwZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4WmVyb1BhZCkoKDAsIGFkZHJlc3NfMS5nZXRBZGRyZXNzKSh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2NhazI1Nl8xLmtlY2NhazI1NikodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaWRfMS5pZCkodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIG5hbWUgKyBcIihcIiArIGZpZWxkcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiAodHlwZSArIFwiIFwiICsgbmFtZSk7XG4gICAgfSkuam9pbihcIixcIikgKyBcIilcIjtcbn1cbnZhciBUeXBlZERhdGFFbmNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVkRGF0YUVuY29kZXIodHlwZXMpIHtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJ0eXBlc1wiLCBPYmplY3QuZnJlZXplKCgwLCBwcm9wZXJ0aWVzXzEuZGVlcENvcHkpKHR5cGVzKSkpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9lbmNvZGVyQ2FjaGVcIiwge30pO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl90eXBlc1wiLCB7fSk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXG4gICAgICAgIHZhciBsaW5rcyA9IHt9O1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICB2YXIgcGFyZW50cyA9IHt9O1xuICAgICAgICAvLyBMaW5rIGFsbCBzdWJ0eXBlcyB3aXRoaW4gYSBnaXZlbiBzdHJ1Y3RcbiAgICAgICAgdmFyIHN1YnR5cGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBsaW5rc1t0eXBlXSA9IHt9O1xuICAgICAgICAgICAgcGFyZW50c1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgc3VidHlwZXNbdHlwZV0gPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG5hbWVfMSkge1xuICAgICAgICAgICAgdmFyIHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgICAgICB0eXBlc1tuYW1lXzFdLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVOYW1lc1tmaWVsZC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgXCIgKyBKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKSArIFwiIGluIFwiICsgSlNPTi5zdHJpbmdpZnkobmFtZV8xKSwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICB2YXIgYmFzZVR5cGUgPSBmaWVsZC50eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoXFx4NWJ8JCkvKVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVR5cGUgPT09IG5hbWVfMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gXCIgKyBKU09OLnN0cmluZ2lmeShiYXNlVHlwZSksIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIHZhciBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2Jhc2VUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzW2Jhc2VUeXBlXS5wdXNoKG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgbGlua3NbbmFtZV8xXVtiYXNlVHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB0eXBlcykge1xuICAgICAgICAgICAgX2xvb3BfMShuYW1lXzEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIHZhciBwcmltYXJ5VHlwZXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIChwYXJlbnRzW25dLmxlbmd0aCA9PT0gMCk7IH0pO1xuICAgICAgICBpZiAocHJpbWFyeVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaW1hcnlUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiBcIiArIHByaW1hcnlUeXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChKU09OLnN0cmluZ2lmeSh0KSk7IH0pLmpvaW4oXCIsIFwiKSwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwcmltYXJ5VHlwZVwiLCBwcmltYXJ5VHlwZXNbMF0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2lyY3VsYXIodHlwZSwgZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpbmtzW3R5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50c1tjaGlsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNoZWNrQ2lyY3VsYXIoY2hpbGQsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZm91bmQpLmZvckVhY2goZnVuY3Rpb24gKHN1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXNbc3VidHlwZV1bY2hpbGRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIGZvdW5kW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwge30pO1xuICAgICAgICAvLyBDb21wdXRlIGVhY2ggZnVsbHkgZGVzY3JpYmUgdHlwZVxuICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gc3VidHlwZXMpIHtcbiAgICAgICAgICAgIHZhciBzdCA9IE9iamVjdC5rZXlzKHN1YnR5cGVzW25hbWVfMl0pO1xuICAgICAgICAgICAgc3Quc29ydCgpO1xuICAgICAgICAgICAgdGhpcy5fdHlwZXNbbmFtZV8yXSA9IGVuY29kZVR5cGUobmFtZV8yLCB0eXBlc1tuYW1lXzJdKSArIHN0Lm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSk7IH0pLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuZ2V0RW5jb2RlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBlbmNvZGVyID0gdGhpcy5fZW5jb2RlckNhY2hlW3R5cGVdO1xuICAgICAgICBpZiAoIWVuY29kZXIpIHtcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV0gPSB0aGlzLl9nZXRFbmNvZGVyKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuX2dldEVuY29kZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgdmFyIG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHN1YnR5cGVfMSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdmFyIHN1YkVuY29kZXJfMSA9IHRoaXMuZ2V0RW5jb2RlcihzdWJ0eXBlXzEpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhfMSA+PSAwICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcl8xKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3R5cGVzW3N1YnR5cGVfMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTZfMS5rZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGtlY2NhazI1Nl8xLmtlY2NhazI1NikoKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RlZFR5cGVfMSA9ICgwLCBpZF8xLmlkKSh0aGlzLl90eXBlc1t0eXBlXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl90eXBlc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBrZWNjYWsyNTZfMS5rZWNjYWsyNTYpKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZV8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KSh2YWx1ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfTtcbiAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGVUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3R5cGVzW25hbWVdO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVua25vd24gdHlwZTogXCIgKyBKU09OLnN0cmluZ2lmeShuYW1lKSwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGVEYXRhID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuaGFzaFN0cnVjdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIGtlY2NhazI1Nl8xLmtlY2NhazI1NikodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRGF0YSh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBUeXBlZERhdGFFbmNvZGVyLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUuX3Zpc2l0ID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICB2YXIgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgc3VidHlwZV8yID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB2YXIgbGVuZ3RoXzIgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoXzIgPj0gMCAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aF8yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5fdmlzaXQoc3VidHlwZV8yLCB2LCBjYWxsYmFjayk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBfYSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSBfdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfTtcbiAgICBUeXBlZERhdGFFbmNvZGVyLmdldFByaW1hcnlUeXBlID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0ID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoU3RydWN0KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcbiAgICAgICAgdmFyIGRvbWFpbkZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV8zXTtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogXCIgKyBKU09OLnN0cmluZ2lmeShuYW1lXzMpLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lOiBuYW1lXzMsIHR5cGU6IHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluRmllbGRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLCB7IEVJUDcxMkRvbWFpbjogZG9tYWluRmllbGRzIH0sIGRvbWFpbik7XG4gICAgfTtcbiAgICBUeXBlZERhdGFFbmNvZGVyLmVuY29kZSA9IGZ1bmN0aW9uIChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoID0gZnVuY3Rpb24gKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwga2VjY2FrMjU2XzEua2VjY2FrMjU2KShUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIFR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzID0gZnVuY3Rpb24gKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW5zQ2FjaGUsIGVuY29kZXIsIF9hLCBfYiwgX2ksIG5hbWVfNCwgX2MsIF9kO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgdG8gaXNvbGF0ZSBpdCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KShkb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5zQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICEoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LCAyMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgISgwLCBieXRlc18xLmlzSGV4U3RyaW5nKSh2YWx1ZSwgMjApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfYiBpbiBlbnNDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5wdXNoKF9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBfYS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfNCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gZW5zQ2FjaGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IG5hbWVfNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVOYW1lKG5hbWVfNCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY1tfZF0gPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgZG9tYWluIHZlcmlmeWluZ0NvbnRyYWN0IGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmIGVuc0NhY2hlW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGRvbWFpbjogZG9tYWluLCB2YWx1ZTogdmFsdWUgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkID0gZnVuY3Rpb24gKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkb21haW4gZmllbGRzXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBEZXJpdmUgdGhlIEVJUDcxMkRvbWFpbiBTdHJ1Y3QgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgdmFyIGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICB2YXIgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkb21haW5bbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XG4gICAgICAgICAgICBkb21haW5UeXBlcy5wdXNoKHsgbmFtZTogbmFtZSwgdHlwZTogZG9tYWluRmllbGRUeXBlc1tuYW1lXSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgdmFyIHR5cGVzV2l0aERvbWFpbiA9ICgwLCBwcm9wZXJ0aWVzXzEuc2hhbGxvd0NvcHkpKHR5cGVzKTtcbiAgICAgICAgaWYgKHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsIFwidHlwZXMuRUlQNzEyRG9tYWluXCIsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xuICAgICAgICBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxuICAgICAgICAgICAgZG9tYWluOiBkb21haW5WYWx1ZXMsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogZW5jb2Rlci5wcmltYXJ5VHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsIGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL15ieXRlcyhcXGQqKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KSgoMCwgYnl0ZXNfMS5hcnJheWlmeSkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlcjtcbn0oKSk7XG5leHBvcnRzLlR5cGVkRGF0YUVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQtZGF0YS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keccak256 = void 0;\nvar js_sha3_1 = __importDefault(__webpack_require__(/*! js-sha3 */ \"(ssr)/./node_modules/js-sha3/src/sha3.js\"));\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nfunction keccak256(data) {\n    return '0x' + js_sha3_1.default.keccak_256((0, bytes_1.arrayify)(data));\n}\nexports.keccak256 = keccak256;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9rZWNjYWsyNTYvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGdDQUFnQyxtQkFBTyxDQUFDLHlEQUFTO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIvaW5kZXguanM/MjBjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gdm9pZCAwO1xudmFyIGpzX3NoYTNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianMtc2hhM1wiKSk7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbmZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG4gICAgcmV0dXJuICcweCcgKyBqc19zaGEzXzEuZGVmYXVsdC5rZWNjYWtfMjU2KCgwLCBieXRlc18xLmFycmF5aWZ5KShkYXRhKSk7XG59XG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1Njtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/_version.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/logger/lib/_version.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"logger/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9sb2dnZXIvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi9fdmVyc2lvbi5qcz9jNzk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJsb2dnZXIvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = exports.ErrorCode = exports.LogLevel = void 0;\nvar _permanentCensorErrors = false;\nvar _censorErrors = false;\nvar LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nvar _logLevel = LogLevels[\"default\"];\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/_version.js\");\nvar _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        var missing_1 = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(function (form) {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing_1.push(form);\n            }\n        });\n        if (missing_1.length) {\n            throw new Error(\"missing \" + missing_1.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nvar _normalizeError = _checkNormalize();\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));\n;\nvar HEX = \"0123456789abcdef\";\nvar Logger = /** @class */ (function () {\n    function Logger(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    Logger.prototype._log = function (logLevel, args) {\n        var level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    };\n    Logger.prototype.debug = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._log(Logger.levels.DEBUG, args);\n    };\n    Logger.prototype.info = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._log(Logger.levels.INFO, args);\n    };\n    Logger.prototype.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._log(Logger.levels.WARNING, args);\n    };\n    Logger.prototype.makeError = function (message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        var messageDetails = [];\n        Object.keys(params).forEach(function (key) {\n            var value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    var hex = \"\";\n                    for (var i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(\"code=\" + code);\n        messageDetails.push(\"version=\" + this.version);\n        var reason = message;\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        var error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    };\n    Logger.prototype.throwError = function (message, code, params) {\n        throw this.makeError(message, code, params);\n    };\n    Logger.prototype.throwArgumentError = function (message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    };\n    Logger.prototype.assert = function (condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    };\n    Logger.prototype.assertArgument = function (condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    };\n    Logger.prototype.checkNormalize = function (message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    };\n    Logger.prototype.checkSafeUint53 = function (value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    };\n    Logger.prototype.checkArgumentCount = function (count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    };\n    Logger.prototype.checkNew = function (target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    };\n    Logger.prototype.checkAbstract = function (target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    };\n    Logger.globalLogger = function () {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(_version_1.version);\n        }\n        return _globalLogger;\n    };\n    Logger.setCensorship = function (censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    };\n    Logger.setLogLevel = function (logLevel) {\n        var level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    };\n    Logger.from = function (version) {\n        return new Logger(version);\n    };\n    Logger.errors = ErrorCode;\n    Logger.levels = LogLevel;\n    return Logger;\n}());\nexports.Logger = Logger;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9sb2dnZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGtHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DLGlCQUFpQixLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx5REFBeUQscUNBQXFDO0FBQ3pNO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIvaW5kZXguanM/Y2E5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nZ2VyID0gZXhwb3J0cy5FcnJvckNvZGUgPSBleHBvcnRzLkxvZ0xldmVsID0gdm9pZCAwO1xudmFyIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSBmYWxzZTtcbnZhciBfY2Vuc29yRXJyb3JzID0gZmFsc2U7XG52YXIgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbnZhciBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xudmFyIF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvblwiKTtcbnZhciBfZ2xvYmFsTG9nZ2VyID0gbnVsbDtcbmZ1bmN0aW9uIF9jaGVja05vcm1hbGl6ZSgpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgbWlzc2luZ18xID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgZm9ybXMgb2Ygbm9ybWFsaXphdGlvbiBhcmUgc3VwcG9ydGVkXG4gICAgICAgIFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLmZvckVhY2goZnVuY3Rpb24gKGZvcm0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ18xLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZ18xLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3NpbmdfMS5qb2luKFwiLCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcbnZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICBMb2dMZXZlbFtcIkRFQlVHXCJdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xuICAgIExvZ0xldmVsW1wiV0FSTklOR1wiXSA9IFwiV0FSTklOR1wiO1xuICAgIExvZ0xldmVsW1wiRVJST1JcIl0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbXCJPRkZcIl0gPSBcIk9GRlwiO1xufSkoTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBHZW5lcmljIEVycm9yc1xuICAgIC8vIFVua25vd24gRXJyb3JcbiAgICBFcnJvckNvZGVbXCJVTktOT1dOX0VSUk9SXCJdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgLy8gTm90IEltcGxlbWVudGVkXG4gICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgICAvLyBVbnN1cHBvcnRlZCBPcGVyYXRpb25cbiAgICAvLyAgIC0gb3BlcmF0aW9uXG4gICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcbiAgICAvLyBOZXR3b3JrIEVycm9yIChpLmUuIEV0aGVyZXVtIE5ldHdvcmssIHN1Y2ggYXMgYW4gaW52YWxpZCBjaGFpbiBJRClcbiAgICAvLyAgIC0gZXZlbnQgKFwibm9OZXR3b3JrXCIgaXMgbm90IHJlLXRocm93biBpbiBwcm92aWRlci5yZWFkeTsgb3RoZXJ3aXNlIHRocm93bilcbiAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgLy8gU29tZSBzb3J0IG9mIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICBFcnJvckNvZGVbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuICAgIC8vIFRpbWVvdXRcbiAgICBFcnJvckNvZGVbXCJUSU1FT1VUXCJdID0gXCJUSU1FT1VUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcbiAgICAvLyBCdWZmZXIgT3ZlcnJ1blxuICAgIEVycm9yQ29kZVtcIkJVRkZFUl9PVkVSUlVOXCJdID0gXCJCVUZGRVJfT1ZFUlJVTlwiO1xuICAgIC8vIE51bWVyaWMgRmF1bHRcbiAgICAvLyAgIC0gb3BlcmF0aW9uOiB0aGUgb3BlcmF0aW9uIGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gICAtIGZhdWx0OiB0aGUgcmVhc29uIHRoaXMgZmF1bHRlZFxuICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQXJndW1lbnQgRXJyb3JzXG4gICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG4gICAgLy8gIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl0gPSBcIk1JU1NJTkdfTkVXXCI7XG4gICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBhcmd1bWVudDogVGhlIGFyZ3VtZW50IG5hbWUgdGhhdCB3YXMgaW52YWxpZFxuICAgIC8vICAgLSB2YWx1ZTogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICAvLyBNaXNzaW5nIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfQVJHVU1FTlRcIl0gPSBcIk1JU1NJTkdfQVJHVU1FTlRcIjtcbiAgICAvLyBUb28gbWFueSBhcmd1bWVudHNcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiXSA9IFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCbG9ja2NoYWluIEVycm9yc1xuICAgIC8vIENhbGwgZXhjZXB0aW9uXG4gICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuICAgIC8vICAtIGFkZHJlc3M/OiB0aGUgY29udHJhY3QgYWRkcmVzc1xuICAgIC8vICAtIGFyZ3M/OiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JTaWduYXR1cmU/OiBUaGUgRUlQODQ4IGVycm9yIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yQXJncz86IFRoZSBFSVA4NDggZXJyb3IgcGFyYW1ldGVyc1xuICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuICAgIEVycm9yQ29kZVtcIkNBTExfRVhDRVBUSU9OXCJdID0gXCJDQUxMX0VYQ0VQVElPTlwiO1xuICAgIC8vIEluc3VmZmljaWVudCBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdID0gXCJOT05DRV9FWFBJUkVEXCI7XG4gICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiXSA9IFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtcbiAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBwYXNzZWQgdG8gZXN0aW1hdGVHYXNcbiAgICBFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXSA9IFwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIjtcbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkIGJ5IG9uZSB3aXRoIGEgaGlnaGVyIGdhcyBwcmljZVxuICAgIC8vICAgLSByZWFzb246IFwiY2FuY2VsbGVkXCIsIFwicmVwbGFjZWRcIiBvciBcInJlcHJpY2VkXCJcbiAgICAvLyAgIC0gY2FuY2VsbGVkOiB0cnVlIGlmIHJlYXNvbiA9PSBcImNhbmNlbGxlZFwiIG9yIHJlYXNvbiA9PSBcInJlcGxhY2VkXCIpXG4gICAgLy8gICAtIGhhc2g6IG9yaWdpbmFsIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAvLyAgIC0gcmVwbGFjZW1lbnQ6IHRoZSBmdWxsIFRyYW5zYWN0aW9uc1Jlc3BvbnNlIGZvciB0aGUgcmVwbGFjZW1lbnRcbiAgICAvLyAgIC0gcmVjZWlwdDogdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgRXJyb3JDb2RlW1wiVFJBTlNBQ1RJT05fUkVQTEFDRURcIl0gPSBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCI7XG59KShFcnJvckNvZGUgPSBleHBvcnRzLkVycm9yQ29kZSB8fCAoZXhwb3J0cy5FcnJvckNvZGUgPSB7fSkpO1xuO1xudmFyIEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xudmFyIExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXIodmVyc2lvbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmVyc2lvbixcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5fbG9nID0gZnVuY3Rpb24gKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChMb2dMZXZlbHNbbGV2ZWxdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGxvZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xvZ0xldmVsID4gTG9nTGV2ZWxzW2xldmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5ERUJVRywgYXJncyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuV0FSTklORywgYXJncyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLm1ha2VFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gRXJyb3JzIGFyZSBiZWluZyBjZW5zb3JlZFxuICAgICAgICBpZiAoX2NlbnNvckVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2VEZXRhaWxzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKFwiY29kZT1cIiArIGNvZGUpO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKFwidmVyc2lvbj1cIiArIHRoaXMudmVyc2lvbik7XG4gICAgICAgIHZhciByZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IHRoaXMubWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLnRocm93QXJndW1lbnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgYXJndW1lbnQ6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUuYXNzZXJ0QXJndW1lbnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrTm9ybWFsaXplID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbm9ybWFsaXplRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgZm9ybTogX25vcm1hbGl6ZUVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5jaGVja1NhZmVVaW50NTMgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwidmFsdWUgbm90IHNhZmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDB4MWZmZmZmZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm91dC1vZi1zYWZlLXJhbmdlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJub24taW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tBcmd1bWVudENvdW50ID0gZnVuY3Rpb24gKGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA8IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPiBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5jaGVja05ldyA9IGZ1bmN0aW9uICh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5jaGVja0Fic3RyYWN0ID0gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MgXCIgKyBKU09OLnN0cmluZ2lmeShraW5kLm5hbWUpICsgXCIgZGlyZWN0bHk7IHVzZSBhIHN1Yi1jbGFzc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiB0YXJnZXQubmFtZSwgb3BlcmF0aW9uOiBcIm5ld1wiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLmdsb2JhbExvZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG4gICAgICAgICAgICBfZ2xvYmFsTG9nZ2VyID0gbmV3IExvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuICAgIH07XG4gICAgTG9nZ2VyLnNldENlbnNvcnNoaXAgPSBmdW5jdGlvbiAoY2Vuc29yc2hpcCwgcGVybWFuZW50KSB7XG4gICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3Blcm1hbmVudENlbnNvckVycm9ycykge1xuICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuICAgICAgICBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gISFwZXJtYW5lbnQ7XG4gICAgfTtcbiAgICBMb2dnZXIuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAobG9nTGV2ZWwpIHtcbiAgICAgICAgdmFyIGxldmVsID0gTG9nTGV2ZWxzW2xvZ0xldmVsLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgbG9nTGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9sb2dMZXZlbCA9IGxldmVsO1xuICAgIH07XG4gICAgTG9nZ2VyLmZyb20gPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICB9O1xuICAgIExvZ2dlci5lcnJvcnMgPSBFcnJvckNvZGU7XG4gICAgTG9nZ2VyLmxldmVscyA9IExvZ0xldmVsO1xuICAgIHJldHVybiBMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib/_version.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/networks/lib/_version.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"networks/5.5.2\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIvX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIvX3ZlcnNpb24uanM/NTgyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbmV4cG9ydHMudmVyc2lvbiA9IFwibmV0d29ya3MvNS41LjJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/networks/lib/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNetwork = void 0;\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    var func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        var providerList = [];\n        if (providers.InfuraProvider) {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider) {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider) {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider) {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            var skip = [\"goerli\", \"ropsten\", \"rinkeby\"];\n            try {\n                var provider = new providers.PocketProvider(network);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider) {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            var quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    var func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nvar homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nvar ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nvar classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nvar networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: { chainId: 137, name: \"matic\" },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: { chainId: 10, name: \"optimism\" },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nfunction getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (var name_1 in networks) {\n            var standard_1 = networks[name_1];\n            if (standard_1.chainId === network) {\n                return {\n                    name: standard_1.name,\n                    chainId: standard_1.chainId,\n                    ensAddress: (standard_1.ensAddress || null),\n                    _defaultProvider: (standard_1._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        var standard_2 = networks[network];\n        if (standard_2 == null) {\n            return null;\n        }\n        return {\n            name: standard_2.name,\n            chainId: standard_2.chainId,\n            ensAddress: standard_2.ensAddress,\n            _defaultProvider: (standard_2._defaultProvider || null)\n        };\n    }\n    var standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    var defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\nexports.getNetwork = getNetwork;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsb0dBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLDRCQUE0QjtBQUN4QyxhQUFhLDZCQUE2QjtBQUMxQyxnQkFBZ0Isa0NBQWtDO0FBQ2xELGdCQUFnQiwrQkFBK0I7QUFDL0Msd0JBQXdCLHFDQUFxQztBQUM3RCx5QkFBeUIsdUNBQXVDO0FBQ2hFLGdCQUFnQixrQ0FBa0M7QUFDbEQsMEJBQTBCLDJDQUEyQztBQUNyRSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi9pbmRleC5qcz9lNzU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXROZXR3b3JrID0gdm9pZCAwO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xuO1xuZnVuY3Rpb24gaXNSZW5ldHdvcmthYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlbmV0d29yaykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yaykge1xuICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3ZpZGVyTGlzdCA9IFtdO1xuICAgICAgICBpZiAocHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5pbmZ1cmEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkV0aGVyc2NhblByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuZXRoZXJzY2FuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYWxjaGVteSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBuZXR3b3JrcyBhcmUgY3VycmVudGx5IGZhdWx0eSBvbiBQb2NrZXQgYXMgdGhlaXJcbiAgICAgICAgICAgIC8vIG5ldHdvcmsgZG9lcyBub3QgaGFuZGxlIHRoZSBCZXJsaW4gaGFyZGZvcmssIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBsaXZlIG9uIHRoZXNlIG9uZXMuXG4gICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBnb2VzIGF3YXkgb25jZSBQb2NrZXQgaGFzIHVwZ3JhZGVkIHRoZWlyIG5vZGVzXG4gICAgICAgICAgICB2YXIgc2tpcCA9IFtcImdvZXJsaVwiLCBcInJvcHN0ZW5cIiwgXCJyaW5rZWJ5XCJdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKG5ldHdvcmspO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5uZXR3b3JrICYmIHNraXAuaW5kZXhPZihwcm92aWRlci5uZXR3b3JrLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlckxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciBxdW9ydW0gPSAxO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVvcnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBxdW9ydW0gPSBvcHRpb25zLnF1b3J1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ldHdvcmsgPT09IFwiaG9tZXN0ZWFkXCIpIHtcbiAgICAgICAgICAgICAgICBxdW9ydW0gPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuRmFsbGJhY2tQcm92aWRlcihwcm92aWRlckxpc3QsIHF1b3J1bSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyTGlzdFswXTtcbiAgICB9O1xuICAgIGZ1bmMucmVuZXR3b3JrID0gZnVuY3Rpb24gKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIGV0aERlZmF1bHRQcm92aWRlcihuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxuZnVuY3Rpb24gZXRjRGVmYXVsdFByb3ZpZGVyKHVybCwgbmV0d29yaykge1xuICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxudmFyIGhvbWVzdGVhZCA9IHtcbiAgICBjaGFpbklkOiAxLFxuICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG4gICAgbmFtZTogXCJob21lc3RlYWRcIixcbiAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJob21lc3RlYWRcIilcbn07XG52YXIgcm9wc3RlbiA9IHtcbiAgICBjaGFpbklkOiAzLFxuICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG4gICAgbmFtZTogXCJyb3BzdGVuXCIsXG4gICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicm9wc3RlblwiKVxufTtcbnZhciBjbGFzc2ljTW9yZG9yID0ge1xuICAgIGNoYWluSWQ6IDYzLFxuICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxufTtcbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG52YXIgbmV0d29ya3MgPSB7XG4gICAgdW5zcGVjaWZpZWQ6IHsgY2hhaW5JZDogMCwgbmFtZTogXCJ1bnNwZWNpZmllZFwiIH0sXG4gICAgaG9tZXN0ZWFkOiBob21lc3RlYWQsXG4gICAgbWFpbm5ldDogaG9tZXN0ZWFkLFxuICAgIG1vcmRlbjogeyBjaGFpbklkOiAyLCBuYW1lOiBcIm1vcmRlblwiIH0sXG4gICAgcm9wc3Rlbjogcm9wc3RlbixcbiAgICB0ZXN0bmV0OiByb3BzdGVuLFxuICAgIHJpbmtlYnk6IHtcbiAgICAgICAgY2hhaW5JZDogNCxcbiAgICAgICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICAgICAgbmFtZTogXCJyaW5rZWJ5XCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJpbmtlYnlcIilcbiAgICB9LFxuICAgIGtvdmFuOiB7XG4gICAgICAgIGNoYWluSWQ6IDQyLFxuICAgICAgICBuYW1lOiBcImtvdmFuXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImtvdmFuXCIpXG4gICAgfSxcbiAgICBnb2VybGk6IHtcbiAgICAgICAgY2hhaW5JZDogNSxcbiAgICAgICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICAgICAgbmFtZTogXCJnb2VybGlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwiZ29lcmxpXCIpXG4gICAgfSxcbiAgICBraW50c3VnaTogeyBjaGFpbklkOiAxMzM3NzAyLCBuYW1lOiBcImtpbnRzdWdpXCIgfSxcbiAgICAvLyBFVEMgKFNlZTogIzM1MSlcbiAgICBjbGFzc2ljOiB7XG4gICAgICAgIGNoYWluSWQ6IDYxLFxuICAgICAgICBuYW1lOiBcImNsYXNzaWNcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2V0Y1wiLCBcImNsYXNzaWNcIilcbiAgICB9LFxuICAgIGNsYXNzaWNNb3JkZW46IHsgY2hhaW5JZDogNjIsIG5hbWU6IFwiY2xhc3NpY01vcmRlblwiIH0sXG4gICAgY2xhc3NpY01vcmRvcjogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljVGVzdG5ldDogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljS290dGk6IHtcbiAgICAgICAgY2hhaW5JZDogNixcbiAgICAgICAgbmFtZTogXCJjbGFzc2ljS290dGlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2tvdHRpXCIsIFwiY2xhc3NpY0tvdHRpXCIpXG4gICAgfSxcbiAgICB4ZGFpOiB7IGNoYWluSWQ6IDEwMCwgbmFtZTogXCJ4ZGFpXCIgfSxcbiAgICBtYXRpYzogeyBjaGFpbklkOiAxMzcsIG5hbWU6IFwibWF0aWNcIiB9LFxuICAgIG1hdGljbXVtOiB7IGNoYWluSWQ6IDgwMDAxLCBuYW1lOiBcIm1hdGljbXVtXCIgfSxcbiAgICBvcHRpbWlzbTogeyBjaGFpbklkOiAxMCwgbmFtZTogXCJvcHRpbWlzbVwiIH0sXG4gICAgXCJvcHRpbWlzbS1rb3ZhblwiOiB7IGNoYWluSWQ6IDY5LCBuYW1lOiBcIm9wdGltaXNtLWtvdmFuXCIgfSxcbiAgICBcIm9wdGltaXNtLWdvZXJsaVwiOiB7IGNoYWluSWQ6IDQyMCwgbmFtZTogXCJvcHRpbWlzbS1nb2VybGlcIiB9LFxuICAgIGFyYml0cnVtOiB7IGNoYWluSWQ6IDQyMTYxLCBuYW1lOiBcImFyYml0cnVtXCIgfSxcbiAgICBcImFyYml0cnVtLXJpbmtlYnlcIjogeyBjaGFpbklkOiA0MjE2MTEsIG5hbWU6IFwiYXJiaXRydW0tcmlua2VieVwiIH0sXG4gICAgYm5iOiB7IGNoYWluSWQ6IDU2LCBuYW1lOiBcImJuYlwiIH0sXG4gICAgYm5idDogeyBjaGFpbklkOiA5NywgbmFtZTogXCJibmJ0XCIgfSxcbn07XG4vKipcbiAqICBnZXROZXR3b3JrXG4gKlxuICogIENvbnZlcnRzIGEgbmFtZWQgY29tbW9uIG5ldHdvcmtzIG9yIGNoYWluIElEIChuZXR3b3JrIElEKSB0byBhIE5ldHdvcmtcbiAqICBhbmQgdmVyaWZpZXMgYSBuZXR3b3JrIGlzIGEgdmFsaWQgTmV0d29yay4uXG4gKi9cbmZ1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yaykge1xuICAgIC8vIE5vIG5ldHdvcmsgKG51bGwpXG4gICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIG5ldHdvcmtzKSB7XG4gICAgICAgICAgICB2YXIgc3RhbmRhcmRfMSA9IG5ldHdvcmtzW25hbWVfMV07XG4gICAgICAgICAgICBpZiAoc3RhbmRhcmRfMS5jaGFpbklkID09PSBuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RhbmRhcmRfMS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZF8xLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIGVuc0FkZHJlc3M6IChzdGFuZGFyZF8xLmVuc0FkZHJlc3MgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IChzdGFuZGFyZF8xLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLFxuICAgICAgICAgICAgbmFtZTogXCJ1bmtub3duXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIHN0YW5kYXJkXzIgPSBuZXR3b3Jrc1tuZXR3b3JrXTtcbiAgICAgICAgaWYgKHN0YW5kYXJkXzIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHN0YW5kYXJkXzIubmFtZSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkXzIuY2hhaW5JZCxcbiAgICAgICAgICAgIGVuc0FkZHJlc3M6IHN0YW5kYXJkXzIuZW5zQWRkcmVzcyxcbiAgICAgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IChzdGFuZGFyZF8yLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0YW5kYXJkID0gbmV0d29ya3NbbmV0d29yay5uYW1lXTtcbiAgICAvLyBOb3QgYSBzdGFuZGFyZCBuZXR3b3JrOyBjaGVjayB0aGF0IGl0IGlzIGEgdmFsaWQgbmV0d29yayBpbiBnZW5lcmFsXG4gICAgaWYgKCFzdGFuZGFyZCkge1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYWluSWQgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgbmV0d29yayBjaGFpbklkIChvciBpcyAwOyBkaXNhYmxlIEVJUC0xNTUpXG4gICAgaWYgKG5ldHdvcmsuY2hhaW5JZCAhPT0gMCAmJiBuZXR3b3JrLmNoYWluSWQgIT09IHN0YW5kYXJkLmNoYWluSWQpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5ldHdvcmsgY2hhaW5JZCBtaXNtYXRjaFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBJbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGFkZCBhbiBhdHRhY2ggZnVuY3Rpb24gdG8gYSBkZWZhdWx0UHJvdmlkZXJcbiAgICAvLyBjbGFzcyBhbmQgbW92ZSB0aGUgX2RlZmF1bHRQcm92aWRlciBpbnRlcm5hbCB0byB0aGlzIGZpbGUgKGV4dGVuZCBOZXR3b3JrKVxuICAgIHZhciBkZWZhdWx0UHJvdmlkZXIgPSBuZXR3b3JrLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbDtcbiAgICBpZiAoZGVmYXVsdFByb3ZpZGVyID09IG51bGwgJiYgc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcikge1xuICAgICAgICBpZiAoaXNSZW5ldHdvcmthYmxlKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyLnJlbmV0d29yayhuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcm92aWRlciA9IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RhbmRhcmQgTmV0d29yayAoYWxsb3cgb3ZlcnJpZGluZyB0aGUgRU5TIGFkZHJlc3MpXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmV0d29yay5uYW1lLFxuICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICBlbnNBZGRyZXNzOiAobmV0d29yay5lbnNBZGRyZXNzIHx8IHN0YW5kYXJkLmVuc0FkZHJlc3MgfHwgbnVsbCksXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGRlZmF1bHRQcm92aWRlclxuICAgIH07XG59XG5leHBvcnRzLmdldE5ldHdvcmsgPSBnZXROZXR3b3JrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/_version.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/properties/lib/_version.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"properties/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliL192ZXJzaW9uLmpzPzExMjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSBcInByb3BlcnRpZXMvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = void 0;\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\nexports.defineReadOnly = defineReadOnly;\n// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor, key) {\n    for (var i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nexports.getStatic = getStatic;\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function () {\n        var promises, results;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    promises = Object.keys(object).map(function (key) {\n                        var value = object[key];\n                        return Promise.resolve(value).then(function (v) { return ({ key: key, value: v }); });\n                    });\n                    return [4 /*yield*/, Promise.all(promises)];\n                case 1:\n                    results = _a.sent();\n                    return [2 /*return*/, results.reduce(function (accum, result) {\n                            accum[(result.key)] = result.value;\n                            return accum;\n                        }, {})];\n            }\n        });\n    });\n}\nexports.resolveProperties = resolveProperties;\nfunction checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach(function (key) {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nexports.checkProperties = checkProperties;\nfunction shallowCopy(object) {\n    var result = {};\n    for (var key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nexports.shallowCopy = shallowCopy;\nvar opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        var keys = Object.keys(object);\n        for (var i = 0; i < keys.length; i++) {\n            var value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(\"Cannot deepCopy \" + typeof (object), \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map(function (item) { return deepCopy(item); }));\n    }\n    if (typeof (object) === \"object\") {\n        var result = {};\n        for (var key in object) {\n            var value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"Cannot deepCopy \" + typeof (object), \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\nexports.deepCopy = deepCopy;\nvar Description = /** @class */ (function () {\n    function Description(info) {\n        for (var key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n    return Description;\n}());\nexports.Description = Description;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsaUJBQWlCLEdBQUcsc0JBQXNCO0FBQy9KLGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsc0dBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVUsb0JBQW9CLElBQUk7QUFDNUcscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliL2luZGV4LmpzP2FkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZXNjcmlwdGlvbiA9IGV4cG9ydHMuZGVlcENvcHkgPSBleHBvcnRzLnNoYWxsb3dDb3B5ID0gZXhwb3J0cy5jaGVja1Byb3BlcnRpZXMgPSBleHBvcnRzLnJlc29sdmVQcm9wZXJ0aWVzID0gZXhwb3J0cy5nZXRTdGF0aWMgPSBleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gdm9pZCAwO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xuZnVuY3Rpb24gZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gZGVmaW5lUmVhZE9ubHk7XG4vLyBDcmF3bCB1cCB0aGUgY29uc3RydWN0b3IgY2hhaW4gdG8gZmluZCBhIHN0YXRpYyBtZXRob2RcbmZ1bmN0aW9uIGdldFN0YXRpYyhjdG9yLCBrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgaWYgKGN0b3Jba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0b3Jba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN0b3IucHJvdG90eXBlIHx8IHR5cGVvZiAoY3Rvci5wcm90b3R5cGUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmdldFN0YXRpYyA9IGdldFN0YXRpYztcbmZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb21pc2VzLCByZXN1bHRzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbHVlOiB2IH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHByb21pc2VzKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVsocmVzdWx0LmtleSldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IHJlc29sdmVQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gY2hlY2tQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiAob2JqZWN0KSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3RcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdCBrZXkgLSBcIiArIGtleSwgXCJ0cmFuc2FjdGlvbjpcIiArIGtleSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5jaGVja1Byb3BlcnRpZXMgPSBjaGVja1Byb3BlcnRpZXM7XG5mdW5jdGlvbiBzaGFsbG93Q29weShvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zaGFsbG93Q29weSA9IHNoYWxsb3dDb3B5O1xudmFyIG9wYXF1ZSA9IHsgYmlnaW50OiB0cnVlLCBib29sZWFuOiB0cnVlLCBcImZ1bmN0aW9uXCI6IHRydWUsIG51bWJlcjogdHJ1ZSwgc3RyaW5nOiB0cnVlIH07XG5mdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KSB7XG4gICAgLy8gT3BhcXVlIG9iamVjdHMgYXJlIG5vdCBtdXRhYmxlLCBzbyBzYWZlIHRvIGNvcHkgYnkgYXNzaWdubWVudFxuICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwgfHwgb3BhcXVlW3R5cGVvZiAob2JqZWN0KV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgdHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhY2Nlc3NpbmcgYSB2YWx1ZSB0cmlnZ2VycyBhbiBlcnJvciwgaXQgaXMgYSBnZXR0ZXJcbiAgICAgICAgICAgICAgICAvLyBkZXNpZ25lZCB0byBkbyBzbyAoZS5nLiBSZXN1bHQpIGFuZCBpcyB0aGVyZWZvcmUgXCJmcm96ZW5cIlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfaXNGcm96ZW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIkNhbm5vdCBkZWVwQ29weSBcIiArIHR5cGVvZiAob2JqZWN0KSwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbi8vIFJldHVybnMgYSBuZXcgY29weSBvZiBvYmplY3QsIHN1Y2ggdGhhdCBubyBwcm9wZXJ0aWVzIG1heSBiZSByZXBsYWNlZC5cbi8vIE5ldyBwcm9wZXJ0aWVzIG1heSBiZSBhZGRlZCBvbmx5IHRvIG9iamVjdHMuXG5mdW5jdGlvbiBfZGVlcENvcHkob2JqZWN0KSB7XG4gICAgaWYgKF9pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIC8vIEFycmF5cyBhcmUgbXV0YWJsZSwgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBjb3B5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBkZWVwQ29weShpdGVtKTsgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkocmVzdWx0LCBrZXksIGRlZXBDb3B5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJDYW5ub3QgZGVlcENvcHkgXCIgKyB0eXBlb2YgKG9iamVjdCksIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG5mdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcbiAgICByZXR1cm4gX2RlZXBDb3B5KG9iamVjdCk7XG59XG5leHBvcnRzLmRlZXBDb3B5ID0gZGVlcENvcHk7XG52YXIgRGVzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVzY3JpcHRpb24oaW5mbykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENvcHkoaW5mb1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRGVzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5EZXNjcmlwdGlvbiA9IERlc2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"providers/5.5.2\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9fdmVyc2lvbi5qcz8zMWNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJwcm92aWRlcnMvNS41LjJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/alchemy-provider.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/alchemy-provider.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlchemyProvider = exports.AlchemyWebSocketProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar websocket_provider_1 = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/websocket-provider.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nvar defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nvar AlchemyWebSocketProvider = /** @class */ (function (_super) {\n    __extends(AlchemyWebSocketProvider, _super);\n    function AlchemyWebSocketProvider(network, apiKey) {\n        var _this = this;\n        var provider = new AlchemyProvider(network, apiKey);\n        var url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        _this = _super.call(this, url, provider.network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"apiKey\", provider.apiKey);\n        return _this;\n    }\n    AlchemyWebSocketProvider.prototype.isCommunityResource = function () {\n        return (this.apiKey === defaultApiKey);\n    };\n    return AlchemyWebSocketProvider;\n}(websocket_provider_1.WebSocketProvider));\nexports.AlchemyWebSocketProvider = AlchemyWebSocketProvider;\nvar AlchemyProvider = /** @class */ (function (_super) {\n    __extends(AlchemyProvider, _super);\n    function AlchemyProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AlchemyProvider.getWebSocketProvider = function (network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    };\n    AlchemyProvider.getApiKey = function (apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    };\n    AlchemyProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: function (attempt, url) {\n                if (apiKey === defaultApiKey) {\n                    (0, formatter_1.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    };\n    AlchemyProvider.prototype.isCommunityResource = function () {\n        return (this.apiKey === defaultApiKey);\n    };\n    return AlchemyProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.AlchemyProvider = AlchemyProvider;\n//# sourceMappingURL=alchemy-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2FsY2hlbXktcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsZ0NBQWdDO0FBQzFELG1CQUFtQixtQkFBTyxDQUFDLGtIQUEyQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBYTtBQUN2QywyQkFBMkIsbUJBQU8sQ0FBQyx5SEFBc0I7QUFDekQsZUFBZSxtQkFBTyxDQUFDLDBHQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxxR0FBWTtBQUNyQztBQUNBLDhCQUE4QixtQkFBTyxDQUFDLCtIQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2FsY2hlbXktcHJvdmlkZXIuanM/ZDkyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IGV4cG9ydHMuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIGZvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vZm9ybWF0dGVyXCIpO1xudmFyIHdlYnNvY2tldF9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vd2Vic29ja2V0LXByb3ZpZGVyXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIHVybF9qc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCIpO1xuLy8gVGhpcyBrZXkgd2FzIHByb3ZpZGVkIHRvIGV0aGVycy5qcyBieSBBbGNoZW15IHRvIGJlIHVzZWQgYnkgdGhlXG4vLyBkZWZhdWx0IHByb3ZpZGVyLCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCBmb3IgeW91ciBvd25cbi8vIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLCB0aGF0IHlvdSBhY3F1aXJlIHlvdXIgb3duIEFQSSBrZXkgYXQ6XG4vLyAgIGh0dHBzOi8vZGFzaGJvYXJkLmFsY2hlbXlhcGkuaW9cbnZhciBkZWZhdWx0QXBpS2V5ID0gXCJfZ2c3d1NTaTBLTUJzZEtuR1ZmSER1ZXE2eE1COUVrQ1wiO1xudmFyIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICB2YXIgdXJsID0gcHJvdmlkZXIuY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCIuYWxjaGVteWFwaS5cIiwgXCIud3MuYWxjaGVteWFwaS5cIik7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdXJsLCBwcm92aWRlci5uZXR3b3JrKSB8fCB0aGlzO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhcGlLZXlcIiwgcHJvdmlkZXIuYXBpS2V5KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcjtcbn0od2Vic29ja2V0X3Byb3ZpZGVyXzEuV2ViU29ja2V0UHJvdmlkZXIpKTtcbmV4cG9ydHMuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyID0gQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyO1xudmFyIEFsY2hlbXlQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxjaGVteVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFsY2hlbXlQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBbGNoZW15UHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG4gICAgfTtcbiAgICBBbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QXBpS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpS2V5O1xuICAgIH07XG4gICAgQWxjaGVteVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1tYWlubmV0LmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yb3BzdGVuLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yaW5rZWJ5LmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWdvZXJsaS5hbGNoZW15YXBpLmlvL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWtvdmFuLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY211bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbXVtYmFpLmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmItbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLXJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmItcmlua2VieS5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwib3B0LW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1rb3ZhblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdC1rb3Zhbi5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBhcGlLZXkpLFxuICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGZvcm1hdHRlcl8xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBbGNoZW15UHJvdmlkZXIucHJvdG90eXBlLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFsY2hlbXlQcm92aWRlcjtcbn0odXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IEFsY2hlbXlQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsY2hlbXktcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/alchemy-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/base-provider.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/base-provider.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseProvider = exports.Resolver = exports.Event = void 0;\nvar abstract_provider_1 = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/index.js\");\nvar basex_1 = __webpack_require__(/*! @ethersproject/basex */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/basex/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar constants_1 = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js\");\nvar hash_1 = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/index.js\");\nvar networks_1 = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar sha2_1 = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js\");\nvar bech32_1 = __importDefault(__webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/bech32/index.js\"));\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js\");\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if ((0, bytes_1.hexDataLength)(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map(function (topic) {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            var unique_1 = {};\n            topic.forEach(function (topic) {\n                unique_1[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            var sorted = Object.keys(unique_1);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map(function (topic) {\n        if (topic === \"\") {\n            return [];\n        }\n        var comps = topic.split(\"|\").map(function (topic) {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if ((0, bytes_1.hexDataLength)(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (abstract_provider_1.ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nvar PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nvar Event = /** @class */ (function () {\n    function Event(tag, listener, once) {\n        (0, properties_1.defineReadOnly)(this, \"tag\", tag);\n        (0, properties_1.defineReadOnly)(this, \"listener\", listener);\n        (0, properties_1.defineReadOnly)(this, \"once\", once);\n    }\n    Object.defineProperty(Event.prototype, \"event\", {\n        get: function () {\n            switch (this.type) {\n                case \"tx\":\n                    return this.hash;\n                case \"filter\":\n                    return this.filter;\n            }\n            return this.tag;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Event.prototype, \"type\", {\n        get: function () {\n            return this.tag.split(\":\")[0];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Event.prototype, \"hash\", {\n        get: function () {\n            var comps = this.tag.split(\":\");\n            if (comps[0] !== \"tx\") {\n                return null;\n            }\n            return comps[1];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Event.prototype, \"filter\", {\n        get: function () {\n            var comps = this.tag.split(\":\");\n            if (comps[0] !== \"filter\") {\n                return null;\n            }\n            var address = comps[1];\n            var topics = deserializeTopics(comps[2]);\n            var filter = {};\n            if (topics.length > 0) {\n                filter.topics = topics;\n            }\n            if (address && address !== \"*\") {\n                filter.address = address;\n            }\n            return filter;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Event.prototype.pollable = function () {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    };\n    return Event;\n}());\nexports.Event = Event;\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nvar coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));\n}\nvar matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nvar matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result) {\n    try {\n        return (0, strings_1.toUtf8String)(_parseBytes(result));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result) {\n    if (result === \"0x\") {\n        return null;\n    }\n    var offset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, 0, 32)).toNumber();\n    var length = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, offset, offset + 32)).toNumber();\n    return (0, bytes_1.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    return \"https://gateway.ipfs.io/ipfs/\" + link.substring(7);\n}\nvar Resolver = /** @class */ (function () {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    function Resolver(provider, address, name, resolvedAddress) {\n        (0, properties_1.defineReadOnly)(this, \"provider\", provider);\n        (0, properties_1.defineReadOnly)(this, \"name\", name);\n        (0, properties_1.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n        (0, properties_1.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    Resolver.prototype._fetchBytes = function (selector, parameters) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, _a, error_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        tx = {\n                            to: this.address,\n                            data: (0, bytes_1.hexConcat)([selector, (0, hash_1.namehash)(this.name), (parameters || \"0x\")])\n                        };\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 3, , 4]);\n                        _a = _parseBytes;\n                        return [4 /*yield*/, this.provider.call(tx)];\n                    case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n                    case 3:\n                        error_1 = _b.sent();\n                        if (error_1.code === logger_1.Logger.errors.CALL_EXCEPTION) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, null];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Resolver.prototype._getAddress = function (coinType, hexBytes) {\n        var coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(\"unsupported coin type: \" + coinType, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getAddress(\" + coinType + \")\"\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        var bytes = (0, bytes_1.arrayify)(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                var length_1 = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length_1 * 2 && length_1 >= 1 && length_1 <= 75) {\n                    return base58Encode((0, bytes_1.concat)([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                var length_2 = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length_2 * 2 && length_2 >= 1 && length_2 <= 75) {\n                    return base58Encode((0, bytes_1.concat)([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            var length_3 = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            var version_1 = bytes[0];\n            if (version_1 === 0x00) {\n                if (length_3 !== 20 && length_3 !== 32) {\n                    version_1 = -1;\n                }\n            }\n            else {\n                version_1 = -1;\n            }\n            if (version_1 >= 0 && bytes.length === 2 + length_3 && length_3 >= 1 && length_3 <= 75) {\n                var words = bech32_1.default.toWords(bytes.slice(2));\n                words.unshift(version_1);\n                return bech32_1.default.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    };\n    Resolver.prototype.getAddress = function (coinType) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transaction, hexBytes_1, error_2, hexBytes, address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (coinType == null) {\n                            coinType = 60;\n                        }\n                        if (!(coinType === 60)) return [3 /*break*/, 4];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        transaction = {\n                            to: this.address,\n                            data: (\"0x3b3b57de\" + (0, hash_1.namehash)(this.name).substring(2))\n                        };\n                        return [4 /*yield*/, this.provider.call(transaction)];\n                    case 2:\n                        hexBytes_1 = _a.sent();\n                        // No address\n                        if (hexBytes_1 === \"0x\" || hexBytes_1 === constants_1.HashZero) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, this.provider.formatter.callAddress(hexBytes_1)];\n                    case 3:\n                        error_2 = _a.sent();\n                        if (error_2.code === logger_1.Logger.errors.CALL_EXCEPTION) {\n                            return [2 /*return*/, null];\n                        }\n                        throw error_2;\n                    case 4: return [4 /*yield*/, this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType))];\n                    case 5:\n                        hexBytes = _a.sent();\n                        // No address\n                        if (hexBytes == null || hexBytes === \"0x\") {\n                            return [2 /*return*/, null];\n                        }\n                        address = this._getAddress(coinType, hexBytes);\n                        if (address == null) {\n                            logger.throwError(\"invalid or unsupported coin data\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"getAddress(\" + coinType + \")\",\n                                coinType: coinType,\n                                data: hexBytes\n                            });\n                        }\n                        return [2 /*return*/, address];\n                }\n            });\n        });\n    };\n    Resolver.prototype.getAvatar = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var linkage, avatar, i, match, scheme, _a, selector, owner, _b, comps, addr, tokenId, tokenOwner, _c, _d, balance, _e, _f, tx, metadataUrl, _g, metadata, imageUrl, ipfs, error_3;\n            return __generator(this, function (_h) {\n                switch (_h.label) {\n                    case 0:\n                        linkage = [{ type: \"name\", content: this.name }];\n                        _h.label = 1;\n                    case 1:\n                        _h.trys.push([1, 19, , 20]);\n                        return [4 /*yield*/, this.getText(\"avatar\")];\n                    case 2:\n                        avatar = _h.sent();\n                        if (avatar == null) {\n                            return [2 /*return*/, null];\n                        }\n                        i = 0;\n                        _h.label = 3;\n                    case 3:\n                        if (!(i < matchers.length)) return [3 /*break*/, 18];\n                        match = avatar.match(matchers[i]);\n                        if (match == null) {\n                            return [3 /*break*/, 17];\n                        }\n                        scheme = match[1].toLowerCase();\n                        _a = scheme;\n                        switch (_a) {\n                            case \"https\": return [3 /*break*/, 4];\n                            case \"data\": return [3 /*break*/, 5];\n                            case \"ipfs\": return [3 /*break*/, 6];\n                            case \"erc721\": return [3 /*break*/, 7];\n                            case \"erc1155\": return [3 /*break*/, 7];\n                        }\n                        return [3 /*break*/, 17];\n                    case 4:\n                        linkage.push({ type: \"url\", content: avatar });\n                        return [2 /*return*/, { linkage: linkage, url: avatar }];\n                    case 5:\n                        linkage.push({ type: \"data\", content: avatar });\n                        return [2 /*return*/, { linkage: linkage, url: avatar }];\n                    case 6:\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return [2 /*return*/, { linkage: linkage, url: getIpfsLink(avatar) }];\n                    case 7:\n                        selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n                        _b = this._resolvedAddress;\n                        if (_b) return [3 /*break*/, 9];\n                        return [4 /*yield*/, this.getAddress()];\n                    case 8:\n                        _b = (_h.sent());\n                        _h.label = 9;\n                    case 9:\n                        owner = (_b);\n                        comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, this.provider.formatter.address(comps[0])];\n                    case 10:\n                        addr = _h.sent();\n                        tokenId = (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(comps[1]).toHexString(), 32);\n                        if (!(scheme === \"erc721\")) return [3 /*break*/, 12];\n                        _d = (_c = this.provider.formatter).callAddress;\n                        return [4 /*yield*/, this.provider.call({\n                                to: addr, data: (0, bytes_1.hexConcat)([\"0x6352211e\", tokenId])\n                            })];\n                    case 11:\n                        tokenOwner = _d.apply(_c, [_h.sent()]);\n                        if (owner !== tokenOwner) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"owner\", content: tokenOwner });\n                        return [3 /*break*/, 14];\n                    case 12:\n                        if (!(scheme === \"erc1155\")) return [3 /*break*/, 14];\n                        _f = (_e = bignumber_1.BigNumber).from;\n                        return [4 /*yield*/, this.provider.call({\n                                to: addr, data: (0, bytes_1.hexConcat)([\"0x00fdd58e\", (0, bytes_1.hexZeroPad)(owner, 32), tokenId])\n                            })];\n                    case 13:\n                        balance = _f.apply(_e, [_h.sent()]);\n                        if (balance.isZero()) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"balance\", content: balance.toString() });\n                        _h.label = 14;\n                    case 14:\n                        tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: (0, bytes_1.hexConcat)([selector, tokenId])\n                        };\n                        _g = _parseString;\n                        return [4 /*yield*/, this.provider.call(tx)];\n                    case 15:\n                        metadataUrl = _g.apply(void 0, [_h.sent()]);\n                        if (metadataUrl == null) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n                        return [4 /*yield*/, (0, web_1.fetchJson)(metadataUrl)];\n                    case 16:\n                        metadata = _h.sent();\n                        if (!metadata) {\n                            return [2 /*return*/, null];\n                        }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                        imageUrl = metadata.image;\n                        if (typeof (imageUrl) !== \"string\") {\n                            return [2 /*return*/, null];\n                        }\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        }\n                        else {\n                            ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                return [2 /*return*/, null];\n                            }\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n                        linkage.push({ type: \"url\", content: imageUrl });\n                        return [2 /*return*/, { linkage: linkage, url: imageUrl }];\n                    case 17:\n                        i++;\n                        return [3 /*break*/, 3];\n                    case 18: return [3 /*break*/, 20];\n                    case 19:\n                        error_3 = _h.sent();\n                        return [3 /*break*/, 20];\n                    case 20: return [2 /*return*/, null];\n                }\n            });\n        });\n    };\n    Resolver.prototype.getContentHash = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var hexBytes, ipfs, length_4, swarm;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._fetchBytes(\"0xbc1c58d1\")];\n                    case 1:\n                        hexBytes = _a.sent();\n                        // No contenthash\n                        if (hexBytes == null || hexBytes === \"0x\") {\n                            return [2 /*return*/, null];\n                        }\n                        ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n                        if (ipfs) {\n                            length_4 = parseInt(ipfs[3], 16);\n                            if (ipfs[4].length === length_4 * 2) {\n                                return [2 /*return*/, \"ipfs:/\\/\" + basex_1.Base58.encode(\"0x\" + ipfs[1])];\n                            }\n                        }\n                        swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n                        if (swarm) {\n                            if (swarm[1].length === (32 * 2)) {\n                                return [2 /*return*/, \"bzz:/\\/\" + swarm[1]];\n                            }\n                        }\n                        return [2 /*return*/, logger.throwError(\"invalid or unsupported content hash data\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"getContentHash()\",\n                                data: hexBytes\n                            })];\n                }\n            });\n        });\n    };\n    Resolver.prototype.getText = function (key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var keyBytes, hexBytes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        keyBytes = (0, strings_1.toUtf8Bytes)(key);\n                        // The nodehash consumes the first slot, so the string pointer targets\n                        // offset 64, with the length at offset 64 and data starting at offset 96\n                        keyBytes = (0, bytes_1.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n                        // Pad to word-size (32 bytes)\n                        if ((keyBytes.length % 32) !== 0) {\n                            keyBytes = (0, bytes_1.concat)([keyBytes, (0, bytes_1.hexZeroPad)(\"0x\", 32 - (key.length % 32))]);\n                        }\n                        return [4 /*yield*/, this._fetchBytes(\"0x59d1d43c\", (0, bytes_1.hexlify)(keyBytes))];\n                    case 1:\n                        hexBytes = _a.sent();\n                        if (hexBytes == null || hexBytes === \"0x\") {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, (0, strings_1.toUtf8String)(hexBytes)];\n                }\n            });\n        });\n    };\n    return Resolver;\n}());\nexports.Resolver = Resolver;\nvar defaultFormatter = null;\nvar nextPollId = 1;\nvar BaseProvider = /** @class */ (function (_super) {\n    __extends(BaseProvider, _super);\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    function BaseProvider(network) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, abstract_provider_1.Provider);\n        _this = _super.call(this) || this;\n        // Events being listened to\n        _this._events = [];\n        _this._emitted = { block: -2 };\n        _this.formatter = _newTarget.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        (0, properties_1.defineReadOnly)(_this, \"anyNetwork\", (network === \"any\"));\n        if (_this.anyNetwork) {\n            network = _this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            _this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch(function (error) { });\n            // Trigger initial network setting (async)\n            _this._ready().catch(function (error) { });\n        }\n        else {\n            var knownNetwork = (0, properties_1.getStatic)(_newTarget, \"getNetwork\")(network);\n            if (knownNetwork) {\n                (0, properties_1.defineReadOnly)(_this, \"_network\", knownNetwork);\n                _this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        _this._maxInternalBlockNumber = -1024;\n        _this._lastBlockNumber = -2;\n        _this._pollingInterval = 4000;\n        _this._fastQueryDate = 0;\n        return _this;\n    }\n    BaseProvider.prototype._ready = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var network, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this._network == null)) return [3 /*break*/, 7];\n                        network = null;\n                        if (!this._networkPromise) return [3 /*break*/, 4];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._networkPromise];\n                    case 2:\n                        network = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        error_4 = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 4:\n                        if (!(network == null)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.detectNetwork()];\n                    case 5:\n                        network = _a.sent();\n                        _a.label = 6;\n                    case 6:\n                        // This should never happen; every Provider sub-class should have\n                        // suggested a network by here (or have thrown).\n                        if (!network) {\n                            logger.throwError(\"no network detected\", logger_1.Logger.errors.UNKNOWN_ERROR, {});\n                        }\n                        // Possible this call stacked so do not call defineReadOnly again\n                        if (this._network == null) {\n                            if (this.anyNetwork) {\n                                this._network = network;\n                            }\n                            else {\n                                (0, properties_1.defineReadOnly)(this, \"_network\", network);\n                            }\n                            this.emit(\"network\", network, null);\n                        }\n                        _a.label = 7;\n                    case 7: return [2 /*return*/, this._network];\n                }\n            });\n        });\n    };\n    Object.defineProperty(BaseProvider.prototype, \"ready\", {\n        // This will always return the most recently established network.\n        // For \"any\", this can change (a \"network\" event is emitted before\n        // any change is reflected); otherwise this cannot change\n        get: function () {\n            var _this = this;\n            return (0, web_1.poll)(function () {\n                return _this._ready().then(function (network) {\n                    return network;\n                }, function (error) {\n                    // If the network isn't running yet, we will wait\n                    if (error.code === logger_1.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                        return undefined;\n                    }\n                    throw error;\n                });\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // @TODO: Remove this and just create a singleton formatter\n    BaseProvider.getFormatter = function () {\n        if (defaultFormatter == null) {\n            defaultFormatter = new formatter_1.Formatter();\n        }\n        return defaultFormatter;\n    };\n    // @TODO: Remove this and just use getNetwork\n    BaseProvider.getNetwork = function (network) {\n        return (0, networks_1.getNetwork)((network == null) ? \"homestead\" : network);\n    };\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    BaseProvider.prototype._getInternalBlockNumber = function (maxAge) {\n        return __awaiter(this, void 0, void 0, function () {\n            var internalBlockNumber, result, error_5, reqTime, checkInternalBlockNumber;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._ready()];\n                    case 1:\n                        _a.sent();\n                        if (!(maxAge > 0)) return [3 /*break*/, 7];\n                        _a.label = 2;\n                    case 2:\n                        if (!this._internalBlockNumber) return [3 /*break*/, 7];\n                        internalBlockNumber = this._internalBlockNumber;\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, internalBlockNumber];\n                    case 4:\n                        result = _a.sent();\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return [2 /*return*/, result.blockNumber];\n                        }\n                        // Too old; fetch a new value\n                        return [3 /*break*/, 7];\n                    case 5:\n                        error_5 = _a.sent();\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            return [3 /*break*/, 7];\n                        }\n                        return [3 /*break*/, 6];\n                    case 6: return [3 /*break*/, 2];\n                    case 7:\n                        reqTime = getTime();\n                        checkInternalBlockNumber = (0, properties_1.resolveProperties)({\n                            blockNumber: this.perform(\"getBlockNumber\", {}),\n                            networkError: this.getNetwork().then(function (network) { return (null); }, function (error) { return (error); })\n                        }).then(function (_a) {\n                            var blockNumber = _a.blockNumber, networkError = _a.networkError;\n                            if (networkError) {\n                                // Unremember this bad internal block number\n                                if (_this._internalBlockNumber === checkInternalBlockNumber) {\n                                    _this._internalBlockNumber = null;\n                                }\n                                throw networkError;\n                            }\n                            var respTime = getTime();\n                            blockNumber = bignumber_1.BigNumber.from(blockNumber).toNumber();\n                            if (blockNumber < _this._maxInternalBlockNumber) {\n                                blockNumber = _this._maxInternalBlockNumber;\n                            }\n                            _this._maxInternalBlockNumber = blockNumber;\n                            _this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                            return { blockNumber: blockNumber, reqTime: reqTime, respTime: respTime };\n                        });\n                        this._internalBlockNumber = checkInternalBlockNumber;\n                        // Swallow unhandled exceptions; if needed they are handled else where\n                        checkInternalBlockNumber.catch(function (error) {\n                            // Don't null the dead (rejected) fetch, if it has already been updated\n                            if (_this._internalBlockNumber === checkInternalBlockNumber) {\n                                _this._internalBlockNumber = null;\n                            }\n                        });\n                        return [4 /*yield*/, checkInternalBlockNumber];\n                    case 8: return [2 /*return*/, (_a.sent()).blockNumber];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.poll = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var pollId, runners, blockNumber, error_6, i;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        pollId = nextPollId++;\n                        runners = [];\n                        blockNumber = null;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];\n                    case 2:\n                        blockNumber = _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        error_6 = _a.sent();\n                        this.emit(\"error\", error_6);\n                        return [2 /*return*/];\n                    case 4:\n                        this._setFastBlockNumber(blockNumber);\n                        // Emit a poll event after we have the latest (fast) block number\n                        this.emit(\"poll\", pollId, blockNumber);\n                        // If the block has not changed, meh.\n                        if (blockNumber === this._lastBlockNumber) {\n                            this.emit(\"didPoll\", pollId);\n                            return [2 /*return*/];\n                        }\n                        // First polling cycle, trigger a \"block\" events\n                        if (this._emitted.block === -2) {\n                            this._emitted.block = blockNumber - 1;\n                        }\n                        if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                            logger.warn(\"network block skew detected; skipping block events (emitted=\" + this._emitted.block + \" blockNumber\" + blockNumber + \")\");\n                            this.emit(\"error\", logger.makeError(\"network block skew detected\", logger_1.Logger.errors.NETWORK_ERROR, {\n                                blockNumber: blockNumber,\n                                event: \"blockSkew\",\n                                previousBlockNumber: this._emitted.block\n                            }));\n                            this.emit(\"block\", blockNumber);\n                        }\n                        else {\n                            // Notify all listener for each block that has passed\n                            for (i = this._emitted.block + 1; i <= blockNumber; i++) {\n                                this.emit(\"block\", i);\n                            }\n                        }\n                        // The emitted block was updated, check for obsolete events\n                        if (this._emitted.block !== blockNumber) {\n                            this._emitted.block = blockNumber;\n                            Object.keys(this._emitted).forEach(function (key) {\n                                // The block event does not expire\n                                if (key === \"block\") {\n                                    return;\n                                }\n                                // The block we were at when we emitted this event\n                                var eventBlockNumber = _this._emitted[key];\n                                // We cannot garbage collect pending transactions or blocks here\n                                // They should be garbage collected by the Provider when setting\n                                // \"pending\" events\n                                if (eventBlockNumber === \"pending\") {\n                                    return;\n                                }\n                                // Evict any transaction hashes or block hashes over 12 blocks\n                                // old, since they should not return null anyways\n                                if (blockNumber - eventBlockNumber > 12) {\n                                    delete _this._emitted[key];\n                                }\n                            });\n                        }\n                        // First polling cycle\n                        if (this._lastBlockNumber === -2) {\n                            this._lastBlockNumber = blockNumber - 1;\n                        }\n                        // Find all transaction hashes we are waiting on\n                        this._events.forEach(function (event) {\n                            switch (event.type) {\n                                case \"tx\": {\n                                    var hash_2 = event.hash;\n                                    var runner = _this.getTransactionReceipt(hash_2).then(function (receipt) {\n                                        if (!receipt || receipt.blockNumber == null) {\n                                            return null;\n                                        }\n                                        _this._emitted[\"t:\" + hash_2] = receipt.blockNumber;\n                                        _this.emit(hash_2, receipt);\n                                        return null;\n                                    }).catch(function (error) { _this.emit(\"error\", error); });\n                                    runners.push(runner);\n                                    break;\n                                }\n                                case \"filter\": {\n                                    var filter_1 = event.filter;\n                                    filter_1.fromBlock = _this._lastBlockNumber + 1;\n                                    filter_1.toBlock = blockNumber;\n                                    var runner = _this.getLogs(filter_1).then(function (logs) {\n                                        if (logs.length === 0) {\n                                            return;\n                                        }\n                                        logs.forEach(function (log) {\n                                            _this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                            _this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                            _this.emit(filter_1, log);\n                                        });\n                                    }).catch(function (error) { _this.emit(\"error\", error); });\n                                    runners.push(runner);\n                                    break;\n                                }\n                            }\n                        });\n                        this._lastBlockNumber = blockNumber;\n                        // Once all events for this loop have been processed, emit \"didPoll\"\n                        Promise.all(runners).then(function () {\n                            _this.emit(\"didPoll\", pollId);\n                        }).catch(function (error) { _this.emit(\"error\", error); });\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // Deprecated; do not use this\n    BaseProvider.prototype.resetEventsBlock = function (blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    };\n    Object.defineProperty(BaseProvider.prototype, \"network\", {\n        get: function () {\n            return this._network;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    BaseProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, logger.throwError(\"provider does not support network detection\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"provider.detectNetwork\"\n                    })];\n            });\n        });\n    };\n    BaseProvider.prototype.getNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var network, currentNetwork, error;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._ready()];\n                    case 1:\n                        network = _a.sent();\n                        return [4 /*yield*/, this.detectNetwork()];\n                    case 2:\n                        currentNetwork = _a.sent();\n                        if (!(network.chainId !== currentNetwork.chainId)) return [3 /*break*/, 5];\n                        if (!this.anyNetwork) return [3 /*break*/, 4];\n                        this._network = currentNetwork;\n                        // Reset all internal block number guards and caches\n                        this._lastBlockNumber = -2;\n                        this._fastBlockNumber = null;\n                        this._fastBlockNumberPromise = null;\n                        this._fastQueryDate = 0;\n                        this._emitted.block = -2;\n                        this._maxInternalBlockNumber = -1024;\n                        this._internalBlockNumber = null;\n                        // The \"network\" event MUST happen before this method resolves\n                        // so any events have a chance to unregister, so we stall an\n                        // additional event loop before returning from /this/ call\n                        this.emit(\"network\", currentNetwork, network);\n                        return [4 /*yield*/, stall(0)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, this._network];\n                    case 4:\n                        error = logger.makeError(\"underlying network changed\", logger_1.Logger.errors.NETWORK_ERROR, {\n                            event: \"changed\",\n                            network: network,\n                            detectedNetwork: currentNetwork\n                        });\n                        this.emit(\"error\", error);\n                        throw error;\n                    case 5: return [2 /*return*/, network];\n                }\n            });\n        });\n    };\n    Object.defineProperty(BaseProvider.prototype, \"blockNumber\", {\n        get: function () {\n            var _this = this;\n            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function (blockNumber) {\n                _this._setFastBlockNumber(blockNumber);\n            }, function (error) { });\n            return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseProvider.prototype, \"polling\", {\n        get: function () {\n            return (this._poller != null);\n        },\n        set: function (value) {\n            var _this = this;\n            if (value && !this._poller) {\n                this._poller = setInterval(function () { _this.poll(); }, this.pollingInterval);\n                if (!this._bootstrapPoll) {\n                    this._bootstrapPoll = setTimeout(function () {\n                        _this.poll();\n                        // We block additional polls until the polling interval\n                        // is done, to prevent overwhelming the poll function\n                        _this._bootstrapPoll = setTimeout(function () {\n                            // If polling was disabled, something may require a poke\n                            // since starting the bootstrap poll and it was disabled\n                            if (!_this._poller) {\n                                _this.poll();\n                            }\n                            // Clear out the bootstrap so we can do another\n                            _this._bootstrapPoll = null;\n                        }, _this.pollingInterval);\n                    }, 0);\n                }\n            }\n            else if (!value && this._poller) {\n                clearInterval(this._poller);\n                this._poller = null;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseProvider.prototype, \"pollingInterval\", {\n        get: function () {\n            return this._pollingInterval;\n        },\n        set: function (value) {\n            var _this = this;\n            if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n                throw new Error(\"invalid polling interval\");\n            }\n            this._pollingInterval = value;\n            if (this._poller) {\n                clearInterval(this._poller);\n                this._poller = setInterval(function () { _this.poll(); }, this._pollingInterval);\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BaseProvider.prototype._getFastBlockNumber = function () {\n        var _this = this;\n        var now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then(function (blockNumber) {\n                if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {\n                    _this._fastBlockNumber = blockNumber;\n                }\n                return _this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    };\n    BaseProvider.prototype._setFastBlockNumber = function (blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    };\n    BaseProvider.prototype.waitForTransaction = function (transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null)];\n            });\n        });\n    };\n    BaseProvider.prototype._waitForTransaction = function (transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function () {\n            var receipt;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];\n                    case 1:\n                        receipt = _a.sent();\n                        // Receipt is already good\n                        if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                            return [2 /*return*/, receipt];\n                        }\n                        // Poll until the receipt is good...\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                var cancelFuncs = [];\n                                var done = false;\n                                var alreadyDone = function () {\n                                    if (done) {\n                                        return true;\n                                    }\n                                    done = true;\n                                    cancelFuncs.forEach(function (func) { func(); });\n                                    return false;\n                                };\n                                var minedHandler = function (receipt) {\n                                    if (receipt.confirmations < confirmations) {\n                                        return;\n                                    }\n                                    if (alreadyDone()) {\n                                        return;\n                                    }\n                                    resolve(receipt);\n                                };\n                                _this.on(transactionHash, minedHandler);\n                                cancelFuncs.push(function () { _this.removeListener(transactionHash, minedHandler); });\n                                if (replaceable) {\n                                    var lastBlockNumber_1 = replaceable.startBlock;\n                                    var scannedBlock_1 = null;\n                                    var replaceHandler_1 = function (blockNumber) { return __awaiter(_this, void 0, void 0, function () {\n                                        var _this = this;\n                                        return __generator(this, function (_a) {\n                                            switch (_a.label) {\n                                                case 0:\n                                                    if (done) {\n                                                        return [2 /*return*/];\n                                                    }\n                                                    // Wait 1 second; this is only used in the case of a fault, so\n                                                    // we will trade off a little bit of latency for more consistent\n                                                    // results and fewer JSON-RPC calls\n                                                    return [4 /*yield*/, stall(1000)];\n                                                case 1:\n                                                    // Wait 1 second; this is only used in the case of a fault, so\n                                                    // we will trade off a little bit of latency for more consistent\n                                                    // results and fewer JSON-RPC calls\n                                                    _a.sent();\n                                                    this.getTransactionCount(replaceable.from).then(function (nonce) { return __awaiter(_this, void 0, void 0, function () {\n                                                        var mined, block, ti, tx, receipt_1, reason;\n                                                        return __generator(this, function (_a) {\n                                                            switch (_a.label) {\n                                                                case 0:\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    if (!(nonce <= replaceable.nonce)) return [3 /*break*/, 1];\n                                                                    lastBlockNumber_1 = blockNumber;\n                                                                    return [3 /*break*/, 9];\n                                                                case 1: return [4 /*yield*/, this.getTransaction(transactionHash)];\n                                                                case 2:\n                                                                    mined = _a.sent();\n                                                                    if (mined && mined.blockNumber != null) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    // First time scanning. We start a little earlier for some\n                                                                    // wiggle room here to handle the eventually consistent nature\n                                                                    // of blockchain (e.g. the getTransactionCount was for a\n                                                                    // different block)\n                                                                    if (scannedBlock_1 == null) {\n                                                                        scannedBlock_1 = lastBlockNumber_1 - 3;\n                                                                        if (scannedBlock_1 < replaceable.startBlock) {\n                                                                            scannedBlock_1 = replaceable.startBlock;\n                                                                        }\n                                                                    }\n                                                                    _a.label = 3;\n                                                                case 3:\n                                                                    if (!(scannedBlock_1 <= blockNumber)) return [3 /*break*/, 9];\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    return [4 /*yield*/, this.getBlockWithTransactions(scannedBlock_1)];\n                                                                case 4:\n                                                                    block = _a.sent();\n                                                                    ti = 0;\n                                                                    _a.label = 5;\n                                                                case 5:\n                                                                    if (!(ti < block.transactions.length)) return [3 /*break*/, 8];\n                                                                    tx = block.transactions[ti];\n                                                                    // Successfully mined!\n                                                                    if (tx.hash === transactionHash) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    if (!(tx.from === replaceable.from && tx.nonce === replaceable.nonce)) return [3 /*break*/, 7];\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    return [4 /*yield*/, this.waitForTransaction(tx.hash, confirmations)];\n                                                                case 6:\n                                                                    receipt_1 = _a.sent();\n                                                                    // Already resolved or rejected (prolly a timeout)\n                                                                    if (alreadyDone()) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    reason = \"replaced\";\n                                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                                        reason = \"repriced\";\n                                                                    }\n                                                                    else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                                        reason = \"cancelled\";\n                                                                    }\n                                                                    // Explain why we were replaced\n                                                                    reject(logger.makeError(\"transaction was replaced\", logger_1.Logger.errors.TRANSACTION_REPLACED, {\n                                                                        cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                                        reason: reason,\n                                                                        replacement: this._wrapTransaction(tx),\n                                                                        hash: transactionHash,\n                                                                        receipt: receipt_1\n                                                                    }));\n                                                                    return [2 /*return*/];\n                                                                case 7:\n                                                                    ti++;\n                                                                    return [3 /*break*/, 5];\n                                                                case 8:\n                                                                    scannedBlock_1++;\n                                                                    return [3 /*break*/, 3];\n                                                                case 9:\n                                                                    if (done) {\n                                                                        return [2 /*return*/];\n                                                                    }\n                                                                    this.once(\"block\", replaceHandler_1);\n                                                                    return [2 /*return*/];\n                                                            }\n                                                        });\n                                                    }); }, function (error) {\n                                                        if (done) {\n                                                            return;\n                                                        }\n                                                        _this.once(\"block\", replaceHandler_1);\n                                                    });\n                                                    return [2 /*return*/];\n                                            }\n                                        });\n                                    }); };\n                                    if (done) {\n                                        return;\n                                    }\n                                    _this.once(\"block\", replaceHandler_1);\n                                    cancelFuncs.push(function () {\n                                        _this.removeListener(\"block\", replaceHandler_1);\n                                    });\n                                }\n                                if (typeof (timeout) === \"number\" && timeout > 0) {\n                                    var timer_1 = setTimeout(function () {\n                                        if (alreadyDone()) {\n                                            return;\n                                        }\n                                        reject(logger.makeError(\"timeout exceeded\", logger_1.Logger.errors.TIMEOUT, { timeout: timeout }));\n                                    }, timeout);\n                                    if (timer_1.unref) {\n                                        timer_1.unref();\n                                    }\n                                    cancelFuncs.push(function () { clearTimeout(timer_1); });\n                                }\n                            })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getBlockNumber = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this._getInternalBlockNumber(0)];\n            });\n        });\n    };\n    BaseProvider.prototype.getGasPrice = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.perform(\"getGasPrice\", {})];\n                    case 2:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getGasPrice\",\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getBalance = function (addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getBalance\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getBalance\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getTransactionCount = function (addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getTransactionCount\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result).toNumber()];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getTransactionCount\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getCode = function (addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getCode\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getCode\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getStorageAt = function (addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                address: this._getAddress(addressOrName),\n                                blockTag: this._getBlockTag(blockTag),\n                                position: Promise.resolve(position).then(function (p) { return (0, bytes_1.hexValue)(p); })\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getStorageAt\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"getStorageAt\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // This should be called by any subclass wrapping a TransactionResponse\n    BaseProvider.prototype._wrapTransaction = function (tx, hash, startBlock) {\n        var _this = this;\n        if (hash != null && (0, bytes_1.hexDataLength)(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        var result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", logger_1.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = function (confirms, timeout) { return __awaiter(_this, void 0, void 0, function () {\n            var replacement, receipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (confirms == null) {\n                            confirms = 1;\n                        }\n                        if (timeout == null) {\n                            timeout = 0;\n                        }\n                        replacement = undefined;\n                        if (confirms !== 0 && startBlock != null) {\n                            replacement = {\n                                data: tx.data,\n                                from: tx.from,\n                                nonce: tx.nonce,\n                                to: tx.to,\n                                value: tx.value,\n                                startBlock: startBlock\n                            };\n                        }\n                        return [4 /*yield*/, this._waitForTransaction(tx.hash, confirms, timeout, replacement)];\n                    case 1:\n                        receipt = _a.sent();\n                        if (receipt == null && confirms === 0) {\n                            return [2 /*return*/, null];\n                        }\n                        // No longer pending, allow the polling loop to garbage collect this\n                        this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n                        if (receipt.status === 0) {\n                            logger.throwError(\"transaction failed\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                                transactionHash: tx.hash,\n                                transaction: tx,\n                                receipt: receipt\n                            });\n                        }\n                        return [2 /*return*/, receipt];\n                }\n            });\n        }); };\n        return result;\n    };\n    BaseProvider.prototype.sendTransaction = function (signedTransaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var hexTx, tx, blockNumber, hash, error_7;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, Promise.resolve(signedTransaction).then(function (t) { return (0, bytes_1.hexlify)(t); })];\n                    case 2:\n                        hexTx = _a.sent();\n                        tx = this.formatter.transaction(signedTransaction);\n                        if (tx.confirmations == null) {\n                            tx.confirmations = 0;\n                        }\n                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                    case 3:\n                        blockNumber = _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        _a.trys.push([4, 6, , 7]);\n                        return [4 /*yield*/, this.perform(\"sendTransaction\", { signedTransaction: hexTx })];\n                    case 5:\n                        hash = _a.sent();\n                        return [2 /*return*/, this._wrapTransaction(tx, hash, blockNumber)];\n                    case 6:\n                        error_7 = _a.sent();\n                        error_7.transaction = tx;\n                        error_7.transactionHash = tx.hash;\n                        throw error_7;\n                    case 7: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getTransactionRequest = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var values, tx, _a, _b;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, transaction];\n                    case 1:\n                        values = _c.sent();\n                        tx = {};\n                        [\"from\", \"to\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? _this._getAddress(v) : null); });\n                        });\n                        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? bignumber_1.BigNumber.from(v) : null); });\n                        });\n                        [\"type\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return ((v != null) ? v : null); });\n                        });\n                        if (values.accessList) {\n                            tx.accessList = this.formatter.accessList(values.accessList);\n                        }\n                        [\"data\"].forEach(function (key) {\n                            if (values[key] == null) {\n                                return;\n                            }\n                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? (0, bytes_1.hexlify)(v) : null); });\n                        });\n                        _b = (_a = this.formatter).transactionRequest;\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)(tx)];\n                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getFilter = function (filter) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _a, _b;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, filter];\n                    case 1:\n                        filter = _c.sent();\n                        result = {};\n                        if (filter.address != null) {\n                            result.address = this._getAddress(filter.address);\n                        }\n                        [\"blockHash\", \"topics\"].forEach(function (key) {\n                            if (filter[key] == null) {\n                                return;\n                            }\n                            result[key] = filter[key];\n                        });\n                        [\"fromBlock\", \"toBlock\"].forEach(function (key) {\n                            if (filter[key] == null) {\n                                return;\n                            }\n                            result[key] = _this._getBlockTag(filter[key]);\n                        });\n                        _b = (_a = this.formatter).filter;\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)(result)];\n                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.call = function (transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                transaction: this._getTransactionRequest(transaction),\n                                blockTag: this._getBlockTag(blockTag)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"call\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"call\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.estimateGas = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({\n                                transaction: this._getTransactionRequest(transaction)\n                            })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"estimateGas\", params)];\n                    case 3:\n                        result = _a.sent();\n                        try {\n                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];\n                        }\n                        catch (error) {\n                            return [2 /*return*/, logger.throwError(\"bad result from backend\", logger_1.Logger.errors.SERVER_ERROR, {\n                                    method: \"estimateGas\",\n                                    params: params,\n                                    result: result,\n                                    error: error\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getAddress = function (addressOrName) {\n        return __awaiter(this, void 0, void 0, function () {\n            var address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, addressOrName];\n                    case 1:\n                        addressOrName = _a.sent();\n                        if (typeof (addressOrName) !== \"string\") {\n                            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n                        }\n                        return [4 /*yield*/, this.resolveName(addressOrName)];\n                    case 2:\n                        address = _a.sent();\n                        if (address == null) {\n                            logger.throwError(\"ENS name not configured\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"resolveName(\" + JSON.stringify(addressOrName) + \")\"\n                            });\n                        }\n                        return [2 /*return*/, address];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getBlock = function (blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumber, params, _a, error_8;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _b.sent();\n                        return [4 /*yield*/, blockHashOrBlockTag];\n                    case 2:\n                        blockHashOrBlockTag = _b.sent();\n                        blockNumber = -128;\n                        params = {\n                            includeTransactions: !!includeTransactions\n                        };\n                        if (!(0, bytes_1.isHexString)(blockHashOrBlockTag, 32)) return [3 /*break*/, 3];\n                        params.blockHash = blockHashOrBlockTag;\n                        return [3 /*break*/, 6];\n                    case 3:\n                        _b.trys.push([3, 5, , 6]);\n                        _a = params;\n                        return [4 /*yield*/, this._getBlockTag(blockHashOrBlockTag)];\n                    case 4:\n                        _a.blockTag = _b.sent();\n                        if ((0, bytes_1.isHexString)(params.blockTag)) {\n                            blockNumber = parseInt(params.blockTag.substring(2), 16);\n                        }\n                        return [3 /*break*/, 6];\n                    case 5:\n                        error_8 = _b.sent();\n                        logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                        return [3 /*break*/, 6];\n                    case 6: return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                            var block, blockNumber_1, i, tx, confirmations, blockWithTxs;\n                            var _this = this;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, this.perform(\"getBlock\", params)];\n                                    case 1:\n                                        block = _a.sent();\n                                        // Block was not found\n                                        if (block == null) {\n                                            // For blockhashes, if we didn't say it existed, that blockhash may\n                                            // not exist. If we did see it though, perhaps from a log, we know\n                                            // it exists, and this node is just not caught up yet.\n                                            if (params.blockHash != null) {\n                                                if (this._emitted[\"b:\" + params.blockHash] == null) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                            }\n                                            // For block tags, if we are asking for a future block, we return null\n                                            if (params.blockTag != null) {\n                                                if (blockNumber > this._emitted.block) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                            }\n                                            // Retry on the next block\n                                            return [2 /*return*/, undefined];\n                                        }\n                                        if (!includeTransactions) return [3 /*break*/, 8];\n                                        blockNumber_1 = null;\n                                        i = 0;\n                                        _a.label = 2;\n                                    case 2:\n                                        if (!(i < block.transactions.length)) return [3 /*break*/, 7];\n                                        tx = block.transactions[i];\n                                        if (!(tx.blockNumber == null)) return [3 /*break*/, 3];\n                                        tx.confirmations = 0;\n                                        return [3 /*break*/, 6];\n                                    case 3:\n                                        if (!(tx.confirmations == null)) return [3 /*break*/, 6];\n                                        if (!(blockNumber_1 == null)) return [3 /*break*/, 5];\n                                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                                    case 4:\n                                        blockNumber_1 = _a.sent();\n                                        _a.label = 5;\n                                    case 5:\n                                        confirmations = (blockNumber_1 - tx.blockNumber) + 1;\n                                        if (confirmations <= 0) {\n                                            confirmations = 1;\n                                        }\n                                        tx.confirmations = confirmations;\n                                        _a.label = 6;\n                                    case 6:\n                                        i++;\n                                        return [3 /*break*/, 2];\n                                    case 7:\n                                        blockWithTxs = this.formatter.blockWithTransactions(block);\n                                        blockWithTxs.transactions = blockWithTxs.transactions.map(function (tx) { return _this._wrapTransaction(tx); });\n                                        return [2 /*return*/, blockWithTxs];\n                                    case 8: return [2 /*return*/, this.formatter.block(block)];\n                                }\n                            });\n                        }); }, { oncePoll: this })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getBlock = function (blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    };\n    BaseProvider.prototype.getBlockWithTransactions = function (blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    };\n    BaseProvider.prototype.getTransaction = function (transactionHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, transactionHash];\n                    case 2:\n                        transactionHash = _a.sent();\n                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n                        return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var result, tx, blockNumber, confirmations;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, this.perform(\"getTransaction\", params)];\n                                        case 1:\n                                            result = _a.sent();\n                                            if (result == null) {\n                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            tx = this.formatter.transactionResponse(result);\n                                            if (!(tx.blockNumber == null)) return [3 /*break*/, 2];\n                                            tx.confirmations = 0;\n                                            return [3 /*break*/, 4];\n                                        case 2:\n                                            if (!(tx.confirmations == null)) return [3 /*break*/, 4];\n                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                                        case 3:\n                                            blockNumber = _a.sent();\n                                            confirmations = (blockNumber - tx.blockNumber) + 1;\n                                            if (confirmations <= 0) {\n                                                confirmations = 1;\n                                            }\n                                            tx.confirmations = confirmations;\n                                            _a.label = 4;\n                                        case 4: return [2 /*return*/, this._wrapTransaction(tx)];\n                                    }\n                                });\n                            }); }, { oncePoll: this })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getTransactionReceipt = function (transactionHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, transactionHash];\n                    case 2:\n                        transactionHash = _a.sent();\n                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n                        return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var result, receipt, blockNumber, confirmations;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, this.perform(\"getTransactionReceipt\", params)];\n                                        case 1:\n                                            result = _a.sent();\n                                            if (result == null) {\n                                                if (this._emitted[\"t:\" + transactionHash] == null) {\n                                                    return [2 /*return*/, null];\n                                                }\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            // \"geth-etc\" returns receipts before they are ready\n                                            if (result.blockHash == null) {\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            receipt = this.formatter.receipt(result);\n                                            if (!(receipt.blockNumber == null)) return [3 /*break*/, 2];\n                                            receipt.confirmations = 0;\n                                            return [3 /*break*/, 4];\n                                        case 2:\n                                            if (!(receipt.confirmations == null)) return [3 /*break*/, 4];\n                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                                        case 3:\n                                            blockNumber = _a.sent();\n                                            confirmations = (blockNumber - receipt.blockNumber) + 1;\n                                            if (confirmations <= 0) {\n                                                confirmations = 1;\n                                            }\n                                            receipt.confirmations = confirmations;\n                                            _a.label = 4;\n                                        case 4: return [2 /*return*/, receipt];\n                                    }\n                                });\n                            }); }, { oncePoll: this })];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getLogs = function (filter) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, logs;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, (0, properties_1.resolveProperties)({ filter: this._getFilter(filter) })];\n                    case 2:\n                        params = _a.sent();\n                        return [4 /*yield*/, this.perform(\"getLogs\", params)];\n                    case 3:\n                        logs = _a.sent();\n                        logs.forEach(function (log) {\n                            if (log.removed == null) {\n                                log.removed = false;\n                            }\n                        });\n                        return [2 /*return*/, formatter_1.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getEtherPrice = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, this.perform(\"getEtherPrice\", {})];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getBlockTag = function (blockTag) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, blockTag];\n                    case 1:\n                        blockTag = _a.sent();\n                        if (!(typeof (blockTag) === \"number\" && blockTag < 0)) return [3 /*break*/, 3];\n                        if (blockTag % 1) {\n                            logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                        }\n                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n                    case 2:\n                        blockNumber = _a.sent();\n                        blockNumber += blockTag;\n                        if (blockNumber < 0) {\n                            blockNumber = 0;\n                        }\n                        return [2 /*return*/, this.formatter.blockTag(blockNumber)];\n                    case 3: return [2 /*return*/, this.formatter.blockTag(blockTag)];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getResolver = function (name) {\n        return __awaiter(this, void 0, void 0, function () {\n            var address, error_9;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this._getResolver(name)];\n                    case 1:\n                        address = _a.sent();\n                        if (address == null) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, new Resolver(this, address, name)];\n                    case 2:\n                        error_9 = _a.sent();\n                        if (error_9.code === logger_1.Logger.errors.CALL_EXCEPTION) {\n                            return [2 /*return*/, null];\n                        }\n                        throw error_9;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype._getResolver = function (name) {\n        return __awaiter(this, void 0, void 0, function () {\n            var network, transaction, _a, _b, error_10;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.getNetwork()];\n                    case 1:\n                        network = _c.sent();\n                        // No ENS...\n                        if (!network.ensAddress) {\n                            logger.throwError(\"network does not support ENS\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n                        }\n                        transaction = {\n                            to: network.ensAddress,\n                            data: (\"0x0178b8bf\" + (0, hash_1.namehash)(name).substring(2))\n                        };\n                        _c.label = 2;\n                    case 2:\n                        _c.trys.push([2, 4, , 5]);\n                        _b = (_a = this.formatter).callAddress;\n                        return [4 /*yield*/, this.call(transaction)];\n                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n                    case 4:\n                        error_10 = _c.sent();\n                        if (error_10.code === logger_1.Logger.errors.CALL_EXCEPTION) {\n                            return [2 /*return*/, null];\n                        }\n                        throw error_10;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.resolveName = function (name) {\n        return __awaiter(this, void 0, void 0, function () {\n            var resolver;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, name];\n                    case 1:\n                        name = _a.sent();\n                        // If it is already an address, nothing to resolve\n                        try {\n                            return [2 /*return*/, Promise.resolve(this.formatter.address(name))];\n                        }\n                        catch (error) {\n                            // If is is a hexstring, the address is bad (See #694)\n                            if ((0, bytes_1.isHexString)(name)) {\n                                throw error;\n                            }\n                        }\n                        if (typeof (name) !== \"string\") {\n                            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n                        }\n                        return [4 /*yield*/, this.getResolver(name)];\n                    case 2:\n                        resolver = _a.sent();\n                        if (!resolver) {\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, resolver.getAddress()];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.lookupAddress = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var reverseName, resolverAddress, bytes, _a, length, name, addr;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, address];\n                    case 1:\n                        address = _b.sent();\n                        address = this.formatter.address(address);\n                        reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n                        return [4 /*yield*/, this._getResolver(reverseName)];\n                    case 2:\n                        resolverAddress = _b.sent();\n                        if (!resolverAddress) {\n                            return [2 /*return*/, null];\n                        }\n                        _a = bytes_1.arrayify;\n                        return [4 /*yield*/, this.call({\n                                to: resolverAddress,\n                                data: (\"0x691f3431\" + (0, hash_1.namehash)(reverseName).substring(2))\n                            })];\n                    case 3:\n                        bytes = _a.apply(void 0, [_b.sent()]);\n                        // Strip off the dynamic string pointer (0x20)\n                        if (bytes.length < 32 || !bignumber_1.BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n                            return [2 /*return*/, null];\n                        }\n                        bytes = bytes.slice(32);\n                        // Not a length-prefixed string\n                        if (bytes.length < 32) {\n                            return [2 /*return*/, null];\n                        }\n                        length = bignumber_1.BigNumber.from(bytes.slice(0, 32)).toNumber();\n                        bytes = bytes.slice(32);\n                        // Length longer than available data\n                        if (length > bytes.length) {\n                            return [2 /*return*/, null];\n                        }\n                        name = (0, strings_1.toUtf8String)(bytes.slice(0, length));\n                        return [4 /*yield*/, this.resolveName(name)];\n                    case 4:\n                        addr = _b.sent();\n                        if (addr != address) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, name];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.getAvatar = function (nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function () {\n            var resolver, address, reverseName, resolverAddress, avatar;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        resolver = null;\n                        if (!(0, bytes_1.isHexString)(nameOrAddress)) return [3 /*break*/, 2];\n                        address = this.formatter.address(nameOrAddress);\n                        reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n                        return [4 /*yield*/, this._getResolver(reverseName)];\n                    case 1:\n                        resolverAddress = _a.sent();\n                        if (!resolverAddress) {\n                            return [2 /*return*/, null];\n                        }\n                        resolver = new Resolver(this, resolverAddress, \"_\", address);\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, this.getResolver(nameOrAddress)];\n                    case 3:\n                        // ENS name; forward lookup\n                        resolver = _a.sent();\n                        if (!resolver) {\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 4;\n                    case 4: return [4 /*yield*/, resolver.getAvatar()];\n                    case 5:\n                        avatar = _a.sent();\n                        if (avatar == null) {\n                            return [2 /*return*/, null];\n                        }\n                        return [2 /*return*/, avatar.url];\n                }\n            });\n        });\n    };\n    BaseProvider.prototype.perform = function (method, params) {\n        return logger.throwError(method + \" not implemented\", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    };\n    BaseProvider.prototype._startEvent = function (event) {\n        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n    };\n    BaseProvider.prototype._stopEvent = function (event) {\n        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n    };\n    BaseProvider.prototype._addEventListener = function (eventName, listener, once) {\n        var event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    };\n    BaseProvider.prototype.on = function (eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    };\n    BaseProvider.prototype.once = function (eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    };\n    BaseProvider.prototype.emit = function (eventName) {\n        var _this = this;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var result = false;\n        var stopped = [];\n        var eventTag = getEventTag(eventName);\n        this._events = this._events.filter(function (event) {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(function () {\n                event.listener.apply(_this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach(function (event) { _this._stopEvent(event); });\n        return result;\n    };\n    BaseProvider.prototype.listenerCount = function (eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        var eventTag = getEventTag(eventName);\n        return this._events.filter(function (event) {\n            return (event.tag === eventTag);\n        }).length;\n    };\n    BaseProvider.prototype.listeners = function (eventName) {\n        if (eventName == null) {\n            return this._events.map(function (event) { return event.listener; });\n        }\n        var eventTag = getEventTag(eventName);\n        return this._events\n            .filter(function (event) { return (event.tag === eventTag); })\n            .map(function (event) { return event.listener; });\n    };\n    BaseProvider.prototype.off = function (eventName, listener) {\n        var _this = this;\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        var stopped = [];\n        var found = false;\n        var eventTag = getEventTag(eventName);\n        this._events = this._events.filter(function (event) {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach(function (event) { _this._stopEvent(event); });\n        return this;\n    };\n    BaseProvider.prototype.removeAllListeners = function (eventName) {\n        var _this = this;\n        var stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            var eventTag_1 = getEventTag(eventName);\n            this._events = this._events.filter(function (event) {\n                if (event.tag !== eventTag_1) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach(function (event) { _this._stopEvent(event); });\n        return this;\n    };\n    return BaseProvider;\n}(abstract_provider_1.Provider));\nexports.BaseProvider = BaseProvider;\n//# sourceMappingURL=base-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Jhc2UtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYTtBQUN2RCwwQkFBMEIsbUJBQU8sQ0FBQyxnSUFBa0M7QUFDcEUsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLHNHQUFxQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyw4R0FBeUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsa0hBQTJCO0FBQ3RELGFBQWEsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsNEdBQXdCO0FBQ2hELFlBQVksbUJBQU8sQ0FBQyxvR0FBb0I7QUFDeEMsK0JBQStCLG1CQUFPLENBQUMsb0RBQVE7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDBHQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxxR0FBWTtBQUNyQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0RBQXNEO0FBQ2pFLFdBQVcsdURBQXVEO0FBQ2xFLFdBQVcseUNBQXlDO0FBQ3BELFlBQVksMkJBQTJCO0FBQ3ZDLFlBQVksMkJBQTJCO0FBQ3ZDLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtDQUFrQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckUsZ0RBQWdELCtCQUErQjtBQUMvRTtBQUNBLHVDQUF1QywrQkFBK0I7QUFDdEUsZ0RBQWdELCtCQUErQjtBQUMvRTtBQUNBLHVDQUF1QywrQkFBK0I7QUFDdEUsZ0RBQWdELDRDQUE0QztBQUM1RjtBQUNBO0FBQ0EsdUNBQXVDLCtCQUErQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhDQUE4QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0Q0FBNEM7QUFDbkYsc0RBQXNELElBQUk7QUFDMUQ7QUFDQSxnRUFBZ0UsR0FBRztBQUNuRSwyQ0FBMkMscURBQXFEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFEQUFxRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUNBQXFDO0FBQ2hGO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDO0FBQ3ZFLGdEQUFnRCxpQ0FBaUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELDhDQUE4QztBQUM5QztBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsc0ZBQXNGLGdCQUFnQixxQkFBcUIsaUJBQWlCO0FBQzVJLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLHFDQUFxQztBQUNyQyx5QkFBeUI7QUFDekI7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkJBQTJCLDZCQUE2QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMscUNBQXFDLDJCQUEyQiw2QkFBNkI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCLDZCQUE2QjtBQUNqRjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseURBQXlELGVBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGVBQWU7QUFDeEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0RBQXNEO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQscURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxrQkFBa0I7QUFDeEkscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx3QkFBd0I7QUFDM0Y7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixrQ0FBa0M7QUFDMUgsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtJQUFrSSwyQ0FBMkM7QUFDN0s7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxpQ0FBaUM7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDBCQUEwQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDJDQUEyQztBQUNsSSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsb0RBQW9EO0FBQzNJLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixrQ0FBa0M7QUFDekgseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDhDQUE4QztBQUNySSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSEFBa0gsb0NBQW9DO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUIsSUFBSSxJQUFJLGdCQUFnQjtBQUNqRDtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLElBQUksSUFBSSxnQkFBZ0I7QUFDckQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLElBQUksSUFBSSxnQkFBZ0I7QUFDckQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixpQ0FBaUM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgseUNBQXlDO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdHQUF3RyxtQkFBbUI7QUFDM0g7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3QkFBd0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RSxvQ0FBb0Msd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Jhc2UtcHJvdmlkZXIuanM/MDdlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlUHJvdmlkZXIgPSBleHBvcnRzLlJlc29sdmVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbnZhciBhYnN0cmFjdF9wcm92aWRlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCIpO1xudmFyIGJhc2V4XzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmFzZXhcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCIpO1xudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9oYXNoXCIpO1xudmFyIG5ldHdvcmtzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbmV0d29ya3NcIik7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgc2hhMl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3NoYTJcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIik7XG52YXIgd2ViXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qvd2ViXCIpO1xudmFyIGJlY2gzMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiZWNoMzJcIikpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xudmFyIGZvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vZm9ybWF0dGVyXCIpO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFdmVudCBTZXJpYWxpemVpbmdcbmZ1bmN0aW9uIGNoZWNrVG9waWModG9waWMpIHtcbiAgICBpZiAodG9waWMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmICgoMCwgYnl0ZXNfMS5oZXhEYXRhTGVuZ3RoKSh0b3BpYykgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsIFwidG9waWNcIiwgdG9waWMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9waWMudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvcGljcyh0b3BpY3MpIHtcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgbnVsbCBBTkQtdG9waWNzOyB0aGV5IGFyZSByZWR1bmRhbnRcbiAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcbiAgICB3aGlsZSAodG9waWNzLmxlbmd0aCA+IDAgJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PSBudWxsKSB7XG4gICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcGljcy5tYXAoZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuICAgICAgICAgICAgLy8gT25seSB0cmFjayB1bmlxdWUgT1ItdG9waWNzXG4gICAgICAgICAgICB2YXIgdW5pcXVlXzEgPSB7fTtcbiAgICAgICAgICAgIHRvcGljLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlXzFbY2hlY2tUb3BpYyh0b3BpYyldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIE9SLXRvcGljcyBkb2VzIG5vdCBtYXR0ZXJcbiAgICAgICAgICAgIHZhciBzb3J0ZWQgPSBPYmplY3Qua2V5cyh1bmlxdWVfMSk7XG4gICAgICAgICAgICBzb3J0ZWQuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1RvcGljKHRvcGljKTtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoLyYvZykubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICBpZiAodG9waWMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcHMgPSB0b3BpYy5zcGxpdChcInxcIikubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICAgICAgcmV0dXJuICgodG9waWMgPT09IFwibnVsbFwiKSA/IG51bGwgOiB0b3BpYyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKChjb21wcy5sZW5ndGggPT09IDEpID8gY29tcHNbMF0gOiBjb21wcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFRhZyhldmVudE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoKDAsIGJ5dGVzXzEuaGV4RGF0YUxlbmd0aCkoZXZlbnROYW1lKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInR4OlwiICsgZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnROYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJmaWx0ZXI6KjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhYnN0cmFjdF9wcm92aWRlcl8xLkZvcmtFdmVudC5pc0ZvcmtFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50TmFtZSAmJiB0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsdGVyOlwiICsgKGV2ZW50TmFtZS5hZGRyZXNzIHx8IFwiKlwiKSArIFwiOlwiICsgc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZS50b3BpY3MgfHwgW10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50IC0gXCIgKyBldmVudE5hbWUpO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgT2JqZWN0XG5mdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gICAgfSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFByb3ZpZGVyIE9iamVjdFxuLyoqXG4gKiAgRXZlbnRUeXBlXG4gKiAgIC0gXCJibG9ja1wiXG4gKiAgIC0gXCJwb2xsXCJcbiAqICAgLSBcImRpZFBvbGxcIlxuICogICAtIFwicGVuZGluZ1wiXG4gKiAgIC0gXCJlcnJvclwiXG4gKiAgIC0gXCJuZXR3b3JrXCJcbiAqICAgLSBmaWx0ZXJcbiAqICAgLSB0b3BpY3MgYXJyYXlcbiAqICAgLSB0cmFuc2FjdGlvbiBoYXNoXG4gKi9cbnZhciBQb2xsYWJsZUV2ZW50cyA9IFtcImJsb2NrXCIsIFwibmV0d29ya1wiLCBcInBlbmRpbmdcIiwgXCJwb2xsXCJdO1xudmFyIEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50KHRhZywgbGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJsaXN0ZW5lclwiLCBsaXN0ZW5lcik7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwib25jZVwiLCBvbmNlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJldmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidHhcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaDtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiaGFzaFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcInR4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wc1sxXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwiZmlsdGVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhZGRyZXNzID0gY29tcHNbMV07XG4gICAgICAgICAgICB2YXIgdG9waWNzID0gZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKHRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEV2ZW50LnByb3RvdHlwZS5wb2xsYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnRhZy5pbmRleE9mKFwiOlwiKSA+PSAwIHx8IFBvbGxhYmxlRXZlbnRzLmluZGV4T2YodGhpcy50YWcpID49IDApO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50O1xufSgpKTtcbmV4cG9ydHMuRXZlbnQgPSBFdmVudDtcbjtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iL21hc3Rlci9zbGlwLTAwNDQubWRcbnZhciBjb2luSW5mb3MgPSB7XG4gICAgXCIwXCI6IHsgc3ltYm9sOiBcImJ0Y1wiLCBwMnBraDogMHgwMCwgcDJzaDogMHgwNSwgcHJlZml4OiBcImJjXCIgfSxcbiAgICBcIjJcIjogeyBzeW1ib2w6IFwibHRjXCIsIHAycGtoOiAweDMwLCBwMnNoOiAweDMyLCBwcmVmaXg6IFwibHRjXCIgfSxcbiAgICBcIjNcIjogeyBzeW1ib2w6IFwiZG9nZVwiLCBwMnBraDogMHgxZSwgcDJzaDogMHgxNiB9LFxuICAgIFwiNjBcIjogeyBzeW1ib2w6IFwiZXRoXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNjFcIjogeyBzeW1ib2w6IFwiZXRjXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNzAwXCI6IHsgc3ltYm9sOiBcInhkYWlcIiwgaWxrOiBcImV0aFwiIH0sXG59O1xuZnVuY3Rpb24gYnl0ZXMzMmlmeSh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKShiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSwgMzIpO1xufVxuLy8gQ29tcHV0ZSB0aGUgQmFzZTU4Q2hlY2sgZW5jb2RlZCBkYXRhIChjaGVja3N1bSBpcyBmaXJzdCA0IGJ5dGVzIG9mIHNoYTI1NmQpXG5mdW5jdGlvbiBiYXNlNThFbmNvZGUoZGF0YSkge1xuICAgIHJldHVybiBiYXNleF8xLkJhc2U1OC5lbmNvZGUoKDAsIGJ5dGVzXzEuY29uY2F0KShbZGF0YSwgKDAsIGJ5dGVzXzEuaGV4RGF0YVNsaWNlKSgoMCwgc2hhMl8xLnNoYTI1NikoKDAsIHNoYTJfMS5zaGEyNTYpKGRhdGEpKSwgMCwgNCldKSk7XG59XG52YXIgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xudmFyIG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfMS50b1V0ZjhTdHJpbmcpKF9wYXJzZUJ5dGVzKHJlc3VsdCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oKDAsIGJ5dGVzXzEuaGV4RGF0YVNsaWNlKShyZXN1bHQsIDAsIDMyKSkudG9OdW1iZXIoKTtcbiAgICB2YXIgbGVuZ3RoID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oKDAsIGJ5dGVzXzEuaGV4RGF0YVNsaWNlKShyZXN1bHQsIG9mZnNldCwgb2Zmc2V0ICsgMzIpKS50b051bWJlcigpO1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbn1cbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgcmV0dXJuIFwiaHR0cHM6Ly9nYXRld2F5LmlwZnMuaW8vaXBmcy9cIiArIGxpbmsuc3Vic3RyaW5nKDcpO1xufVxudmFyIFJlc29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSByZXNvbHZlZEFkZHJlc3MgaXMgb25seSBmb3IgY3JlYXRpbmcgYSBSZXZlcnNlTG9va3VwIHJlc29sdmVyXG4gICAgZnVuY3Rpb24gUmVzb2x2ZXIocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUsIHJlc29sdmVkQWRkcmVzcykge1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcImFkZHJlc3NcIiwgcHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcykpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KSh0aGlzLCBcIl9yZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZWRBZGRyZXNzKTtcbiAgICB9XG4gICAgUmVzb2x2ZXIucHJvdG90eXBlLl9mZXRjaEJ5dGVzID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eCwgX2EsIGVycm9yXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICgwLCBieXRlc18xLmhleENvbmNhdCkoW3NlbGVjdG9yLCAoMCwgaGFzaF8xLm5hbWVoYXNoKSh0aGlzLm5hbWUpLCAocGFyYW1ldGVycyB8fCBcIjB4XCIpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9wYXJzZUJ5dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5jYWxsKHR4KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcl8xLmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc29sdmVyLnByb3RvdHlwZS5fZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uIChjb2luVHlwZSwgaGV4Qnl0ZXMpIHtcbiAgICAgICAgdmFyIGNvaW5JbmZvID0gY29pbkluZm9zW1N0cmluZyhjb2luVHlwZSldO1xuICAgICAgICBpZiAoY29pbkluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luIHR5cGU6IFwiICsgY29pblR5cGUsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEFkZHJlc3MoXCIgKyBjb2luVHlwZSArIFwiKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pbkluZm8uaWxrID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhoZXhCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGhleEJ5dGVzKTtcbiAgICAgICAgLy8gUDJQS0g6IE9QX0RVUCBPUF9IQVNIMTYwIDxwdWJLZXlIYXNoPiBPUF9FUVVBTFZFUklGWSBPUF9DSEVDS1NJR1xuICAgICAgICBpZiAoY29pbkluZm8ucDJwa2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHAycGtoID0gaGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7XG4gICAgICAgICAgICBpZiAocDJwa2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBwYXJzZUludChwMnBraFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnBraFsyXS5sZW5ndGggPT09IGxlbmd0aF8xICogMiAmJiBsZW5ndGhfMSA+PSAxICYmIGxlbmd0aF8xIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoKDAsIGJ5dGVzXzEuY29uY2F0KShbW2NvaW5JbmZvLnAycGtoXSwgKFwiMHhcIiArIHAycGtoWzJdKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUDJTSDogT1BfSEFTSDE2MCA8c2NyaXB0SGFzaD4gT1BfRVFVQUxcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAyc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHAyc2ggPSBoZXhCeXRlcy5tYXRjaCgvXjB4YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg3JC8pO1xuICAgICAgICAgICAgaWYgKHAyc2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzIgPSBwYXJzZUludChwMnNoWzFdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKHAyc2hbMl0ubGVuZ3RoID09PSBsZW5ndGhfMiAqIDIgJiYgbGVuZ3RoXzIgPj0gMSAmJiBsZW5ndGhfMiA8PSA3NSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTU4RW5jb2RlKCgwLCBieXRlc18xLmNvbmNhdCkoW1tjb2luSW5mby5wMnNoXSwgKFwiMHhcIiArIHAyc2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCZWNoMzJcbiAgICAgICAgaWYgKGNvaW5JbmZvLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoXzMgPSBieXRlc1sxXTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAxNDEubWVkaWF3aWtpI3dpdG5lc3MtcHJvZ3JhbVxuICAgICAgICAgICAgdmFyIHZlcnNpb25fMSA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb25fMSA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhfMyAhPT0gMjAgJiYgbGVuZ3RoXzMgIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25fMSA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnNpb25fMSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb25fMSA+PSAwICYmIGJ5dGVzLmxlbmd0aCA9PT0gMiArIGxlbmd0aF8zICYmIGxlbmd0aF8zID49IDEgJiYgbGVuZ3RoXzMgPD0gNzUpIHtcbiAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSBiZWNoMzJfMS5kZWZhdWx0LnRvV29yZHMoYnl0ZXMuc2xpY2UoMikpO1xuICAgICAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQodmVyc2lvbl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVjaDMyXzEuZGVmYXVsdC5lbmNvZGUoY29pbkluZm8ucHJlZml4LCB3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZXNvbHZlci5wcm90b3R5cGUuZ2V0QWRkcmVzcyA9IGZ1bmN0aW9uIChjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24sIGhleEJ5dGVzXzEsIGVycm9yXzIsIGhleEJ5dGVzLCBhZGRyZXNzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29pblR5cGUgPT09IDYwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4M2IzYjU3ZGVcIiArICgwLCBoYXNoXzEubmFtZWhhc2gpKHRoaXMubmFtZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh0cmFuc2FjdGlvbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlc18xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhleEJ5dGVzXzEgPT09IFwiMHhcIiB8fCBoZXhCeXRlc18xID09PSBjb25zdGFudHNfMS5IYXNoWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhoZXhCeXRlc18xKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JfMi5jb2RlID09PSBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhmMWNiN2UwNlwiLCBieXRlczMyaWZ5KGNvaW5UeXBlKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb2luIGRhdGFcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEFkZHJlc3MoXCIgKyBjb2luVHlwZSArIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2luVHlwZTogY29pblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzb2x2ZXIucHJvdG90eXBlLmdldEF2YXRhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpbmthZ2UsIGF2YXRhciwgaSwgbWF0Y2gsIHNjaGVtZSwgX2EsIHNlbGVjdG9yLCBvd25lciwgX2IsIGNvbXBzLCBhZGRyLCB0b2tlbklkLCB0b2tlbk93bmVyLCBfYywgX2QsIGJhbGFuY2UsIF9lLCBfZiwgdHgsIG1ldGFkYXRhVXJsLCBfZywgbWV0YWRhdGEsIGltYWdlVXJsLCBpcGZzLCBlcnJvcl8zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfaCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2gubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZSA9IFt7IHR5cGU6IFwibmFtZVwiLCBjb250ZW50OiB0aGlzLm5hbWUgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oLnRyeXMucHVzaChbMSwgMTksICwgMjBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YXRhciA9IF9oLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2gubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgbWF0Y2hlcnMubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWUgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBzY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpcGZzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGxpbmthZ2U6IGxpbmthZ2UsIHVybDogYXZhdGFyIH1dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImRhdGFcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgbGlua2FnZTogbGlua2FnZSwgdXJsOiBhdmF0YXIgfV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyBsaW5rYWdlOiBsaW5rYWdlLCB1cmw6IGdldElwZnNMaW5rKGF2YXRhcikgfV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcIjB4Yzg3YjU2ZGRcIiA6IFwiMHgwZTg5MzQxY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogc2NoZW1lLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHRoaXMuX3Jlc29sdmVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYikgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEFkZHJlc3MoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9oLnNlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyID0gKF9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyID0gX2guc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5JZCA9ICgwLCBieXRlc18xLmhleFplcm9QYWQpKGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKGNvbXBzWzFdKS50b0hleFN0cmluZygpLCAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzY2hlbWUgPT09IFwiZXJjNzIxXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IChfYyA9IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyKS5jYWxsQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBhZGRyLCBkYXRhOiAoMCwgYnl0ZXNfMS5oZXhDb25jYXQpKFtcIjB4NjM1MjIxMWVcIiwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Pd25lciA9IF9kLmFwcGx5KF9jLCBbX2guc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgIT09IHRva2VuT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIGNvbnRlbnQ6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YgPSAoX2UgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIpLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShbXCIweDAwZmRkNThlXCIsICgwLCBieXRlc18xLmhleFplcm9QYWQpKG93bmVyLCAzMiksIHRva2VuSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2UgPSBfZi5hcHBseShfZSwgW19oLnNlbnQoKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhbGFuY2UuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImJhbGFuY2VcIiwgY29udGVudDogYmFsYW5jZS50b1N0cmluZygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2gubGFiZWwgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoMCwgYnl0ZXNfMS5oZXhDb25jYXQpKFtzZWxlY3RvciwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2cgPSBfcGFyc2VTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gX2cuYXBwbHkodm9pZCAwLCBbX2guc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIGNvbnRlbnQ6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBtZXRhZGF0YVVybC5yZXBsYWNlKFwie2lkfVwiLCB0b2tlbklkLnN1YnN0cmluZygyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgd2ViXzEuZmV0Y2hKc29uKShtZXRhZGF0YVVybCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmwtaXBmc1wiLCBjb250ZW50OiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIGNvbnRlbnQ6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgbGlua2FnZTogbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8zID0gX2guc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzb2x2ZXIucHJvdG90eXBlLmdldENvbnRlbnRIYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaGV4Qnl0ZXMsIGlwZnMsIGxlbmd0aF80LCBzd2FybTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4YmMxYzU4ZDFcIildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbnRlbnRoYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXBmcyA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlMzAxMDE3MCgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aF80ID0gcGFyc2VJbnQoaXBmc1szXSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzWzRdLmxlbmd0aCA9PT0gbGVuZ3RoXzQgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBcImlwZnM6L1xcL1wiICsgYmFzZXhfMS5CYXNlNTguZW5jb2RlKFwiMHhcIiArIGlwZnNbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FybSA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXJtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXJtWzFdLmxlbmd0aCA9PT0gKDMyICogMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFwiYnp6Oi9cXC9cIiArIHN3YXJtWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvbnRlbnQgaGFzaCBkYXRhXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc29sdmVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIga2V5Qnl0ZXMsIGhleEJ5dGVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSAoMCwgc3RyaW5nc18xLnRvVXRmOEJ5dGVzKShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vZGVoYXNoIGNvbnN1bWVzIHRoZSBmaXJzdCBzbG90LCBzbyB0aGUgc3RyaW5nIHBvaW50ZXIgdGFyZ2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IDY0LCB3aXRoIHRoZSBsZW5ndGggYXQgb2Zmc2V0IDY0IGFuZCBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCA5NlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSAoMCwgYnl0ZXNfMS5jb25jYXQpKFtieXRlczMyaWZ5KDY0KSwgYnl0ZXMzMmlmeShrZXlCeXRlcy5sZW5ndGgpLCBrZXlCeXRlc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFkIHRvIHdvcmQtc2l6ZSAoMzIgYnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGtleUJ5dGVzLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gKDAsIGJ5dGVzXzEuY29uY2F0KShba2V5Qnl0ZXMsICgwLCBieXRlc18xLmhleFplcm9QYWQpKFwiMHhcIiwgMzIgLSAoa2V5Lmxlbmd0aCAlIDMyKSldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2ZldGNoQnl0ZXMoXCIweDU5ZDFkNDNjXCIsICgwLCBieXRlc18xLmhleGxpZnkpKGtleUJ5dGVzKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIHN0cmluZ3NfMS50b1V0ZjhTdHJpbmcpKGhleEJ5dGVzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc29sdmVyO1xufSgpKTtcbmV4cG9ydHMuUmVzb2x2ZXIgPSBSZXNvbHZlcjtcbnZhciBkZWZhdWx0Rm9ybWF0dGVyID0gbnVsbDtcbnZhciBuZXh0UG9sbElkID0gMTtcbnZhciBCYXNlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VQcm92aWRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiAgcmVhZHlcbiAgICAgKlxuICAgICAqICBBIFByb21pc2U8TmV0d29yaz4gdGhhdCByZXNvbHZlcyBvbmx5IG9uY2UgdGhlIHByb3ZpZGVyIGlzIHJlYWR5LlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIHRoYXQgY2FsbCB0aGUgc3VwZXIgd2l0aCBhIG5ldHdvcmsgd2l0aG91dCBhIGNoYWluSWRcbiAgICAgKiAgTVVTVCBzZXQgdGhpcy4gU3RhbmRhcmQgbmFtZWQgbmV0d29ya3MgaGF2ZSBhIGtub3duIGNoYWluSWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCYXNlUHJvdmlkZXIobmV0d29yaykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBhYnN0cmFjdF9wcm92aWRlcl8xLlByb3ZpZGVyKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBFdmVudHMgYmVpbmcgbGlzdGVuZWQgdG9cbiAgICAgICAgX3RoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5fZW1pdHRlZCA9IHsgYmxvY2s6IC0yIH07XG4gICAgICAgIF90aGlzLmZvcm1hdHRlciA9IF9uZXdUYXJnZXQuZ2V0Rm9ybWF0dGVyKCk7XG4gICAgICAgIC8vIElmIG5ldHdvcmsgaXMgYW55LCB0aGlzIFByb3ZpZGVyIGFsbG93cyB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBuZXR3b3JrIHRvIGNoYW5nZSBkeW5hbWljYWxseSwgYW5kIHdlIGF1dG8tZGV0ZWN0IHRoZVxuICAgICAgICAvLyBjdXJyZW50IG5ldHdvcmtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYW55TmV0d29ya1wiLCAobmV0d29yayA9PT0gXCJhbnlcIikpO1xuICAgICAgICBpZiAoX3RoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgbmV0d29yayA9IF90aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9uZXR3b3JrUHJvbWlzZSA9IG5ldHdvcms7XG4gICAgICAgICAgICAvLyBTcXVhc2ggYW55IFwidW5oYW5kbGVkIHByb21pc2VcIiBlcnJvcnM7IHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgaGFuZGxlZFxuICAgICAgICAgICAgbmV0d29yay5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgbmV0d29yayBzZXR0aW5nIChhc3luYylcbiAgICAgICAgICAgIF90aGlzLl9yZWFkeSgpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrbm93bk5ldHdvcmsgPSAoMCwgcHJvcGVydGllc18xLmdldFN0YXRpYykoX25ld1RhcmdldCwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGtub3duTmV0d29yaykge1xuICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcIm5ldHdvcmtcIiwga25vd25OZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG4gICAgICAgIF90aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgX3RoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIF90aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9yZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcmssIGVycm9yXzQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9uZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9uZXR3b3JrUHJvbWlzZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9uZXR3b3JrUHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShuZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGV0ZWN0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuOyBldmVyeSBQcm92aWRlciBzdWItY2xhc3Mgc2hvdWxkIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3RlZCBhIG5ldHdvcmsgYnkgaGVyZSAob3IgaGF2ZSB0aHJvd24pLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJubyBuZXR3b3JrIGRldGVjdGVkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgdGhpcyBjYWxsIHN0YWNrZWQgc28gZG8gbm90IGNhbGwgZGVmaW5lUmVhZE9ubHkgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fbmV0d29ya107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwicmVhZHlcIiwge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBlc3RhYmxpc2hlZCBuZXR3b3JrLlxuICAgICAgICAvLyBGb3IgXCJhbnlcIiwgdGhpcyBjYW4gY2hhbmdlIChhIFwibmV0d29ya1wiIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlXG4gICAgICAgIC8vIGFueSBjaGFuZ2UgaXMgcmVmbGVjdGVkKTsgb3RoZXJ3aXNlIHRoaXMgY2Fubm90IGNoYW5nZVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHdlYl8xLnBvbGwpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JlYWR5KCkudGhlbihmdW5jdGlvbiAobmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldHdvcmsgaXNuJ3QgcnVubmluZyB5ZXQsIHdlIHdpbGwgd2FpdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SICYmIGVycm9yLmV2ZW50ID09PSBcIm5vTmV0d29ya1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgY3JlYXRlIGEgc2luZ2xldG9uIGZvcm1hdHRlclxuICAgIEJhc2VQcm92aWRlci5nZXRGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Rm9ybWF0dGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRGb3JtYXR0ZXIgPSBuZXcgZm9ybWF0dGVyXzEuRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG4gICAgfTtcbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcbiAgICBCYXNlUHJvdmlkZXIuZ2V0TmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiAoMCwgbmV0d29ya3NfMS5nZXROZXR3b3JrKSgobmV0d29yayA9PSBudWxsKSA/IFwiaG9tZXN0ZWFkXCIgOiBuZXR3b3JrKTtcbiAgICB9O1xuICAgIC8vIEZldGNoZXMgdGhlIGJsb2NrTnVtYmVyLCBidXQgd2lsbCByZXVzZSBhbnkgcmVzdWx0IHRoYXQgaXMgbGVzc1xuICAgIC8vIHRoYW4gbWF4QWdlIG9sZCBvciBoYXMgYmVlbiByZXF1ZXN0ZWQgc2luY2UgdGhlIGxhc3QgcmVxdWVzdFxuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEludGVybmFsQmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAobWF4QWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbEJsb2NrTnVtYmVyLCByZXN1bHQsIGVycm9yXzUsIHJlcVRpbWUsIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3JlYWR5KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtYXhBZ2UgPiAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW50ZXJuYWxCbG9ja051bWJlcikgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbEJsb2NrTnVtYmVyID0gdGhpcy5faW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFszLCA1LCAsIDZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGludGVybmFsQmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGdldFRpbWUoKSAtIHJlc3VsdC5yZXNwVGltZSkgPD0gbWF4QWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5ibG9ja051bWJlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb28gb2xkOyBmZXRjaCBhIG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmV0Y2ggcmVqZWN0ZWQ7IGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uLCBkcm9wIHRocm91Z2ggc28gd2UgcmVwbGFjZSBpdCB3aXRoIGEgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaDsgYWxsIG90aGVycyBibG9ja2VkIHdpbGwgdGhlbiBnZXQgdGhhdCBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd29uJ3QgbWF0Y2ggdGhlIG9uZSB0aGV5IFwicmVtZW1iZXJlZFwiIGFuZCBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gaW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcVRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIgPSAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucGVyZm9ybShcImdldEJsb2NrTnVtYmVyXCIsIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHsgcmV0dXJuIChudWxsKTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoZXJyb3IpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBfYS5ibG9ja051bWJlciwgbmV0d29ya0Vycm9yID0gX2EubmV0d29ya0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5yZW1lbWJlciB0aGlzIGJhZCBpbnRlcm5hbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXR3b3JrRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKGJsb2NrTnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX3RoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7IC8vIEBUT0RPOiBTdGlsbCBuZWVkIHRoaXM/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgYmxvY2tOdW1iZXI6IGJsb2NrTnVtYmVyLCByZXFUaW1lOiByZXFUaW1lLCByZXNwVGltZTogcmVzcFRpbWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgdW5oYW5kbGVkIGV4Y2VwdGlvbnM7IGlmIG5lZWRlZCB0aGV5IGFyZSBoYW5kbGVkIGVsc2Ugd2hlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlci5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBudWxsIHRoZSBkZWFkIChyZWplY3RlZCkgZmV0Y2gsIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLmJsb2NrTnVtYmVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb2xsSWQsIHJ1bm5lcnMsIGJsb2NrTnVtYmVyLCBlcnJvcl82LCBpO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbGxJZCA9IG5leHRQb2xsSWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgLyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzYgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcl82KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgYSBwb2xsIGV2ZW50IGFmdGVyIHdlIGhhdmUgdGhlIGxhdGVzdCAoZmFzdCkgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwb2xsXCIsIHBvbGxJZCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJsb2NrIGhhcyBub3QgY2hhbmdlZCwgbWVoLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09PSB0aGlzLl9sYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgcG9sbGluZyBjeWNsZSwgdHJpZ2dlciBhIFwiYmxvY2tcIiBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkLmJsb2NrID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoKHRoaXMuX2VtaXR0ZWQuYmxvY2spIC0gYmxvY2tOdW1iZXIpID4gMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHMgKGVtaXR0ZWQ9XCIgKyB0aGlzLl9lbWl0dGVkLmJsb2NrICsgXCIgYmxvY2tOdW1iZXJcIiArIGJsb2NrTnVtYmVyICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGxvZ2dlci5tYWtlRXJyb3IoXCJuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYmxvY2tTa2V3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tOdW1iZXI6IHRoaXMuX2VtaXR0ZWQuYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSB0aGlzLl9lbWl0dGVkLmJsb2NrICsgMTsgaSA8PSBibG9ja051bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbWl0dGVkIGJsb2NrIHdhcyB1cGRhdGVkLCBjaGVjayBmb3Igb2Jzb2xldGUgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayAhPT0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZW1pdHRlZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBldmVudCBkb2VzIG5vdCBleHBpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsb2NrIHdlIHdlcmUgYXQgd2hlbiB3ZSBlbWl0dGVkIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50QmxvY2tOdW1iZXIgPSBfdGhpcy5fZW1pdHRlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgZ2FyYmFnZSBjb2xsZWN0IHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIGJsb2NrcyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGJ5IHRoZSBQcm92aWRlciB3aGVuIHNldHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJwZW5kaW5nXCIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEJsb2NrTnVtYmVyID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2aWN0IGFueSB0cmFuc2FjdGlvbiBoYXNoZXMgb3IgYmxvY2sgaGFzaGVzIG92ZXIgMTIgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9sZCwgc2luY2UgdGhleSBzaG91bGQgbm90IHJldHVybiBudWxsIGFueXdheXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIC0gZXZlbnRCbG9ja051bWJlciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2VtaXR0ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgcG9sbGluZyBjeWNsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RCbG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCB0cmFuc2FjdGlvbiBoYXNoZXMgd2UgYXJlIHdhaXRpbmcgb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2hfMiA9IGV2ZW50Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVubmVyID0gX3RoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2hfMikudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCB8fCByZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0dGVkW1widDpcIiArIGhhc2hfMl0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoaGFzaF8yLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyXzEgPSBldmVudC5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfMS5mcm9tQmxvY2sgPSBfdGhpcy5fbGFzdEJsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcl8xLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW5uZXIgPSBfdGhpcy5nZXRMb2dzKGZpbHRlcl8xKS50aGVuKGZ1bmN0aW9uIChsb2dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJiOlwiICsgbG9nLmJsb2NrSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0dGVkW1widDpcIiArIGxvZy50cmFuc2FjdGlvbkhhc2hdID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGZpbHRlcl8xLCBsb2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIGFsbCBldmVudHMgZm9yIHRoaXMgbG9vcCBoYXZlIGJlZW4gcHJvY2Vzc2VkLCBlbWl0IFwiZGlkUG9sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChydW5uZXJzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUucmVzZXRFdmVudHNCbG9jayA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJuZXR3b3JrXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBxdWVyeSB0aGUgbmV0d29yayBpZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgLy8gY2FuIGNoYW5nZSwgc3VjaCBhcyB3aGVuIGNvbm5lY3RlZCB0byBhIEpTT04tUlBDIGJhY2tlbmRcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IG5ldHdvcmsgZGV0ZWN0aW9uXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicHJvdmlkZXIuZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcmssIGN1cnJlbnROZXR3b3JrLCBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcmVhZHkoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRldGVjdE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROZXR3b3JrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYW55TmV0d29yaykgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gY3VycmVudE5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgaW50ZXJuYWwgYmxvY2sgbnVtYmVyIGd1YXJkcyBhbmQgY2FjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IC0yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJuZXR3b3JrXCIgZXZlbnQgTVVTVCBoYXBwZW4gYmVmb3JlIHRoaXMgbWV0aG9kIHJlc29sdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBhbnkgZXZlbnRzIGhhdmUgYSBjaGFuY2UgdG8gdW5yZWdpc3Rlciwgc28gd2Ugc3RhbGwgYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQgbG9vcCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gL3RoaXMvIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgY3VycmVudE5ldHdvcmssIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGwoMCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fbmV0d29ya107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbG9nZ2VyLm1ha2VFcnJvcihcInVuZGVybHlpbmcgbmV0d29yayBjaGFuZ2VkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGVkTmV0d29yazogY3VycmVudE5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldHdvcmtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcImJsb2NrTnVtYmVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpLnRoZW4oZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2Zhc3RCbG9ja051bWJlciAhPSBudWxsKSA/IHRoaXMuX2Zhc3RCbG9ja051bWJlciA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9wb2xsZXIgIT0gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IF90aGlzLnBvbGwoKTsgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYm9vdHN0cmFwUG9sbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib290c3RyYXBQb2xsID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBibG9jayBhZGRpdGlvbmFsIHBvbGxzIHVudGlsIHRoZSBwb2xsaW5nIGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBkb25lLCB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZyB0aGUgcG9sbCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwb2xsaW5nIHdhcyBkaXNhYmxlZCwgc29tZXRoaW5nIG1heSByZXF1aXJlIGEgcG9rZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHN0YXJ0aW5nIHRoZSBib290c3RyYXAgcG9sbCBhbmQgaXQgd2FzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYm9vdHN0cmFwUG9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJwb2xsaW5nSW50ZXJ2YWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDw9IDAgfHwgcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvbGxpbmcgaW50ZXJ2YWxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBfdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRGYXN0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub3cgPSBnZXRUaW1lKCk7XG4gICAgICAgIC8vIFN0YWxlIGJsb2NrIG51bWJlciwgcmVxdWVzdCBhIG5ld2VyIHZhbHVlXG4gICAgICAgIGlmICgobm93IC0gdGhpcy5fZmFzdFF1ZXJ5RGF0ZSkgPiAyICogdGhpcy5fcG9sbGluZ0ludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gbm93O1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiBfdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9mYXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3NldEZhc3RCbG9ja051bWJlciA9IGZ1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICAvLyBPbGRlciBibG9jaywgbWF5YmUgYSBzdGFsZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBOZXdlciBibG9jayBudW1iZXIsIHVzZSAgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLndhaXRGb3JUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCAoY29uZmlybWF0aW9ucyA9PSBudWxsKSA/IDEgOiBjb25maXJtYXRpb25zLCB0aW1lb3V0IHx8IDAsIG51bGwpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3dhaXRGb3JUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQsIHJlcGxhY2VhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWNlaXB0O1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNlaXB0IGlzIGFscmVhZHkgZ29vZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZWNlaXB0ID8gcmVjZWlwdC5jb25maXJtYXRpb25zIDogMCkgPj0gY29uZmlybWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZWNlaXB0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvbGwgdW50aWwgdGhlIHJlY2VpcHQgaXMgZ29vZC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmNlbEZ1bmNzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5RG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHsgZnVuYygpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbmVkSGFuZGxlciA9IGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zIDwgY29uZmlybWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub24odHJhbnNhY3Rpb25IYXNoLCBtaW5lZEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKGZ1bmN0aW9uICgpIHsgX3RoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLCBtaW5lZEhhbmRsZXIpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdEJsb2NrTnVtYmVyXzEgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYW5uZWRCbG9ja18xID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlSGFuZGxlcl8xID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmQ7IHRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIG9mIGEgZmF1bHQsIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCB0cmFkZSBvZmYgYSBsaXR0bGUgYml0IG9mIGxhdGVuY3kgZm9yIG1vcmUgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgYW5kIGZld2VyIEpTT04tUlBDIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGwoMTAwMCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmQ7IHRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIG9mIGEgZmF1bHQsIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCB0cmFkZSBvZmYgYSBsaXR0bGUgYml0IG9mIGxhdGVuY3kgZm9yIG1vcmUgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgYW5kIGZld2VyIEpTT04tUlBDIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChyZXBsYWNlYWJsZS5mcm9tKS50aGVuKGZ1bmN0aW9uIChub25jZSkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluZWQsIGJsb2NrLCB0aSwgdHgsIHJlY2VpcHRfMSwgcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5vbmNlIDw9IHJlcGxhY2VhYmxlLm5vbmNlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja051bWJlcl8xID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmVkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgc2Nhbm5pbmcuIFdlIHN0YXJ0IGEgbGl0dGxlIGVhcmxpZXIgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lnZ2xlIHJvb20gaGVyZSB0byBoYW5kbGUgdGhlIGV2ZW50dWFsbHkgY29uc2lzdGVudCBuYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmxvY2tjaGFpbiAoZS5nLiB0aGUgZ2V0VHJhbnNhY3Rpb25Db3VudCB3YXMgZm9yIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrXzEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrXzEgPSBsYXN0QmxvY2tOdW1iZXJfMSAtIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrXzEgPCByZXBsYWNlYWJsZS5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrXzEgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHNjYW5uZWRCbG9ja18xIDw9IGJsb2NrTnVtYmVyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoc2Nhbm5lZEJsb2NrXzEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IGJsb2NrLnRyYW5zYWN0aW9uc1t0aV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBtaW5lZCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LmZyb20gPT09IHJlcGxhY2VhYmxlLmZyb20gJiYgdHgubm9uY2UgPT09IHJlcGxhY2VhYmxlLm5vbmNlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24odHguaGFzaCwgY29uZmlybWF0aW9ucyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdF8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIHJlamVjdGVkIChwcm9sbHkgYSB0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHJlcGxhY2VhYmxlLmRhdGEgJiYgdHgudG8gPT09IHJlcGxhY2VhYmxlLnRvICYmIHR4LnZhbHVlLmVxKHJlcGxhY2VhYmxlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsYWluIHdoeSB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVFJBTlNBQ1RJT05fUkVQTEFDRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdF8xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2tfMSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcihcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgdGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lcl8xID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXQgZXhjZWVkZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXJfMS51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyXzEudW5yZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goZnVuY3Rpb24gKCkgeyBjbGVhclRpbWVvdXQodGltZXJfMSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEdhc1ByaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldEdhc1ByaWNlXCIsIHt9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHJlc3VsdCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRHYXNQcmljZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmFsYW5jZSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRCYWxhbmNlXCIsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkNvdW50ID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMsIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uQ291bnRcIiwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHJlc3VsdCkudG9OdW1iZXIoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0Q29kZSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRDb2RlXCIsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgYnl0ZXNfMS5oZXhsaWZ5KShyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRTdG9yYWdlQXQgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMsIHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQcm9taXNlLnJlc29sdmUocG9zaXRpb24pLnRoZW4oZnVuY3Rpb24gKHApIHsgcmV0dXJuICgwLCBieXRlc18xLmhleFZhbHVlKShwKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFN0b3JhZ2VBdFwiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGJ5dGVzXzEuaGV4bGlmeSkocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IGFueSBzdWJjbGFzcyB3cmFwcGluZyBhIFRyYW5zYWN0aW9uUmVzcG9uc2VcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl93cmFwVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHgsIGhhc2gsIHN0YXJ0QmxvY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiAoMCwgYnl0ZXNfMS5oZXhEYXRhTGVuZ3RoKShoYXNoKSAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2UgLSBzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHR4O1xuICAgICAgICAvLyBDaGVjayB0aGUgaGFzaCB3ZSBleHBlY3QgaXMgdGhlIHNhbWUgYXMgdGhlIGhhc2ggdGhlIHNlcnZlciByZXBvcnRlZFxuICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiVHJhbnNhY3Rpb24gaGFzaCBtaXNtYXRjaCBmcm9tIFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbi5cIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC53YWl0ID0gZnVuY3Rpb24gKGNvbmZpcm1zLCB0aW1lb3V0KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQsIHJlY2VpcHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1zICE9PSAwICYmIHN0YXJ0QmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogdHgubm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0eC50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR4LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEJsb2NrOiBzdGFydEJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtcywgdGltZW91dCwgcmVwbGFjZW1lbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgJiYgY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBsb25nZXIgcGVuZGluZywgYWxsb3cgdGhlIHBvbGxpbmcgbG9vcCB0byBnYXJiYWdlIGNvbGxlY3QgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0eC5oYXNoXSA9IHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRyYW5zYWN0aW9uIGZhaWxlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0OiByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhleFR4LCB0eCwgYmxvY2tOdW1iZXIsIGhhc2gsIGVycm9yXzc7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKHNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uICh0KSB7IHJldHVybiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KSh0KTsgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXhUeCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbNCwgNiwgLCA3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJzZW5kVHJhbnNhY3Rpb25cIiwgeyBzaWduZWRUcmFuc2FjdGlvbjogaGV4VHggfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgYmxvY2tOdW1iZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzcudHJhbnNhY3Rpb24gPSB0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzcudHJhbnNhY3Rpb25IYXNoID0gdHguaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzLCB0eCwgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgW1wiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBfdGhpcy5fZ2V0QWRkcmVzcyh2KSA6IG51bGwpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgW1wiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidmFsdWVcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodiA/IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHYpIDogbnVsbCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJ0eXBlXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKCh2ICE9IG51bGwpID8gdiA6IG51bGwpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguYWNjZXNzTGlzdCA9IHRoaXMuZm9ybWF0dGVyLmFjY2Vzc0xpc3QodmFsdWVzLmFjY2Vzc0xpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID8gKDAsIGJ5dGVzXzEuaGV4bGlmeSkodikgOiBudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLnRyYW5zYWN0aW9uUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHR4KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZmlsdGVyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJibG9ja0hhc2hcIiwgXCJ0b3BpY3NcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJmcm9tQmxvY2tcIiwgXCJ0b0Jsb2NrXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBfdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IHRoaXMuZm9ybWF0dGVyKS5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcHJvcGVydGllc18xLnJlc29sdmVQcm9wZXJ0aWVzKShyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiY2FsbFwiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIGJ5dGVzXzEuaGV4bGlmeSkocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZXN0aW1hdGVHYXMgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImVzdGltYXRlR2FzXCIsIHBhcmFtcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShyZXN1bHQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgYWRkcmVzc09yTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NPck5hbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JOYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWUoXCIgKyBKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKSArIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0QmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tIYXNoT3JCbG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIsIHBhcmFtcywgX2EsIGVycm9yXzg7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJsb2NrSGFzaE9yQmxvY2tUYWddO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0hhc2hPckJsb2NrVGFnID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSAtMTI4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVUcmFuc2FjdGlvbnM6ICEhaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGJsb2NrSGFzaE9yQmxvY2tUYWcsIDMyKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoT3JCbG9ja1RhZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja0hhc2hPckJsb2NrVGFnKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmJsb2NrVGFnID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBwYXJzZUludChwYXJhbXMuYmxvY2tUYWcuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfOCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrIGhhc2ggb3IgYmxvY2sgdGFnXCIsIFwiYmxvY2tIYXNoT3JCbG9ja1RhZ1wiLCBibG9ja0hhc2hPckJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCAoMCwgd2ViXzEucG9sbCkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9jaywgYmxvY2tOdW1iZXJfMSwgaSwgdHgsIGNvbmZpcm1hdGlvbnMsIGJsb2NrV2l0aFR4cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja1wiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbG9jayB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NraGFzaGVzLCBpZiB3ZSBkaWRuJ3Qgc2F5IGl0IGV4aXN0ZWQsIHRoYXQgYmxvY2toYXNoIG1heVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgZXhpc3QuIElmIHdlIGRpZCBzZWUgaXQgdGhvdWdoLCBwZXJoYXBzIGZyb20gYSBsb2csIHdlIGtub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgZXhpc3RzLCBhbmQgdGhpcyBub2RlIGlzIGp1c3Qgbm90IGNhdWdodCB1cCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tIYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1wiYjpcIiArIHBhcmFtcy5ibG9ja0hhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NrIHRhZ3MsIGlmIHdlIGFyZSBhc2tpbmcgZm9yIGEgZnV0dXJlIGJsb2NrLCB3ZSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+IHRoaXMuX2VtaXR0ZWQuYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0cnkgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZVRyYW5zYWN0aW9ucykgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJfMSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBibG9jay50cmFuc2FjdGlvbnMubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBibG9jay50cmFuc2FjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJsb2NrTnVtYmVyXzEgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlcl8xIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrV2l0aFR4cyA9IHRoaXMuZm9ybWF0dGVyLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tXaXRoVHhzLnRyYW5zYWN0aW9ucyA9IGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMubWFwKGZ1bmN0aW9uICh0eCkgeyByZXR1cm4gX3RoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBibG9ja1dpdGhUeHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mb3JtYXR0ZXIuYmxvY2soYmxvY2spXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChibG9ja0hhc2hPckJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgdHJ1ZSkpO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB3ZWJfMS5wb2xsKShmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIHR4LCBibG9ja051bWJlciwgY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25cIiwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4LmJsb2NrTnVtYmVyID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9LCB7IG9uY2VQb2xsOiB0aGlzIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgwLCB3ZWJfMS5wb2xsKShmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIHJlY2VpcHQsIGJsb2NrTnVtYmVyLCBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJnZXRoLWV0Y1wiIHJldHVybnMgcmVjZWlwdHMgYmVmb3JlIHRoZXkgYXJlIHJlYWR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSB0aGlzLmZvcm1hdHRlci5yZWNlaXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlY2VpcHQuY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlY2VpcHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgeyBvbmNlUG9sbDogdGhpcyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRMb2dzID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCBsb2dzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dzLmZvckVhY2goZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cucmVtb3ZlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZm9ybWF0dGVyXzEuRm9ybWF0dGVyLmFycmF5T2YodGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nLmJpbmQodGhpcy5mb3JtYXR0ZXIpKShsb2dzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRFdGhlclByaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucGVyZm9ybShcImdldEV0aGVyUHJpY2VcIiwge30pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRCbG9ja1RhZyA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGJsb2NrVGFnXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWcgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiAmJiBibG9ja1RhZyA8IDApKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCbG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrVGFnKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRSZXNvbHZlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzLCBlcnJvcl85O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldFJlc29sdmVyKG5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFJlc29sdmVyKHRoaXMsIGFkZHJlc3MsIG5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfOSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcl85LmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcl85O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRSZXNvbHZlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXR3b3JrLCB0cmFuc2FjdGlvbiwgX2EsIF9iLCBlcnJvcl8xMDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmsuZW5zQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwiRU5TXCIsIG5ldHdvcms6IG5ldHdvcmsubmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBuZXR3b3JrLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgwMTc4YjhiZlwiICsgKDAsIGhhc2hfMS5uYW1laGFzaCkobmFtZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLmNhbGxBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsKHRyYW5zYWN0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xMCA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcl8xMC5jb2RlID09PSBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMTA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUucmVzb2x2ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZXI7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBub3RoaW5nIHRvIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVzb2x2ZSh0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpcyBpcyBhIGhleHN0cmluZywgdGhlIGFkZHJlc3MgaXMgYmFkIChTZWUgIzY5NClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRSZXNvbHZlcihuYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVyLmdldEFkZHJlc3MoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5sb29rdXBBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJldmVyc2VOYW1lLCByZXNvbHZlckFkZHJlc3MsIGJ5dGVzLCBfYSwgbGVuZ3RoLCBuYW1lLCBhZGRyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBhZGRyZXNzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRSZXNvbHZlcihyZXZlcnNlTmFtZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlckFkZHJlc3MgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gYnl0ZXNfMS5hcnJheWlmeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArICgwLCBoYXNoXzEubmFtZWhhc2gpKHJldmVyc2VOYW1lKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBkeW5hbWljIHN0cmluZyBwb2ludGVyICgweDIwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8IDMyIHx8ICFiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShieXRlcy5zbGljZSgwLCAzMikpLmVxKDMyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgbGVuZ3RoLXByZWZpeGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20oYnl0ZXMuc2xpY2UoMCwgMzIpKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZW5ndGggbG9uZ2VyIHRoYW4gYXZhaWxhYmxlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gKDAsIHN0cmluZ3NfMS50b1V0ZjhTdHJpbmcpKGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXNvbHZlTmFtZShuYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciAhPSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QXZhdGFyID0gZnVuY3Rpb24gKG5hbWVPckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVyLCBhZGRyZXNzLCByZXZlcnNlTmFtZSwgcmVzb2x2ZXJBZGRyZXNzLCBhdmF0YXI7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShuYW1lT3JBZGRyZXNzKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lT3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0UmVzb2x2ZXIocmV2ZXJzZU5hbWUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXJBZGRyZXNzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCByZXNvbHZlckFkZHJlc3MsIFwiX1wiLCBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZU9yQWRkcmVzcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFTlMgbmFtZTsgZm9yd2FyZCBsb29rdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNvbHZlci5nZXRBdmF0YXIoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YXRhciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhdmF0YXIudXJsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1ldGhvZCArIFwiIG5vdCBpbXBsZW1lbnRlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwgeyBvcGVyYXRpb246IG1ldGhvZCB9KTtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucG9sbGFibGUoKTsgfSkubGVuZ3RoID4gMCk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucG9sbGFibGUoKTsgfSkubGVuZ3RoID4gMCk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KGdldEV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IF90aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgIH07XG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5saXN0ZW5lcjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5saXN0ZW5lcjsgfSk7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RvcHBlZCA9IFtdO1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IF90aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYWdfMSA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VQcm92aWRlcjtcbn0oYWJzdHJhY3RfcHJvdmlkZXJfMS5Qcm92aWRlcikpO1xuZXhwb3J0cy5CYXNlUHJvdmlkZXIgPSBCYXNlUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/base-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/cloudflare-provider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/cloudflare-provider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CloudflareProvider = void 0;\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar CloudflareProvider = /** @class */ (function (_super) {\n    __extends(CloudflareProvider, _super);\n    function CloudflareProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CloudflareProvider.getApiKey = function (apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    };\n    CloudflareProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    };\n    CloudflareProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var block;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(method === \"getBlockNumber\")) return [3 /*break*/, 2];\n                        return [4 /*yield*/, _super.prototype.perform.call(this, \"getBlock\", { blockTag: \"latest\" })];\n                    case 1:\n                        block = _a.sent();\n                        return [2 /*return*/, block.number];\n                    case 2: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n                }\n            });\n        });\n    };\n    return CloudflareProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.CloudflareProvider = CloudflareProvider;\n//# sourceMappingURL=cloudflare-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Nsb3VkZmxhcmUtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQiw4QkFBOEIsbUJBQU8sQ0FBQywrSEFBeUI7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLDBHQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxxR0FBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysb0JBQW9CO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvY2xvdWRmbGFyZS1wcm92aWRlci5qcz80MWJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IHZvaWQgMDtcbnZhciB1cmxfanNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBDbG91ZGZsYXJlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsb3VkZmxhcmVQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbG91ZGZsYXJlUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2xvdWRmbGFyZVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcbiAgICAgICAgaWYgKGFwaUtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYXBpS2V5IG5vdCBzdXBwb3J0ZWQgZm9yIGNsb3VkZmxhcmVcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENsb3VkZmxhcmVQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHZhciBob3N0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2Nsb3VkZmxhcmUtZXRoLmNvbS9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfTtcbiAgICBDbG91ZGZsYXJlUHJvdmlkZXIucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWV0aG9kID09PSBcImdldEJsb2NrTnVtYmVyXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIFwiZ2V0QmxvY2tcIiwgeyBibG9ja1RhZzogXCJsYXRlc3RcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJsb2NrLm51bWJlcl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIG1ldGhvZCwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENsb3VkZmxhcmVQcm92aWRlcjtcbn0odXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IENsb3VkZmxhcmVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3VkZmxhcmUtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/cloudflare-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/etherscan-provider.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/etherscan-provider.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EtherscanProvider = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/base-provider.js\");\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    var result = {};\n    for (var key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        var value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = (0, bytes_1.hexValue)((0, bytes_1.hexlify)(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + (0, transactions_1.accessListify)(value).map(function (set) {\n                return \"{address:\\\"\" + set.address + \"\\\",storageKeys:[\\\"\" + set.storageKeys.join('\",\"') + \"\\\"]}\";\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = (0, bytes_1.hexlify)(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || result.message != \"OK\") {\n        var error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        var error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        var error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        var error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nvar defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === logger_1.Logger.errors.SERVER_ERROR) {\n        var e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            var data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if ((0, bytes_1.isHexString)(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", logger_1.Logger.errors.CALL_EXCEPTION, {\n                error: error,\n                data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    var message = error.message;\n    if (error.code === logger_1.Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", logger_1.Logger.errors.NONCE_EXPIRED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    throw error;\n}\nvar EtherscanProvider = /** @class */ (function (_super) {\n    __extends(EtherscanProvider, _super);\n    function EtherscanProvider(network, apiKey) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, EtherscanProvider);\n        _this = _super.call(this, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"baseUrl\", _this.getBaseUrl());\n        (0, properties_1.defineReadOnly)(_this, \"apiKey\", apiKey || defaultApiKey);\n        return _this;\n    }\n    EtherscanProvider.prototype.getBaseUrl = function () {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    };\n    EtherscanProvider.prototype.getUrl = function (module, params) {\n        var query = Object.keys(params).reduce(function (accum, key) {\n            var value = params[key];\n            if (value != null) {\n                accum += \"&\" + key + \"=\" + value;\n            }\n            return accum;\n        }, \"\");\n        var apiKey = ((this.apiKey) ? \"&apikey=\" + this.apiKey : \"\");\n        return this.baseUrl + \"/api?module=\" + module + query + apiKey;\n    };\n    EtherscanProvider.prototype.getPostUrl = function () {\n        return this.baseUrl + \"/api\";\n    };\n    EtherscanProvider.prototype.getPostData = function (module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    };\n    EtherscanProvider.prototype.fetch = function (module, params, post) {\n        return __awaiter(this, void 0, void 0, function () {\n            var url, payload, procFunc, connection, payloadStr, result;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        url = (post ? this.getPostUrl() : this.getUrl(module, params));\n                        payload = (post ? this.getPostData(module, params) : null);\n                        procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            request: url,\n                            provider: this\n                        });\n                        connection = {\n                            url: url,\n                            throttleSlotInterval: 1000,\n                            throttleCallback: function (attempt, url) {\n                                if (_this.isCommunityResource()) {\n                                    (0, formatter_1.showThrottleMessage)();\n                                }\n                                return Promise.resolve(true);\n                            }\n                        };\n                        payloadStr = null;\n                        if (payload) {\n                            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                            payloadStr = Object.keys(payload).map(function (key) {\n                                return key + \"=\" + payload[key];\n                            }).join(\"&\");\n                        }\n                        return [4 /*yield*/, (0, web_1.fetchJson)(connection, payloadStr, procFunc || getJsonResult)];\n                    case 1:\n                        result = _a.sent();\n                        this.emit(\"debug\", {\n                            action: \"response\",\n                            request: url,\n                            response: (0, properties_1.deepCopy)(result),\n                            provider: this\n                        });\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    EtherscanProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.network];\n            });\n        });\n    };\n    EtherscanProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, postData, error_1, postData, error_2, args, topic0, logs, blocks, i, log, block, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = method;\n                        switch (_a) {\n                            case \"getBlockNumber\": return [3 /*break*/, 1];\n                            case \"getGasPrice\": return [3 /*break*/, 2];\n                            case \"getBalance\": return [3 /*break*/, 3];\n                            case \"getTransactionCount\": return [3 /*break*/, 4];\n                            case \"getCode\": return [3 /*break*/, 5];\n                            case \"getStorageAt\": return [3 /*break*/, 6];\n                            case \"sendTransaction\": return [3 /*break*/, 7];\n                            case \"getBlock\": return [3 /*break*/, 8];\n                            case \"getTransaction\": return [3 /*break*/, 9];\n                            case \"getTransactionReceipt\": return [3 /*break*/, 10];\n                            case \"call\": return [3 /*break*/, 11];\n                            case \"estimateGas\": return [3 /*break*/, 15];\n                            case \"getLogs\": return [3 /*break*/, 19];\n                            case \"getEtherPrice\": return [3 /*break*/, 26];\n                        }\n                        return [3 /*break*/, 28];\n                    case 1: return [2 /*return*/, this.fetch(\"proxy\", { action: \"eth_blockNumber\" })];\n                    case 2: return [2 /*return*/, this.fetch(\"proxy\", { action: \"eth_gasPrice\" })];\n                    case 3: \n                    // Returns base-10 result\n                    return [2 /*return*/, this.fetch(\"account\", {\n                            action: \"balance\",\n                            address: params.address,\n                            tag: params.blockTag\n                        })];\n                    case 4: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getTransactionCount\",\n                            address: params.address,\n                            tag: params.blockTag\n                        })];\n                    case 5: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getCode\",\n                            address: params.address,\n                            tag: params.blockTag\n                        })];\n                    case 6: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getStorageAt\",\n                            address: params.address,\n                            position: params.position,\n                            tag: params.blockTag\n                        })];\n                    case 7: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_sendRawTransaction\",\n                            hex: params.signedTransaction\n                        }, true).catch(function (error) {\n                            return checkError(\"sendTransaction\", error, params.signedTransaction);\n                        })];\n                    case 8:\n                        if (params.blockTag) {\n                            return [2 /*return*/, this.fetch(\"proxy\", {\n                                    action: \"eth_getBlockByNumber\",\n                                    tag: params.blockTag,\n                                    boolean: (params.includeTransactions ? \"true\" : \"false\")\n                                })];\n                        }\n                        throw new Error(\"getBlock by blockHash not implemented\");\n                    case 9: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getTransactionByHash\",\n                            txhash: params.transactionHash\n                        })];\n                    case 10: return [2 /*return*/, this.fetch(\"proxy\", {\n                            action: \"eth_getTransactionReceipt\",\n                            txhash: params.transactionHash\n                        })];\n                    case 11:\n                        if (params.blockTag !== \"latest\") {\n                            throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                        }\n                        postData = getTransactionPostData(params.transaction);\n                        postData.module = \"proxy\";\n                        postData.action = \"eth_call\";\n                        _c.label = 12;\n                    case 12:\n                        _c.trys.push([12, 14, , 15]);\n                        return [4 /*yield*/, this.fetch(\"proxy\", postData, true)];\n                    case 13: return [2 /*return*/, _c.sent()];\n                    case 14:\n                        error_1 = _c.sent();\n                        return [2 /*return*/, checkError(\"call\", error_1, params.transaction)];\n                    case 15:\n                        postData = getTransactionPostData(params.transaction);\n                        postData.module = \"proxy\";\n                        postData.action = \"eth_estimateGas\";\n                        _c.label = 16;\n                    case 16:\n                        _c.trys.push([16, 18, , 19]);\n                        return [4 /*yield*/, this.fetch(\"proxy\", postData, true)];\n                    case 17: return [2 /*return*/, _c.sent()];\n                    case 18:\n                        error_2 = _c.sent();\n                        return [2 /*return*/, checkError(\"estimateGas\", error_2, params.transaction)];\n                    case 19:\n                        args = { action: \"getLogs\" };\n                        if (params.filter.fromBlock) {\n                            args.fromBlock = checkLogTag(params.filter.fromBlock);\n                        }\n                        if (params.filter.toBlock) {\n                            args.toBlock = checkLogTag(params.filter.toBlock);\n                        }\n                        if (params.filter.address) {\n                            args.address = params.filter.address;\n                        }\n                        // @TODO: We can handle slightly more complicated logs using the logs API\n                        if (params.filter.topics && params.filter.topics.length > 0) {\n                            if (params.filter.topics.length > 1) {\n                                logger.throwError(\"unsupported topic count\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                            }\n                            if (params.filter.topics.length === 1) {\n                                topic0 = params.filter.topics[0];\n                                if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                    logger.throwError(\"unsupported topic format\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                                }\n                                args.topic0 = topic0;\n                            }\n                        }\n                        return [4 /*yield*/, this.fetch(\"logs\", args)];\n                    case 20:\n                        logs = _c.sent();\n                        blocks = {};\n                        i = 0;\n                        _c.label = 21;\n                    case 21:\n                        if (!(i < logs.length)) return [3 /*break*/, 25];\n                        log = logs[i];\n                        if (log.blockHash != null) {\n                            return [3 /*break*/, 24];\n                        }\n                        if (!(blocks[log.blockNumber] == null)) return [3 /*break*/, 23];\n                        return [4 /*yield*/, this.getBlock(log.blockNumber)];\n                    case 22:\n                        block = _c.sent();\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                        _c.label = 23;\n                    case 23:\n                        log.blockHash = blocks[log.blockNumber];\n                        _c.label = 24;\n                    case 24:\n                        i++;\n                        return [3 /*break*/, 21];\n                    case 25: return [2 /*return*/, logs];\n                    case 26:\n                        if (this.network.name !== \"homestead\") {\n                            return [2 /*return*/, 0.0];\n                        }\n                        _b = parseFloat;\n                        return [4 /*yield*/, this.fetch(\"stats\", { action: \"ethprice\" })];\n                    case 27: return [2 /*return*/, _b.apply(void 0, [(_c.sent()).ethusd])];\n                    case 28: return [3 /*break*/, 29];\n                    case 29: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n                }\n            });\n        });\n    };\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    EtherscanProvider.prototype.getHistory = function (addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var params, result;\n            var _a;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = {\n                            action: \"txlist\"\n                        };\n                        return [4 /*yield*/, this.resolveName(addressOrName)];\n                    case 1:\n                        params = (_a.address = (_b.sent()),\n                            _a.startblock = ((startBlock == null) ? 0 : startBlock),\n                            _a.endblock = ((endBlock == null) ? 99999999 : endBlock),\n                            _a.sort = \"asc\",\n                            _a);\n                        return [4 /*yield*/, this.fetch(\"account\", params)];\n                    case 2:\n                        result = _b.sent();\n                        return [2 /*return*/, result.map(function (tx) {\n                                [\"contractAddress\", \"to\"].forEach(function (key) {\n                                    if (tx[key] == \"\") {\n                                        delete tx[key];\n                                    }\n                                });\n                                if (tx.creates == null && tx.contractAddress != null) {\n                                    tx.creates = tx.contractAddress;\n                                }\n                                var item = _this.formatter.transactionResponse(tx);\n                                if (tx.timeStamp) {\n                                    item.timestamp = parseInt(tx.timeStamp);\n                                }\n                                return item;\n                            })];\n                }\n            });\n        });\n    };\n    EtherscanProvider.prototype.isCommunityResource = function () {\n        return (this.apiKey === defaultApiKey);\n    };\n    return EtherscanProvider;\n}(base_provider_1.BaseProvider));\nexports.EtherscanProvider = EtherscanProvider;\n//# sourceMappingURL=etherscan-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2V0aGVyc2Nhbi1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGNBQWMsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsa0hBQTJCO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLHNIQUE2QjtBQUMxRCxZQUFZLG1CQUFPLENBQUMsb0dBQW9CO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMscUdBQVk7QUFDckM7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQywrR0FBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxSEFBcUg7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0ZBQXNGO0FBQy9HLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvREFBb0Q7QUFDdkc7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsMkJBQTJCO0FBQ25HLHdFQUF3RSx3QkFBd0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkgsOEJBQThCO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0lBQWtJLGdCQUFnQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsb0JBQW9CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2V0aGVyc2Nhbi1wcm92aWRlci5qcz8xNTQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gdm9pZCAwO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCIpO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbnZhciBmb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBiYXNlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9iYXNlLXByb3ZpZGVyXCIpO1xuLy8gVGhlIHRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBjYWxscyBpbiBQcm92aWRlclxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YSh0cmFuc2FjdGlvbikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNhY3Rpb25ba2V5XTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFF1YW50aXR5LXR5cGVzIHJlcXVpcmUgbm8gbGVhZGluZyB6ZXJvLCB1bmxlc3MgMFxuICAgICAgICBpZiAoeyB0eXBlOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG1heEZlZVBlckdzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZSwgbm9uY2U6IHRydWUsIHZhbHVlOiB0cnVlIH1ba2V5XSkge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgYnl0ZXNfMS5oZXhWYWx1ZSkoKDAsIGJ5dGVzXzEuaGV4bGlmeSkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiYWNjZXNzTGlzdFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiW1wiICsgKDAsIHRyYW5zYWN0aW9uc18xLmFjY2Vzc0xpc3RpZnkpKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInthZGRyZXNzOlxcXCJcIiArIHNldC5hZGRyZXNzICsgXCJcXFwiLHN0b3JhZ2VLZXlzOltcXFwiXCIgKyBzZXQuc3RvcmFnZUtleXMuam9pbignXCIsXCInKSArIFwiXFxcIl19XCI7XG4gICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgYnl0ZXNfMS5oZXhsaWZ5KSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyBnZXRMb2dzLCBnZXRIaXN0b3J5IGhhdmUgd2VpcmQgc3VjY2VzcyByZXNwb25zZXNcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAwICYmIChyZXN1bHQubWVzc2FnZSA9PT0gXCJObyByZWNvcmRzIGZvdW5kXCIgfHwgcmVzdWx0Lm1lc3NhZ2UgPT09IFwiTm8gdHJhbnNhY3Rpb25zIGZvdW5kXCIpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSAxIHx8IHJlc3VsdC5tZXNzYWdlICE9IFwiT0tcIikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO1xuICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpZiAoKHJlc3VsdC5yZXN1bHQgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwKSB7XG4gICAgICAgICAgICBlcnJvci50aHJvdHRsZVJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRKc29uUmVzdWx0KHJlc3VsdCkge1xuICAgIC8vIFRoaXMgcmVzcG9uc2UgaW5kaWNhdGVzIHdlIGFyZSBiZWluZyB0aHJvdHRsZWRcbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdGF0dXMgPT0gMCAmJiByZXN1bHQubWVzc2FnZSA9PSBcIk5PVE9LXCIgJiYgKHJlc3VsdC5yZXN1bHQgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcInRocm90dGxlZCByZXNwb25zZVwiKTtcbiAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgZXJyb3IudGhyb3R0bGVSZXRyeSA9IHRydWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xuICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO1xuICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByZXN1bHQuZXJyb3IuY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmVycm9yLmRhdGEpIHtcbiAgICAgICAgICAgIGVycm9yLmRhdGEgPSByZXN1bHQuZXJyb3IuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG59XG4vLyBUaGUgYmxvY2tUYWcgd2FzIG5vcm1hbGl6ZWQgYXMgYSBzdHJpbmcgYnkgdGhlIFByb3ZpZGVyIHByZS1wZXJmb3JtIG9wZXJhdGlvbnNcbmZ1bmN0aW9uIGNoZWNrTG9nVGFnKGJsb2NrVGFnKSB7XG4gICAgaWYgKGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwZW5kaW5nIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIikge1xuICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChibG9ja1RhZy5zdWJzdHJpbmcoMiksIDE2KTtcbn1cbnZhciBkZWZhdWx0QXBpS2V5ID0gXCI5RDEzWkU3WFNCVEo5NE45Qk5KMk1BMzNWTUFZMllQSVJCXCI7XG5mdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHRyYW5zYWN0aW9uKSB7XG4gICAgLy8gVW5kbyB0aGUgXCJjb252ZW5pZW5jZVwiIHNvbWUgbm9kZXMgYXJlIGF0dGVtcHRpbmcgdG8gcHJldmVudCBiYWNrd2FyZHNcbiAgICAvLyBpbmNvbXBhdGliaWxpdHk7IG1heWJlIGZvciB2NiBjb25zaWRlciBmb3J3YXJkaW5nIHJldmVydHMgYXMgZXJyb3JzXG4gICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgJiYgZXJyb3IuY29kZSA9PT0gbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcbiAgICAgICAgdmFyIGUgPSBlcnJvci5lcnJvcjtcbiAgICAgICAgLy8gRXRoZXJzY2FuIGtlZXBzIGNoYW5naW5nIHRoZWlyIHN0cmluZ1xuICAgICAgICBpZiAoZSAmJiAoZS5tZXNzYWdlLm1hdGNoKC9yZXZlcnRlZC9pKSB8fCBlLm1lc3NhZ2UubWF0Y2goL1ZNIGV4ZWN1dGlvbiBlcnJvci9pKSkpIHtcbiAgICAgICAgICAgIC8vIEV0aGVyc2NhbiBwcmVmaXhlcyB0aGUgZGF0YSBsaWtlIFwiUmV2ZXJ0ZWQgMHgxMjM0XCJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gXCIweFwiICsgZGF0YS5yZXBsYWNlKC9eLioweC9pLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyByZXZlcnQgZGF0YSBpbiBjYWxsIGV4Y2VwdGlvblwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiMHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSBtZXNzYWdlIGZyb20gYW55IG5lc3RlZCBlcnJvciBzdHJ1Y3R1cmVcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG4gICAgICAgIGlmIChlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gXCJJbnN1ZmZpY2llbnQgZnVuZHMuIFRoZSBhY2NvdW50IHlvdSB0cmllZCB0byBzZW5kIHRyYW5zYWN0aW9uIGZyb20gZG9lcyBub3QgaGF2ZSBlbm91Z2ggZnVuZHMuIFJlcXVpcmVkIDIxNDY0MDAwMDAwMDAwIGFuZCBnb3Q6IDBcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcIlRyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC5cIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9zYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWR8dHJhbnNhY3Rpb24gbm9uY2UgaXMgdG9vIGxvd3xub25jZSB0b28gbG93LykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJUcmFuc2FjdGlvbiBnYXMgcHJpY2UgaXMgdG9vIGxvdy4gVGhlcmUgaXMgYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UgaW4gdGhlIHF1ZXVlLiBUcnkgaW5jcmVhc2luZyB0aGUgZ2FzIHByaWNlIG9yIGluY3JlbWVudGluZyB0aGUgbm9uY2UuXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvYW5vdGhlciB0cmFuc2FjdGlvbiB3aXRoIHNhbWUgbm9uY2UvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvZXhlY3V0aW9uIGZhaWxlZCBkdWUgdG8gYW4gZXhjZXB0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG52YXIgRXRoZXJzY2FuUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV0aGVyc2NhblByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV0aGVyc2NhblByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBFdGhlcnNjYW5Qcm92aWRlcik7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV0d29yaykgfHwgdGhpcztcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiYmFzZVVybFwiLCBfdGhpcy5nZXRCYXNlVXJsKCkpO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhcGlLZXlcIiwgYXBpS2V5IHx8IGRlZmF1bHRBcGlLZXkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5nZXRCYXNlVXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubmV0d29yayA/IHRoaXMubmV0d29yay5uYW1lIDogXCJpbnZhbGlkXCIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktcmlua2VieS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGkta292YW4uZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1nb2VybGkuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG4gICAgfTtcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gKG1vZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gXCImXCIgKyBrZXkgKyBcIj1cIiArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgdmFyIGFwaUtleSA9ICgodGhpcy5hcGlLZXkpID8gXCImYXBpa2V5PVwiICsgdGhpcy5hcGlLZXkgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVVybCArIFwiL2FwaT9tb2R1bGU9XCIgKyBtb2R1bGUgKyBxdWVyeSArIGFwaUtleTtcbiAgICB9O1xuICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5nZXRQb3N0VXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlVXJsICsgXCIvYXBpXCI7XG4gICAgfTtcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0UG9zdERhdGEgPSBmdW5jdGlvbiAobW9kdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgcGFyYW1zLmFwaWtleSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKG1vZHVsZSwgcGFyYW1zLCBwb3N0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB1cmwsIHBheWxvYWQsIHByb2NGdW5jLCBjb25uZWN0aW9uLCBwYXlsb2FkU3RyLCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKHBvc3QgPyB0aGlzLmdldFBvc3RVcmwoKSA6IHRoaXMuZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gKHBvc3QgPyB0aGlzLmdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY0Z1bmMgPSAobW9kdWxlID09PSBcInByb3h5XCIpID8gZ2V0SnNvblJlc3VsdCA6IGdldFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlU2xvdEludGVydmFsOiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IGZ1bmN0aW9uIChhdHRlbXB0LCB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzQ29tbXVuaXR5UmVzb3VyY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGZvcm1hdHRlcl8xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFN0ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRTdHIgPSBPYmplY3Qua2V5cyhwYXlsb2FkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgXCI9XCIgKyBwYXlsb2FkW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgd2ViXzEuZmV0Y2hKc29uKShjb25uZWN0aW9uLCBwYXlsb2FkU3RyLCBwcm9jRnVuYyB8fCBnZXRKc29uUmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6ICgwLCBwcm9wZXJ0aWVzXzEuZGVlcENvcHkpKHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5uZXR3b3JrXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgcG9zdERhdGEsIGVycm9yXzEsIHBvc3REYXRhLCBlcnJvcl8yLCBhcmdzLCB0b3BpYzAsIGxvZ3MsIGJsb2NrcywgaSwgbG9nLCBibG9jaywgX2I7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbmRUcmFuc2FjdGlvblwiOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyOF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfYmxvY2tOdW1iZXJcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfZ2FzUHJpY2VcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybnMgYmFzZS0xMCByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJhY2NvdW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiYmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBwYXJhbXMuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4OiBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldEJsb2NrIGJ5IGJsb2NrSGFzaCBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcGFyYW1zLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YSA9IGdldFRyYW5zYWN0aW9uUG9zdERhdGEocGFyYW1zLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLm1vZHVsZSA9IFwicHJveHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2NhbGxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEyLCAxNCwgLCAxNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja0Vycm9yKFwiY2FsbFwiLCBlcnJvcl8xLCBwYXJhbXMudHJhbnNhY3Rpb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3REYXRhID0gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShwYXJhbXMudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEubW9kdWxlID0gXCJwcm94eVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfZXN0aW1hdGVHYXNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzE2LCAxOCwgLCAxOV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTc6IHJldHVybiBbMiAvKnJldHVybiovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja0Vycm9yKFwiZXN0aW1hdGVHYXNcIiwgZXJyb3JfMiwgcGFyYW1zLnRyYW5zYWN0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0geyBhY3Rpb246IFwiZ2V0TG9nc1wiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmZyb21CbG9jayA9IGNoZWNrTG9nVGFnKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuYWRkcmVzcyA9IHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXZSBjYW4gaGFuZGxlIHNsaWdodGx5IG1vcmUgY29tcGxpY2F0ZWQgbG9ncyB1c2luZyB0aGUgbG9ncyBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBjb3VudFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpY3M6IHBhcmFtcy5maWx0ZXIudG9waWNzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljMCA9IHBhcmFtcy5maWx0ZXIudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0b3BpYzApICE9PSBcInN0cmluZ1wiIHx8IHRvcGljMC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGZvcm1hdFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpYzA6IHRvcGljMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvcGljMCA9IHRvcGljMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwibG9nc1wiLCBhcmdzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgbG9ncy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAyNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cgPSBsb2dzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja0hhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDI0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEJsb2NrKGxvZy5ibG9ja051bWJlcildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9IGJsb2NrLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDIzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmJsb2NrSGFzaCA9IGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDIxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ3NdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmV0d29yay5uYW1lICE9PSBcImhvbWVzdGVhZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDAuMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHBhcnNlRmxvYXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwic3RhdHNcIiwgeyBhY3Rpb246IFwiZXRocHJpY2VcIiB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseSh2b2lkIDAsIFsoX2Muc2VudCgpKS5ldGh1c2RdKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIG1ldGhvZCwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gTm90ZTogVGhlIGBwYWdlYCBwYWdlIHBhcmFtZXRlciBvbmx5IGFsbG93cyBwYWdpbmF0aW9uIHdpdGhpbiB0aGVcbiAgICAvLyAgICAgICAxMCwwMDAgd2luZG93IGF2YWlsYWJsZSB3aXRob3V0IGEgcGFnZSBhbmQgb2Zmc2V0IHBhcmFtZXRlclxuICAgIC8vICAgICAgIEVycm9yOiBSZXN1bHQgd2luZG93IGlzIHRvbyBsYXJnZSwgUGFnZU5vIHggT2Zmc2V0IHNpemUgbXVzdFxuICAgIC8vICAgICAgICAgICAgICBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMTAwMDBcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0SGlzdG9yeSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBzdGFydEJsb2NrLCBlbmRCbG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zLCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInR4bGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IChfYS5hZGRyZXNzID0gKF9iLnNlbnQoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc3RhcnRibG9jayA9ICgoc3RhcnRCbG9jayA9PSBudWxsKSA/IDAgOiBzdGFydEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5lbmRibG9jayA9ICgoZW5kQmxvY2sgPT0gbnVsbCkgPyA5OTk5OTk5OSA6IGVuZEJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zb3J0ID0gXCJhc2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCBwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdC5tYXAoZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNvbnRyYWN0QWRkcmVzc1wiLCBcInRvXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmNyZWF0ZXMgPT0gbnVsbCAmJiB0eC5jb250cmFjdEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY3JlYXRlcyA9IHR4LmNvbnRyYWN0QWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50aW1lc3RhbXAgPSBwYXJzZUludCh0eC50aW1lU3RhbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFdGhlcnNjYW5Qcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXRoZXJzY2FuUHJvdmlkZXI7XG59KGJhc2VfcHJvdmlkZXJfMS5CYXNlUHJvdmlkZXIpKTtcbmV4cG9ydHMuRXRoZXJzY2FuUHJvdmlkZXIgPSBFdGhlcnNjYW5Qcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVyc2Nhbi1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/etherscan-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/fallback-provider.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/fallback-provider.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FallbackProvider = void 0;\nvar abstract_provider_1 = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar random_1 = __webpack_require__(/*! @ethersproject/random */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js\");\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/base-provider.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    var result = null;\n    for (var i = 0; i < networks.length; i++) {\n        var network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    var middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    var a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (bignumber_1.BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map(function (i) { return serialize(i); }));\n    }\n    else if (typeof (value) === \"object\") {\n        var keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map(function (key) {\n            var v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nvar nextRid = 1;\n;\nfunction stall(duration) {\n    var cancel = null;\n    var timer = null;\n    var promise = (new Promise(function (resolve) {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    var wait = function (func) {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel: cancel, getPromise: getPromise, wait: wait };\n}\nvar ForwardErrors = [\n    logger_1.Logger.errors.CALL_EXCEPTION,\n    logger_1.Logger.errors.INSUFFICIENT_FUNDS,\n    logger_1.Logger.errors.NONCE_EXPIRED,\n    logger_1.Logger.errors.REPLACEMENT_UNDERPRICED,\n    logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nvar ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    var result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: function () { return config.provider; } });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        var tally = {};\n        configs.forEach(function (c) {\n            var value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        var keys = Object.keys(tally);\n        for (var i = 0; i < keys.length; i++) {\n            var check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    var normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                var values = configs.map(function (c) { return c.result; });\n                // Get the median block number\n                var blockNumber = median(configs.map(function (c) { return c.result; }), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                var values = configs.map(function (c) { return c.result; });\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map(function (c) { return c.result; }));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = (0, properties_1.shallowCopy)(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = (0, properties_1.shallowCopy)(block);\n                    block.transactions = block.transactions.map(function (tx) {\n                        tx = (0, properties_1.shallowCopy)(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n        var provider;\n        return __generator(this, function (_a) {\n            provider = (config.provider);\n            if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n                return [2 /*return*/, provider];\n            }\n            return [2 /*return*/, (0, web_1.poll)(function () {\n                    return new Promise(function (resolve, reject) {\n                        setTimeout(function () {\n                            // We are synced\n                            if (provider.blockNumber >= blockNumber) {\n                                return resolve(provider);\n                            }\n                            // We're done; just quit\n                            if (config.cancelled) {\n                                return resolve(null);\n                            }\n                            // Try again, next block\n                            return resolve(undefined);\n                        }, 0);\n                    });\n                }, { oncePoll: provider })];\n        });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function () {\n        var provider, _a, filter;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    provider = config.provider;\n                    _a = method;\n                    switch (_a) {\n                        case \"getBlockNumber\": return [3 /*break*/, 1];\n                        case \"getGasPrice\": return [3 /*break*/, 1];\n                        case \"getEtherPrice\": return [3 /*break*/, 2];\n                        case \"getBalance\": return [3 /*break*/, 3];\n                        case \"getTransactionCount\": return [3 /*break*/, 3];\n                        case \"getCode\": return [3 /*break*/, 3];\n                        case \"getStorageAt\": return [3 /*break*/, 6];\n                        case \"getBlock\": return [3 /*break*/, 9];\n                        case \"call\": return [3 /*break*/, 12];\n                        case \"estimateGas\": return [3 /*break*/, 12];\n                        case \"getTransaction\": return [3 /*break*/, 15];\n                        case \"getTransactionReceipt\": return [3 /*break*/, 15];\n                        case \"getLogs\": return [3 /*break*/, 16];\n                    }\n                    return [3 /*break*/, 19];\n                case 1: return [2 /*return*/, provider[method]()];\n                case 2:\n                    if (provider.getEtherPrice) {\n                        return [2 /*return*/, provider.getEtherPrice()];\n                    }\n                    return [3 /*break*/, 19];\n                case 3:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 5];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 4:\n                    provider = _b.sent();\n                    _b.label = 5;\n                case 5: return [2 /*return*/, provider[method](params.address, params.blockTag || \"latest\")];\n                case 6:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 8];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 7:\n                    provider = _b.sent();\n                    _b.label = 8;\n                case 8: return [2 /*return*/, provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\")];\n                case 9:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 11];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 10:\n                    provider = _b.sent();\n                    _b.label = 11;\n                case 11: return [2 /*return*/, provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash)];\n                case 12:\n                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 14];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 13:\n                    provider = _b.sent();\n                    _b.label = 14;\n                case 14: return [2 /*return*/, provider[method](params.transaction)];\n                case 15: return [2 /*return*/, provider[method](params.transactionHash)];\n                case 16:\n                    filter = params.filter;\n                    if (!((filter.fromBlock && (0, bytes_1.isHexString)(filter.fromBlock)) || (filter.toBlock && (0, bytes_1.isHexString)(filter.toBlock)))) return [3 /*break*/, 18];\n                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n                case 17:\n                    provider = _b.sent();\n                    _b.label = 18;\n                case 18: return [2 /*return*/, provider.getLogs(filter)];\n                case 19: return [2 /*return*/, logger.throwError(\"unknown method error\", logger_1.Logger.errors.UNKNOWN_ERROR, {\n                        method: method,\n                        params: params\n                    })];\n            }\n        });\n    });\n}\nvar FallbackProvider = /** @class */ (function (_super) {\n    __extends(FallbackProvider, _super);\n    function FallbackProvider(providers, quorum) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        var providerConfigs = providers.map(function (configOrProvider, index) {\n            if (abstract_provider_1.Provider.isProvider(configOrProvider)) {\n                var stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2000 : 750;\n                var priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout: stallTimeout, priority: priority });\n            }\n            var config = (0, properties_1.shallowCopy)(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            var weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", \"providers[\" + index + \"].weight\", weight);\n            }\n            return Object.freeze(config);\n        });\n        var total = providerConfigs.reduce(function (accum, c) { return (accum + c.weight); }, 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        var networkOrReady = checkNetworks(providerConfigs.map(function (c) { return (c.provider).network; }));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise(function (resolve, reject) {\n                setTimeout(function () {\n                    _this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        _this = _super.call(this, networkOrReady) || this;\n        // Preserve a copy, so we do not get mutated\n        (0, properties_1.defineReadOnly)(_this, \"providerConfigs\", Object.freeze(providerConfigs));\n        (0, properties_1.defineReadOnly)(_this, \"quorum\", quorum);\n        _this._highestBlockNumber = -1;\n        return _this;\n    }\n    FallbackProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var networks;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) { return c.provider.getNetwork(); }))];\n                    case 1:\n                        networks = _a.sent();\n                        return [2 /*return*/, checkNetworks(networks)];\n                }\n            });\n        });\n    };\n    FallbackProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(method === \"sendTransaction\")) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) {\n                                return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n                                    return result.hash;\n                                }, function (error) {\n                                    return error;\n                                });\n                            }))];\n                    case 1:\n                        results = _a.sent();\n                        // Any success is good enough (other errors are likely \"already seen\" errors\n                        for (i_1 = 0; i_1 < results.length; i_1++) {\n                            result = results[i_1];\n                            if (typeof (result) === \"string\") {\n                                return [2 /*return*/, result];\n                            }\n                        }\n                        // They were all an error; pick the first error\n                        throw results[0];\n                    case 2:\n                        if (!(this._highestBlockNumber === -1 && method !== \"getBlockNumber\")) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this.getBlockNumber()];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4:\n                        processFunc = getProcessFunc(this, method, params);\n                        configs = (0, random_1.shuffled)(this.providerConfigs.map(properties_1.shallowCopy));\n                        configs.sort(function (a, b) { return (a.priority - b.priority); });\n                        currentBlockNumber = this._highestBlockNumber;\n                        i = 0;\n                        first = true;\n                        _loop_1 = function () {\n                            var t0, inflightWeight, _loop_2, waiting, results, result, errors;\n                            return __generator(this, function (_b) {\n                                switch (_b.label) {\n                                    case 0:\n                                        t0 = now();\n                                        inflightWeight = configs.filter(function (c) { return (c.runner && ((t0 - c.start) < c.stallTimeout)); })\n                                            .reduce(function (accum, c) { return (accum + c.weight); }, 0);\n                                        _loop_2 = function () {\n                                            var config = configs[i++];\n                                            var rid = nextRid++;\n                                            config.start = now();\n                                            config.staller = stall(config.stallTimeout);\n                                            config.staller.wait(function () { config.staller = null; });\n                                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n                                                config.done = true;\n                                                config.result = result;\n                                                if (_this.listenerCount(\"debug\")) {\n                                                    _this.emit(\"debug\", {\n                                                        action: \"request\",\n                                                        rid: rid,\n                                                        backend: exposeDebugConfig(config, now()),\n                                                        request: { method: method, params: (0, properties_1.deepCopy)(params) },\n                                                        provider: _this\n                                                    });\n                                                }\n                                            }, function (error) {\n                                                config.done = true;\n                                                config.error = error;\n                                                if (_this.listenerCount(\"debug\")) {\n                                                    _this.emit(\"debug\", {\n                                                        action: \"request\",\n                                                        rid: rid,\n                                                        backend: exposeDebugConfig(config, now()),\n                                                        request: { method: method, params: (0, properties_1.deepCopy)(params) },\n                                                        provider: _this\n                                                    });\n                                                }\n                                            });\n                                            if (this_1.listenerCount(\"debug\")) {\n                                                this_1.emit(\"debug\", {\n                                                    action: \"request\",\n                                                    rid: rid,\n                                                    backend: exposeDebugConfig(config, null),\n                                                    request: { method: method, params: (0, properties_1.deepCopy)(params) },\n                                                    provider: this_1\n                                                });\n                                            }\n                                            inflightWeight += config.weight;\n                                        };\n                                        // Start running enough to meet quorum\n                                        while (inflightWeight < this_1.quorum && i < configs.length) {\n                                            _loop_2();\n                                        }\n                                        waiting = [];\n                                        configs.forEach(function (c) {\n                                            if (c.done || !c.runner) {\n                                                return;\n                                            }\n                                            waiting.push(c.runner);\n                                            if (c.staller) {\n                                                waiting.push(c.staller.getPromise());\n                                            }\n                                        });\n                                        if (!waiting.length) return [3 /*break*/, 2];\n                                        return [4 /*yield*/, Promise.race(waiting)];\n                                    case 1:\n                                        _b.sent();\n                                        _b.label = 2;\n                                    case 2:\n                                        results = configs.filter(function (c) { return (c.done && c.error == null); });\n                                        if (!(results.length >= this_1.quorum)) return [3 /*break*/, 5];\n                                        result = processFunc(results);\n                                        if (result !== undefined) {\n                                            // Shut down any stallers\n                                            configs.forEach(function (c) {\n                                                if (c.staller) {\n                                                    c.staller.cancel();\n                                                }\n                                                c.cancelled = true;\n                                            });\n                                            return [2 /*return*/, { value: result }];\n                                        }\n                                        if (!!first) return [3 /*break*/, 4];\n                                        return [4 /*yield*/, stall(100).getPromise()];\n                                    case 3:\n                                        _b.sent();\n                                        _b.label = 4;\n                                    case 4:\n                                        first = false;\n                                        _b.label = 5;\n                                    case 5:\n                                        errors = configs.reduce(function (accum, c) {\n                                            if (!c.done || c.error == null) {\n                                                return accum;\n                                            }\n                                            var code = (c.error).code;\n                                            if (ForwardErrors.indexOf(code) >= 0) {\n                                                if (!accum[code]) {\n                                                    accum[code] = { error: c.error, weight: 0 };\n                                                }\n                                                accum[code].weight += c.weight;\n                                            }\n                                            return accum;\n                                        }, ({}));\n                                        Object.keys(errors).forEach(function (errorCode) {\n                                            var tally = errors[errorCode];\n                                            if (tally.weight < _this.quorum) {\n                                                return;\n                                            }\n                                            // Shut down any stallers\n                                            configs.forEach(function (c) {\n                                                if (c.staller) {\n                                                    c.staller.cancel();\n                                                }\n                                                c.cancelled = true;\n                                            });\n                                            var e = (tally.error);\n                                            var props = {};\n                                            ForwardProperties.forEach(function (name) {\n                                                if (e[name] == null) {\n                                                    return;\n                                                }\n                                                props[name] = e[name];\n                                            });\n                                            logger.throwError(e.reason || e.message, errorCode, props);\n                                        });\n                                        // All configs have run to completion; we will never get more data\n                                        if (configs.filter(function (c) { return !c.done; }).length === 0) {\n                                            return [2 /*return*/, \"break\"];\n                                        }\n                                        return [2 /*return*/];\n                                }\n                            });\n                        };\n                        this_1 = this;\n                        _a.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [5 /*yield**/, _loop_1()];\n                    case 6:\n                        state_1 = _a.sent();\n                        if (typeof state_1 === \"object\")\n                            return [2 /*return*/, state_1.value];\n                        if (state_1 === \"break\")\n                            return [3 /*break*/, 7];\n                        return [3 /*break*/, 5];\n                    case 7:\n                        // Shut down any stallers; shouldn't be any\n                        configs.forEach(function (c) {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return [2 /*return*/, logger.throwError(\"failed to meet quorum\", logger_1.Logger.errors.SERVER_ERROR, {\n                                method: method,\n                                params: params,\n                                //results: configs.map((c) => c.result),\n                                //errors: configs.map((c) => c.error),\n                                results: configs.map(function (c) { return exposeDebugConfig(c); }),\n                                provider: this\n                            })];\n                }\n            });\n        });\n    };\n    return FallbackProvider;\n}(base_provider_1.BaseProvider));\nexports.FallbackProvider = FallbackProvider;\n//# sourceMappingURL=fallback-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2ZhbGxiYWNrLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsMEJBQTBCLG1CQUFPLENBQUMsZ0lBQWtDO0FBQ3BFLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLGtIQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLFlBQVksbUJBQU8sQ0FBQyxvR0FBb0I7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsK0dBQWlCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMscUdBQVk7QUFDckM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQkFBbUIsMkJBQTJCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0Esb0VBQW9FLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCLElBQUksb0JBQW9CO0FBQ3pDLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1RkFBdUY7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxpRUFBaUUsNEJBQTRCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSw4RUFBOEUsOEJBQThCO0FBQzVHLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsaUNBQWlDO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxtQ0FBbUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLHlEQUF5RDtBQUNoSiwwRUFBMEUsNEJBQTRCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsd0JBQXdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsNERBQTREO0FBQy9IO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDREQUE0RDtBQUMvSDtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDREQUE0RDtBQUMzSDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YscUNBQXFDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxvRUFBb0UsZUFBZTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLHlDQUF5QztBQUN6QywrRUFBK0U7QUFDL0UsMEVBQTBFLGlCQUFpQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEVBQUUsRUFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw4QkFBOEI7QUFDbEc7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvZmFsbGJhY2stcHJvdmlkZXIuanM/YzliYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gdm9pZCAwO1xudmFyIGFic3RyYWN0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXJcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgcmFuZG9tXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcmFuZG9tXCIpO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbnZhciBiYXNlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9iYXNlLXByb3ZpZGVyXCIpO1xudmFyIGZvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vZm9ybWF0dGVyXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuLy8gUmV0dXJucyB0byBuZXR3b3JrIGFzIGxvbmcgYXMgYWxsIGFncmVlLCBvciBudWxsIGlmIGFueSBpcyBudWxsLlxuLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFueSB0d28gbmV0d29ya3MgZG8gbm90IG1hdGNoLlxuZnVuY3Rpb24gY2hlY2tOZXR3b3JrcyhuZXR3b3Jrcykge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV0d29ya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ldHdvcmsgPSBuZXR3b3Jrc1tpXTtcbiAgICAgICAgLy8gTnVsbCEgV2UgZG8gbm90IGtub3cgb3VyIG5ldHdvcms7IGJhaWwuXG4gICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV0d29yayBtYXRjaGVzIHRoZSBwcmV2aW91cyBuZXR3b3Jrc1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0Lm5hbWUgPT09IG5ldHdvcmsubmFtZSAmJiByZXN1bHQuY2hhaW5JZCA9PT0gbmV0d29yay5jaGFpbklkICYmXG4gICAgICAgICAgICAgICAgKChyZXN1bHQuZW5zQWRkcmVzcyA9PT0gbmV0d29yay5lbnNBZGRyZXNzKSB8fCAocmVzdWx0LmVuc0FkZHJlc3MgPT0gbnVsbCAmJiBuZXR3b3JrLmVuc0FkZHJlc3MgPT0gbnVsbCkpKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlciBtaXNtYXRjaFwiLCBcIm5ldHdvcmtzXCIsIG5ldHdvcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldHdvcms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1lZGlhbih2YWx1ZXMsIG1heERlbHRhKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKCkuc29ydCgpO1xuICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgICAvLyBPZGQgbGVuZ3RoOyB0YWtlIHRoZSBtaWRkbGVcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1ttaWRkbGVdO1xuICAgIH1cbiAgICAvLyBFdmVuIGxlbmd0aDsgdGFrZSB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIG1pZGRsZVxuICAgIHZhciBhID0gdmFsdWVzW21pZGRsZSAtIDFdLCBiID0gdmFsdWVzW21pZGRsZV07XG4gICAgaWYgKG1heERlbHRhICE9IG51bGwgJiYgTWF0aC5hYnMoYSAtIGIpID4gbWF4RGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoYSArIGIpIC8gMjtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZ251bWJlcl8xLkJpZ051bWJlci5pc0JpZ051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHNlcmlhbGl6ZShpKTsgfSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgIHJldHVybiBcIntcIiArIGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2ID0gXCJbZnVuY3Rpb25dXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ID0gc2VyaWFsaXplKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjpcIiArIHY7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdmFsdWUgdHlwZTogXCIgKyB0eXBlb2YgKHZhbHVlKSk7XG59XG4vLyBOZXh0IHJlcXVlc3QgSUQgdG8gdXNlIGZvciBlbWl0dGluZyBkZWJ1ZyBpbmZvXG52YXIgbmV4dFJpZCA9IDE7XG47XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHZhciBjYW5jZWwgPSBudWxsO1xuICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgdmFyIHByb21pc2UgPSAobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYW5jZWwsIGR1cmF0aW9uKTtcbiAgICB9KSk7XG4gICAgdmFyIHdhaXQgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmMpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldFByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4geyBjYW5jZWw6IGNhbmNlbCwgZ2V0UHJvbWlzZTogZ2V0UHJvbWlzZSwgd2FpdDogd2FpdCB9O1xufVxudmFyIEZvcndhcmRFcnJvcnMgPSBbXG4gICAgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTixcbiAgICBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcbiAgICBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG4gICAgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcbiAgICBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXG5dO1xudmFyIEZvcndhcmRQcm9wZXJ0aWVzID0gW1xuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYXJnc1wiLFxuICAgIFwiZXJyb3JBcmdzXCIsXG4gICAgXCJlcnJvclNpZ25hdHVyZVwiLFxuICAgIFwibWV0aG9kXCIsXG4gICAgXCJ0cmFuc2FjdGlvblwiLFxuXTtcbjtcbmZ1bmN0aW9uIGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgd2VpZ2h0OiBjb25maWcud2VpZ2h0XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcInByb3ZpZGVyXCIsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWcucHJvdmlkZXI7IH0gfSk7XG4gICAgaWYgKGNvbmZpZy5zdGFydCkge1xuICAgICAgICByZXN1bHQuc3RhcnQgPSBjb25maWcuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChub3cpIHtcbiAgICAgICAgcmVzdWx0LmR1cmF0aW9uID0gKG5vdyAtIGNvbmZpZy5zdGFydCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuZG9uZSkge1xuICAgICAgICBpZiAoY29uZmlnLmVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBjb25maWcuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucmVzdWx0ID0gY29uZmlnLnJlc3VsdCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLCBxdW9ydW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcbiAgICAgICAgLy8gQ291bnQgdGhlIHZvdGVzIGZvciBlYWNoIHJlc3VsdFxuICAgICAgICB2YXIgdGFsbHkgPSB7fTtcbiAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemUoYy5yZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCF0YWxseVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICB0YWxseVt2YWx1ZV0gPSB7IGNvdW50OiAwLCByZXN1bHQ6IGMucmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWxseVt2YWx1ZV0uY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBhIHF1b3J1bSBvbiBhbnkgZ2l2ZW4gcmVzdWx0XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFsbHkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IHRhbGx5W2tleXNbaV1dO1xuICAgICAgICAgICAgaWYgKGNoZWNrLmNvdW50ID49IHF1b3J1bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVjay5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gcXVyb3VtXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFByb2Nlc3NGdW5jKHByb3ZpZGVyLCBtZXRob2QsIHBhcmFtcykge1xuICAgIHZhciBub3JtYWxpemUgPSBzZXJpYWxpemU7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1lZGlhbiB2YWx1ZSwgdW5sZXNzIHRoZXJlIGlzIChtZWRpYW4gKyAxKSBpcyBhbHNvXG4gICAgICAgICAgICAvLyBwcmVzZW50LCBpbiB3aGljaCBjYXNlIHRoYXQgaXMgcHJvYmFibHkgdHJ1ZSBhbmQgdGhlIG1lZGlhblxuICAgICAgICAgICAgLy8gaXMgZ29pbmcgdG8gYmUgc3RhbGUgc29vbi4gSW4gdGhlIGV2ZW50IG9mIGEgbWFsaWNpb3VzIG5vZGUsXG4gICAgICAgICAgICAvLyB0aGUgbGllIHdpbGwgYmUgdHJ1ZSBzb29uIGVub3VnaC5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbWVkaWFuIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgIHZhciBibG9ja051bWJlciA9IG1lZGlhbihjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pLCAyKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IE1hdGguY2VpbChibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgYmxvY2sgaGVpZ2h0IGlzIHByZXNlbnQsIGl0cyBwcm9sbHkgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmluZGV4T2YoYmxvY2tOdW1iZXIgKyAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERvbid0IGV2ZXIgcm9sbCBiYWNrIHRoZSBibG9ja051bWJlclxuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+PSBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbWlkZGxlIChyb3VuZCBpbmRleCB1cCkgdmFsdWUsIHNpbWlsYXIgdG8gbWVkaWFuXG4gICAgICAgICAgICAvLyBidXQgZG8gbm90IGF2ZXJhZ2UgZXZlbiBlbnRyaWVzIGFuZCBjaG9vc2UgdGhlIGhpZ2hlci5cbiAgICAgICAgICAgIC8vIE1hbGljaW91cyBhY3RvcnMgbXVzdCBjb21wcm9taXNlIDUwJSBvZiB0aGUgbm9kZXMgdG8gbGllLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnNvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW01hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6XG4gICAgICAgICAgICAvLyBSZXR1cm5zIHRoZSBtZWRpYW4gcHJpY2UuIE1hbGljaW91cyBhY3RvcnMgbXVzdCBjb21wcm9taXNlIGF0XG4gICAgICAgICAgICAvLyBsZWFzdCA1MCUgb2YgdGhlIG5vZGVzIHRvIGxpZSAoaW4gYSBtZWFuaW5nZnVsIHdheSkuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVkaWFuKGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gTm8gYWRkaXRpb25hbCBub3JtYWxpemluZyByZXF1aXJlZDsgc2VyaWFsaXplIGlzIGVub3VnaFxuICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG4gICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOlxuICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFdlIGRyb3AgdGhlIGNvbmZpcm1hdGlvbnMgZnJvbSB0cmFuc2FjdGlvbnMgYXMgaXQgaXMgYXBwcm94aW1hdGVcbiAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eCA9ICgwLCBwcm9wZXJ0aWVzXzEuc2hhbGxvd0NvcHkpKHR4KTtcbiAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZSh0eCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFdlIGRyb3AgdGhlIGNvbmZpcm1hdGlvbnMgZnJvbSB0cmFuc2FjdGlvbnMgYXMgaXQgaXMgYXBwcm94aW1hdGVcbiAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG4gICAgICAgICAgICBpZiAocGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBibG9jay50cmFuc2FjdGlvbnMgPSBibG9jay50cmFuc2FjdGlvbnMubWFwKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KSh0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBpZiBhbmQgb25seSBpZiB0aGUgZXhwZWN0ZWQgcXVvcnVtIGlzXG4gICAgLy8gc2F0aXNmaWVkIGFuZCBhZ3JlZWQgdXBvbiBmb3IgdGhlIGZpbmFsIHJlc3VsdC5cbiAgICByZXR1cm4gbm9ybWFsaXplZFRhbGx5KG5vcm1hbGl6ZSwgcHJvdmlkZXIucXVvcnVtKTtcbn1cbi8vIElmIHdlIGFyZSBkb2luZyBhIGJsb2NrVGFnIHF1ZXJ5LCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgYmFja2VuZCBpc1xuLy8gY2F1Z2h0IHVwIHRvIHRoZSBGYWxsYmFja1Byb3ZpZGVyLCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgdG8gaXQuXG5mdW5jdGlvbiB3YWl0Rm9yU3luYyhjb25maWcsIGJsb2NrTnVtYmVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvdmlkZXI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyID0gKGNvbmZpZy5wcm92aWRlcik7XG4gICAgICAgICAgICBpZiAoKHByb3ZpZGVyLmJsb2NrTnVtYmVyICE9IG51bGwgJiYgcHJvdmlkZXIuYmxvY2tOdW1iZXIgPj0gYmxvY2tOdW1iZXIpIHx8IGJsb2NrTnVtYmVyID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKDAsIHdlYl8xLnBvbGwpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzeW5jZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuYmxvY2tOdW1iZXIgPj0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lOyBqdXN0IHF1aXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGFnYWluLCBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCB7IG9uY2VQb2xsOiBwcm92aWRlciB9KV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UnVubmVyKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyLCBtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyLCBfYSwgZmlsdGVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IGNvbmZpZy5wcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRFdGhlclByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOiByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOiByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyW21ldGhvZF0oKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuZ2V0RXRoZXJQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLmdldEV0aGVyUHJpY2UoKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmICgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLmFkZHJlc3MsIHBhcmFtcy5ibG9ja1RhZyB8fCBcImxhdGVzdFwiKV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbXMuYmxvY2tUYWcgJiYgKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXIuZ2V0U3RvcmFnZUF0KHBhcmFtcy5hZGRyZXNzLCBwYXJhbXMucG9zaXRpb24sIHBhcmFtcy5ibG9ja1RhZyB8fCBcImxhdGVzdFwiKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbXMuYmxvY2tUYWcgJiYgKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTE7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyWyhwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucyA/IFwiZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zXCIgOiBcImdldEJsb2NrXCIpXShwYXJhbXMuYmxvY2tUYWcgfHwgcGFyYW1zLmJsb2NrSGFzaCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtcy5ibG9ja1RhZyAmJiAoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykocGFyYW1zLmJsb2NrVGFnKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxNDtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb24pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb25IYXNoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gcGFyYW1zLmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKGZpbHRlci5mcm9tQmxvY2sgJiYgKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGZpbHRlci5mcm9tQmxvY2spKSB8fCAoZmlsdGVyLnRvQmxvY2sgJiYgKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKGZpbHRlci50b0Jsb2NrKSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTg7XG4gICAgICAgICAgICAgICAgY2FzZSAxODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLmdldExvZ3MoZmlsdGVyKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBtZXRob2QgZXJyb3JcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG52YXIgRmFsbGJhY2tQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmFsbGJhY2tQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVycywgcXVvcnVtKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZhbGxiYWNrUHJvdmlkZXIpO1xuICAgICAgICBpZiAocHJvdmlkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJzXCIsIFwicHJvdmlkZXJzXCIsIHByb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3ZpZGVyQ29uZmlncyA9IHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKGNvbmZpZ09yUHJvdmlkZXIsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYWJzdHJhY3RfcHJvdmlkZXJfMS5Qcm92aWRlci5pc1Byb3ZpZGVyKGNvbmZpZ09yUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWxsVGltZW91dCA9ICgwLCBmb3JtYXR0ZXJfMS5pc0NvbW11bml0eVJlc291cmNlKShjb25maWdPclByb3ZpZGVyKSA/IDIwMDAgOiA3NTA7XG4gICAgICAgICAgICAgICAgdmFyIHByaW9yaXR5ID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IHByb3ZpZGVyOiBjb25maWdPclByb3ZpZGVyLCB3ZWlnaHQ6IDEsIHN0YWxsVGltZW91dDogc3RhbGxUaW1lb3V0LCBwcmlvcml0eTogcHJpb3JpdHkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkoY29uZmlnT3JQcm92aWRlcik7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnByaW9yaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcucHJpb3JpdHkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdGFsbFRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbFRpbWVvdXQgPSAoMCwgZm9ybWF0dGVyXzEuaXNDb21tdW5pdHlSZXNvdXJjZSkoY29uZmlnT3JQcm92aWRlcikgPyAyMDAwIDogNzUwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy53ZWlnaHQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdlaWdodCA9IGNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICUgMSB8fCB3ZWlnaHQgPiA1MTIgfHwgd2VpZ2h0IDwgMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHdlaWdodDsgbXVzdCBiZSBpbnRlZ2VyIGluIFsxLCA1MTJdXCIsIFwicHJvdmlkZXJzW1wiICsgaW5kZXggKyBcIl0ud2VpZ2h0XCIsIHdlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShjb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRvdGFsID0gcHJvdmlkZXJDb25maWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHsgcmV0dXJuIChhY2N1bSArIGMud2VpZ2h0KTsgfSwgMCk7XG4gICAgICAgIGlmIChxdW9ydW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcXVvcnVtID0gdG90YWwgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHF1b3J1bSA+IHRvdGFsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicXVvcnVtIHdpbGwgYWx3YXlzIGZhaWw7IGxhcmdlciB0aGFuIHRvdGFsIHdlaWdodFwiLCBcInF1b3J1bVwiLCBxdW9ydW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFyZSBhbGwgcHJvdmlkZXJzJyBuZXR3b3JrcyBhcmUga25vd25cbiAgICAgICAgdmFyIG5ldHdvcmtPclJlYWR5ID0gY2hlY2tOZXR3b3Jrcyhwcm92aWRlckNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoYy5wcm92aWRlcikubmV0d29yazsgfSkpO1xuICAgICAgICAvLyBOb3QgYWxsIG5ldHdvcmtzIGFyZSBrbm93bjsgd2UgbXVzdCBzdGFsbFxuICAgICAgICBpZiAobmV0d29ya09yUmVhZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV0d29ya09yUmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRldGVjdE5ldHdvcmsoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldHdvcmtPclJlYWR5KSB8fCB0aGlzO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBhIGNvcHksIHNvIHdlIGRvIG5vdCBnZXQgbXV0YXRlZFxuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJwcm92aWRlckNvbmZpZ3NcIiwgT2JqZWN0LmZyZWV6ZShwcm92aWRlckNvbmZpZ3MpKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicXVvcnVtXCIsIHF1b3J1bSk7XG4gICAgICAgIF90aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGYWxsYmFja1Byb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV0d29ya3M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5wcm92aWRlci5nZXROZXR3b3JrKCk7IH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNoZWNrTmV0d29ya3MobmV0d29ya3MpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGYWxsYmFja1Byb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzLCBpXzEsIHJlc3VsdCwgcHJvY2Vzc0Z1bmMsIGNvbmZpZ3MsIGN1cnJlbnRCbG9ja051bWJlciwgaSwgZmlyc3QsIF9sb29wXzEsIHRoaXNfMSwgc3RhdGVfMTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXRob2QgPT09IFwic2VuZFRyYW5zYWN0aW9uXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24ocGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbnkgc3VjY2VzcyBpcyBnb29kIGVub3VnaCAob3RoZXIgZXJyb3JzIGFyZSBsaWtlbHkgXCJhbHJlYWR5IHNlZW5cIiBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaV8xID0gMDsgaV8xIDwgcmVzdWx0cy5sZW5ndGg7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlc3VsdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3ZXJlIGFsbCBhbiBlcnJvcjsgcGljayB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX2hpZ2hlc3RCbG9ja051bWJlciA9PT0gLTEgJiYgbWV0aG9kICE9PSBcImdldEJsb2NrTnVtYmVyXCIpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Z1bmMgPSBnZXRQcm9jZXNzRnVuYyh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzID0gKDAsIHJhbmRvbV8xLnNodWZmbGVkKSh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAocHJvcGVydGllc18xLnNoYWxsb3dDb3B5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrTnVtYmVyID0gdGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0MCwgaW5mbGlnaHRXZWlnaHQsIF9sb29wXzIsIHdhaXRpbmcsIHJlc3VsdHMsIHJlc3VsdCwgZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQwID0gbm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRXZWlnaHQgPSBjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMucnVubmVyICYmICgodDAgLSBjLnN0YXJ0KSA8IGMuc3RhbGxUaW1lb3V0KSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBjKSB7IHJldHVybiAoYWNjdW0gKyBjLndlaWdodCk7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBjb25maWdzW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWQgPSBuZXh0UmlkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFydCA9IG5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxlciA9IHN0YWxsKGNvbmZpZy5zdGFsbFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxlci53YWl0KGZ1bmN0aW9uICgpIHsgY29uZmlnLnN0YWxsZXIgPSBudWxsOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJ1bm5lciA9IGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWQ6IHJpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBub3coKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogKDAsIHByb3BlcnRpZXNfMS5kZWVwQ29weSkocGFyYW1zKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWQ6IHJpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBub3coKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogKDAsIHByb3BlcnRpZXNfMS5kZWVwQ29weSkocGFyYW1zKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzEubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiAoMCwgcHJvcGVydGllc18xLmRlZXBDb3B5KShwYXJhbXMpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNfMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRXZWlnaHQgKz0gY29uZmlnLndlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bm5pbmcgZW5vdWdoIHRvIG1lZXQgcXVvcnVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZmxpZ2h0V2VpZ2h0IDwgdGhpc18xLnF1b3J1bSAmJiBpIDwgY29uZmlncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmRvbmUgfHwgIWMucnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZy5wdXNoKGMucnVubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZy5wdXNoKGMuc3RhbGxlci5nZXRQcm9taXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3YWl0aW5nLmxlbmd0aCkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKHdhaXRpbmcpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMuZG9uZSAmJiBjLmVycm9yID09IG51bGwpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXN1bHRzLmxlbmd0aCA+PSB0aGlzXzEucXVvcnVtKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdmFsdWU6IHJlc3VsdCB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhZmlyc3QpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWxsKDEwMCkuZ2V0UHJvbWlzZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGNvbmZpZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWMuZG9uZSB8fCBjLmVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IChjLmVycm9yKS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRm9yd2FyZEVycm9ycy5pbmRleE9mKGNvZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWNjdW1bY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVtjb2RlXSA9IHsgZXJyb3I6IGMuZXJyb3IsIHdlaWdodDogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bY29kZV0ud2VpZ2h0ICs9IGMud2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAoe30pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhlcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKGVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFsbHkgPSBlcnJvcnNbZXJyb3JDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhbGx5LndlaWdodCA8IF90aGlzLnF1b3J1bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSAodGFsbHkuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yd2FyZFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW25hbWVdID0gZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGUucmVhc29uIHx8IGUubWVzc2FnZSwgZXJyb3JDb2RlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGNvbmZpZ3MgaGF2ZSBydW4gdG8gY29tcGxldGlvbjsgd2Ugd2lsbCBuZXZlciBnZXQgbW9yZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhYy5kb25lOyB9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFwiYnJlYWtcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzUgLyp5aWVsZCoqLywgX2xvb3BfMSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgc3RhdGVfMS52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnM7IHNob3VsZG4ndCBiZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3MuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImZhaWxlZCB0byBtZWV0IHF1b3J1bVwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzdWx0czogY29uZmlncy5tYXAoKGMpID0+IGMucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lcnJvcnM6IGNvbmZpZ3MubWFwKChjKSA9PiBjLmVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGV4cG9zZURlYnVnQ29uZmlnKGMpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEZhbGxiYWNrUHJvdmlkZXI7XG59KGJhc2VfcHJvdmlkZXJfMS5CYXNlUHJvdmlkZXIpKTtcbmV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IEZhbGxiYWNrUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWxsYmFjay1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/fallback-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.showThrottleMessage = exports.isCommunityResource = exports.isCommunityResourcable = exports.Formatter = void 0;\nvar address_1 = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar constants_1 = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar Formatter = /** @class */ (function () {\n    function Formatter() {\n        var _newTarget = this.constructor;\n        logger.checkNew(_newTarget, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n    Formatter.prototype.getDefaultFormats = function () {\n        var _this = this;\n        var formats = ({});\n        var address = this.address.bind(this);\n        var bigNumber = this.bigNumber.bind(this);\n        var blockTag = this.blockTag.bind(this);\n        var data = this.data.bind(this);\n        var hash = this.hash.bind(this);\n        var hex = this.hex.bind(this);\n        var number = this.number.bind(this);\n        var type = this.type.bind(this);\n        var strictData = function (v) { return _this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: address,\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = (0, properties_1.shallowCopy)(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    };\n    Formatter.prototype.accessList = function (accessList) {\n        return (0, transactions_1.accessListify)(accessList || []);\n    };\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    Formatter.prototype.number = function (number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return bignumber_1.BigNumber.from(number).toNumber();\n    };\n    Formatter.prototype.type = function (number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return bignumber_1.BigNumber.from(number).toNumber();\n    };\n    // Strict! Used on input.\n    Formatter.prototype.bigNumber = function (value) {\n        return bignumber_1.BigNumber.from(value);\n    };\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    Formatter.prototype.boolean = function (value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    };\n    Formatter.prototype.hex = function (value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if ((0, bytes_1.isHexString)(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    };\n    Formatter.prototype.data = function (value, strict) {\n        var result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    };\n    // Requires an address\n    // Strict! Used on input.\n    Formatter.prototype.address = function (value) {\n        return (0, address_1.getAddress)(value);\n    };\n    Formatter.prototype.callAddress = function (value) {\n        if (!(0, bytes_1.isHexString)(value, 32)) {\n            return null;\n        }\n        var address = (0, address_1.getAddress)((0, bytes_1.hexDataSlice)(value, 12));\n        return (address === constants_1.AddressZero) ? null : address;\n    };\n    Formatter.prototype.contractAddress = function (value) {\n        return (0, address_1.getContractAddress)(value);\n    };\n    // Strict! Used on input.\n    Formatter.prototype.blockTag = function (blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || (0, bytes_1.isHexString)(blockTag)) {\n            return (0, bytes_1.hexValue)(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    };\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    Formatter.prototype.hash = function (value, strict) {\n        var result = this.hex(value, strict);\n        if ((0, bytes_1.hexDataLength)(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    };\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    Formatter.prototype.difficulty = function (value) {\n        if (value == null) {\n            return null;\n        }\n        var v = bignumber_1.BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    };\n    Formatter.prototype.uint256 = function (value) {\n        if (!(0, bytes_1.isHexString)(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return (0, bytes_1.hexZeroPad)(value, 32);\n    };\n    Formatter.prototype._block = function (value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        var difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        var result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : bignumber_1.BigNumber.from(difficulty));\n        return result;\n    };\n    Formatter.prototype.block = function (value) {\n        return this._block(value, this.formats.block);\n    };\n    Formatter.prototype.blockWithTransactions = function (value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    };\n    // Strict! Used on input.\n    Formatter.prototype.transactionRequest = function (value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    };\n    Formatter.prototype.transactionResponse = function (transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && bignumber_1.BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        var result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            var chainId = transaction.chainId;\n            if ((0, bytes_1.isHexString)(chainId)) {\n                chainId = bignumber_1.BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            var chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if ((0, bytes_1.isHexString)(chainId)) {\n                chainId = bignumber_1.BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    };\n    Formatter.prototype.transaction = function (value) {\n        return (0, transactions_1.parse)(value);\n    };\n    Formatter.prototype.receiptLog = function (value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    };\n    Formatter.prototype.receipt = function (value) {\n        var result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                var value_1 = bignumber_1.BigNumber.from(result.root).toNumber();\n                if (value_1 === 0 || value_1 === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value_1)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value_1;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    };\n    Formatter.prototype.topics = function (value) {\n        var _this = this;\n        if (Array.isArray(value)) {\n            return value.map(function (v) { return _this.topics(v); });\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    };\n    Formatter.prototype.filter = function (value) {\n        return Formatter.check(this.formats.filter, value);\n    };\n    Formatter.prototype.filterLog = function (value) {\n        return Formatter.check(this.formats.filterLog, value);\n    };\n    Formatter.check = function (format, object) {\n        var result = {};\n        for (var key in format) {\n            try {\n                var value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    };\n    // if value is null-ish, nullValue is returned\n    Formatter.allowNull = function (format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    };\n    // If value is false-ish, replaceValue is returned\n    Formatter.allowFalsish = function (format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    };\n    // Requires an Array satisfying check\n    Formatter.arrayOf = function (format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            var result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    };\n    return Formatter;\n}());\nexports.Formatter = Formatter;\nfunction isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexports.isCommunityResourcable = isCommunityResourcable;\nfunction isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\nexports.isCommunityResource = isCommunityResource;\n// Show the throttle message only once\nvar throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\nexports.showThrottleMessage = showThrottleMessage;\n//# sourceMappingURL=formatter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Zvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxpQkFBaUI7QUFDOUcsZ0JBQWdCLG1CQUFPLENBQUMsNEdBQXdCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsc0hBQTZCO0FBQzFELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMscUdBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLDBDQUEwQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2Zvcm1hdHRlci5qcz81Y2JhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNhYmxlID0gZXhwb3J0cy5Gb3JtYXR0ZXIgPSB2b2lkIDA7XG52YXIgYWRkcmVzc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCIpO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9ybWF0dGVyKCkge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBGb3JtYXR0ZXIpO1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB0aGlzLmdldERlZmF1bHRGb3JtYXRzKCk7XG4gICAgfVxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmb3JtYXRzID0gKHt9KTtcbiAgICAgICAgdmFyIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGJpZ051bWJlciA9IHRoaXMuYmlnTnVtYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZhciBibG9ja1RhZyA9IHRoaXMuYmxvY2tUYWcuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGhhc2ggPSB0aGlzLmhhc2guYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGhleCA9IHRoaXMuaGV4LmJpbmQodGhpcyk7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB2YXIgc3RyaWN0RGF0YSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5kYXRhKHYsIHRydWUpOyB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCBudWxsKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgLy8gbXVzdCBiZSBzZXRcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB2YWx1ZTogYmlnTnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IG51bWJlcixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICBzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudWludDI1NiksXG4gICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBjcmVhdGVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmF3OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGZyb206IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksXG4gICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIHZhbHVlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHN0cmljdERhdGEpLFxuICAgICAgICAgICAgdHlwZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSwgbnVsbCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBoYXNoLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnJlY2VpcHQgPSB7XG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgICAgICAgICByb290OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBzdGF0dXM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9jayA9IHtcbiAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICBwYXJlbnRIYXNoOiBoYXNoLFxuICAgICAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhleCksXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiB0aGlzLmRpZmZpY3VsdHkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBnYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBtaW5lcjogYWRkcmVzcyxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSksXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlcilcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KShmb3JtYXRzLmJsb2NrKTtcbiAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuICAgICAgICBmb3JtYXRzLmZpbHRlciA9IHtcbiAgICAgICAgICAgIGZyb21CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmZpbHRlckxvZyA9IHtcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBGb3JtYXR0ZXIuYWxsb3dGYWxzaXNoKGRhdGEsIFwiMHhcIiksXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgbG9nSW5kZXg6IG51bWJlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmFjY2Vzc0xpc3QgPSBmdW5jdGlvbiAoYWNjZXNzTGlzdCkge1xuICAgICAgICByZXR1cm4gKDAsIHRyYW5zYWN0aW9uc18xLmFjY2Vzc0xpc3RpZnkpKGFjY2Vzc0xpc3QgfHwgW10pO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYSBCaWdOdW1iZXJpc2ggdGhhdCBpcyB3aXRoaW4gdGhlIElFRUU3NTQgc2FmZSBpbnRlZ2VyIHJhbmdlOyByZXR1cm5zIGEgbnVtYmVyXG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIiB8fCBudW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcbiAgICB9O1xuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJpZ051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYSBib29sZWFuLCBcInRydWVcIiBvciAgXCJmYWxzZVwiOyByZXR1cm5zIGEgYm9vbGVhblxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvb2xlYW4gLSBcIiArIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggJSAyKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhOyBvZGQtbGVuZ3RoIC0gXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIFJlcXVpcmVzIGFuIGFkZHJlc3NcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgYWRkcmVzc18xLmdldEFkZHJlc3MpKHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuY2FsbEFkZHJlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCEoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykodmFsdWUsIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZHJlc3MgPSAoMCwgYWRkcmVzc18xLmdldEFkZHJlc3MpKCgwLCBieXRlc18xLmhleERhdGFTbGljZSkodmFsdWUsIDEyKSk7XG4gICAgICAgIHJldHVybiAoYWRkcmVzcyA9PT0gY29uc3RhbnRzXzEuQWRkcmVzc1plcm8pID8gbnVsbCA6IGFkZHJlc3M7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmNvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIGFkZHJlc3NfMS5nZXRDb250cmFjdEFkZHJlc3MpKHZhbHVlKTtcbiAgICB9O1xuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJsb2NrVGFnID0gZnVuY3Rpb24gKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tUYWcgPT09IFwiZWFybGllc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImxhdGVzdFwiIHx8IGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiB8fCAoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4VmFsdWUpKGJsb2NrVGFnKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJsb2NrVGFnXCIpO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYSBoYXNoLCBvcHRpb25hbGx5IHJlcXVpcmVzIDB4IHByZWZpeDsgcmV0dXJucyBwcmVmaXhlZCBsb3dlcmNhc2UgaGFzaC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAodmFsdWUsIHN0cmljdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG4gICAgICAgIGlmICgoMCwgYnl0ZXNfMS5oZXhEYXRhTGVuZ3RoKShyZXN1bHQpICE9PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZGlmZmljdWx0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS51aW50MjU2ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghKDAsIGJ5dGVzXzEuaXNIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKSh2YWx1ZSwgMzIpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5fYmxvY2sgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUubWluZXIgPSB2YWx1ZS5hdXRob3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRpZmZpY3VsdHkgbWF5IG5lZWQgdG8gY29tZSBmcm9tIF9kaWZmaWN1bHR5IGluIHJlY3Vyc2VkIGJsb2Nrc1xuICAgICAgICB2YXIgZGlmZmljdWx0eSA9ICh2YWx1ZS5fZGlmZmljdWx0eSAhPSBudWxsKSA/IHZhbHVlLl9kaWZmaWN1bHR5IDogdmFsdWUuZGlmZmljdWx0eTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayhmb3JtYXQsIHZhbHVlKTtcbiAgICAgICAgcmVzdWx0Ll9kaWZmaWN1bHR5ID0gKChkaWZmaWN1bHR5ID09IG51bGwpID8gbnVsbCA6IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKGRpZmZpY3VsdHkpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2sgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2spO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5ibG9ja1dpdGhUcmFuc2FjdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKTtcbiAgICB9O1xuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvblJlcXVlc3QsIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb25SZXNwb25zZSA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBSZW5hbWUgZ2FzIHRvIGdhc0xpbWl0XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXMgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRyYW5zYWN0aW9uLmdhcztcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50byAmJiBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi50bykuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5hbWUgaW5wdXQgdG8gZGF0YVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uaW5wdXQgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSB0cmFuc2FjdGlvbi5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0byBhbmQgY3JlYXRlcyBhcmUgZW1wdHksIHBvcHVsYXRlIHRoZSBjcmVhdGVzIGZyb20gdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50byA9PSBudWxsICYmIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3JlYXRlcyA9IHRoaXMuY29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRyYW5zYWN0aW9uLnR5cGUgPT09IDEgfHwgdHJhbnNhY3Rpb24udHlwZSA9PT0gMikgJiYgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKCgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5uZXR3b3JrSWQ7XG4gICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgICAgIGlmIChjaGFpbklkID09IG51bGwgJiYgcmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBieXRlc18xLmlzSGV4U3RyaW5nKShjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgcmVzdWx0LmJsb2NrSGFzaC5yZXBsYWNlKC8wL2csIFwiXCIpID09PSBcInhcIikge1xuICAgICAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCB0cmFuc2FjdGlvbnNfMS5wYXJzZSkodmFsdWUpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5yZWNlaXB0TG9nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnJlY2VpcHRMb2csIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUucmVjZWlwdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0LCB2YWx1ZSk7XG4gICAgICAgIC8vIFJTSyBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCBFSVAtNjU4LCBzbyB3ZSBtdW5nZSB0aGluZ3MgYSBiaXQgaGVyZSBmb3IgaXRcbiAgICAgICAgaWYgKHJlc3VsdC5yb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucm9vdC5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIDB4MDAsIDB4MCwgMHgwMSBvciAweDFcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHJlc3VsdC5yb290KS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xID09PSAwIHx8IHZhbHVlXzEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGlmIGJvdGggYXJlIHNwZWNpZmllZCwgdGhleSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsICYmIChyZXN1bHQuc3RhdHVzICE9PSB2YWx1ZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFsdC1yb290LXN0YXR1cy9zdGF0dXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZVwiLCB7IHJvb3Q6IHJlc3VsdC5yb290LCBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHZhbHVlXzE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQucm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFsdC1yb290LXN0YXR1c1wiLCBcInZhbHVlLnJvb3RcIiwgcmVzdWx0LnJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5yb290Lmxlbmd0aCAhPT0gNjYpIHtcbiAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIGEgdmFsaWQgYnl0ZXMzMlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJvb3QgaGFzaFwiLCBcInZhbHVlLnJvb3RcIiwgcmVzdWx0LnJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ieXphbnRpdW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRvcGljcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnRvcGljcyh2KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXIsIHZhbHVlKTtcbiAgICB9O1xuICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZmlsdGVyTG9nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlckxvZywgdmFsdWUpO1xuICAgIH07XG4gICAgRm9ybWF0dGVyLmNoZWNrID0gZnVuY3Rpb24gKGZvcm1hdCwgb2JqZWN0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmb3JtYXRba2V5XShvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja0tleSA9IGtleTtcbiAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIGlmIHZhbHVlIGlzIG51bGwtaXNoLCBudWxsVmFsdWUgaXMgcmV0dXJuZWRcbiAgICBGb3JtYXR0ZXIuYWxsb3dOdWxsID0gZnVuY3Rpb24gKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuICAgIEZvcm1hdHRlci5hbGxvd0ZhbHNpc2ggPSBmdW5jdGlvbiAoZm9ybWF0LCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuICAgIEZvcm1hdHRlci5hcnJheU9mID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm9ybWF0KHZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEZvcm1hdHRlcjtcbn0oKSk7XG5leHBvcnRzLkZvcm1hdHRlciA9IEZvcm1hdHRlcjtcbmZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5leHBvcnRzLmlzQ29tbXVuaXR5UmVzb3VyY2FibGUgPSBpc0NvbW11bml0eVJlc291cmNhYmxlO1xuZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkgJiYgdmFsdWUuaXNDb21tdW5pdHlSZXNvdXJjZSgpKTtcbn1cbmV4cG9ydHMuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGlzQ29tbXVuaXR5UmVzb3VyY2U7XG4vLyBTaG93IHRoZSB0aHJvdHRsZSBtZXNzYWdlIG9ubHkgb25jZVxudmFyIHRocm90dGxlTWVzc2FnZSA9IGZhbHNlO1xuZnVuY3Rpb24gc2hvd1Rocm90dGxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhyb3R0bGVNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3R0bGVNZXNzYWdlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdC1SYXRlIEV4Y2VlZGVkICAodGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIHJlcGVhdGVkKVwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG4gICAgY29uc29sZS5sb2coXCJjb21tdW5pdHkgcmVzb3VyY2UgZm9yIGxvdy10cmFmZmljIHByb2plY3RzIGFuZCBlYXJseSBwcm90b3R5cGluZy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcbiAgICBjb25zb2xlLmxvZyhcInNpZ25pbmcgdXAgZm9yIHlvdXIgb3duIEFQSSBrZXlzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIGluY3JlYXNlIHlvdXJcIik7XG4gICAgY29uc29sZS5sb2coXCJyZXF1ZXN0IHJhdGUvbGltaXQgYW5kIGVuYWJsZSBvdGhlciBwZXJrcywgc3VjaCBhcyBtZXRyaWNzIGFuZCBhZHZhbmNlZCBBUElzLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi9cXC9kb2NzLmV0aGVycy5pby9hcGkta2V5cy9cIik7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcbn1cbmV4cG9ydHMuc2hvd1Rocm90dGxlTWVzc2FnZSA9IHNob3dUaHJvdHRsZU1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXR0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Formatter = exports.showThrottleMessage = exports.isCommunityResourcable = exports.isCommunityResource = exports.getNetwork = exports.getDefaultProvider = exports.JsonRpcSigner = exports.IpcProvider = exports.WebSocketProvider = exports.Web3Provider = exports.StaticJsonRpcProvider = exports.PocketProvider = exports.NodesmithProvider = exports.JsonRpcBatchProvider = exports.JsonRpcProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AlchemyWebSocketProvider = exports.AlchemyProvider = exports.FallbackProvider = exports.UrlJsonRpcProvider = exports.Resolver = exports.BaseProvider = exports.Provider = void 0;\nvar abstract_provider_1 = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-provider/lib/index.js\");\nObject.defineProperty(exports, \"Provider\", ({ enumerable: true, get: function () { return abstract_provider_1.Provider; } }));\nvar networks_1 = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/networks/lib/index.js\");\nObject.defineProperty(exports, \"getNetwork\", ({ enumerable: true, get: function () { return networks_1.getNetwork; } }));\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/base-provider.js\");\nObject.defineProperty(exports, \"BaseProvider\", ({ enumerable: true, get: function () { return base_provider_1.BaseProvider; } }));\nObject.defineProperty(exports, \"Resolver\", ({ enumerable: true, get: function () { return base_provider_1.Resolver; } }));\nvar alchemy_provider_1 = __webpack_require__(/*! ./alchemy-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/alchemy-provider.js\");\nObject.defineProperty(exports, \"AlchemyProvider\", ({ enumerable: true, get: function () { return alchemy_provider_1.AlchemyProvider; } }));\nObject.defineProperty(exports, \"AlchemyWebSocketProvider\", ({ enumerable: true, get: function () { return alchemy_provider_1.AlchemyWebSocketProvider; } }));\nvar cloudflare_provider_1 = __webpack_require__(/*! ./cloudflare-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/cloudflare-provider.js\");\nObject.defineProperty(exports, \"CloudflareProvider\", ({ enumerable: true, get: function () { return cloudflare_provider_1.CloudflareProvider; } }));\nvar etherscan_provider_1 = __webpack_require__(/*! ./etherscan-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/etherscan-provider.js\");\nObject.defineProperty(exports, \"EtherscanProvider\", ({ enumerable: true, get: function () { return etherscan_provider_1.EtherscanProvider; } }));\nvar fallback_provider_1 = __webpack_require__(/*! ./fallback-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/fallback-provider.js\");\nObject.defineProperty(exports, \"FallbackProvider\", ({ enumerable: true, get: function () { return fallback_provider_1.FallbackProvider; } }));\nvar ipc_provider_1 = __webpack_require__(/*! ./ipc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/ipc-provider.js\");\nObject.defineProperty(exports, \"IpcProvider\", ({ enumerable: true, get: function () { return ipc_provider_1.IpcProvider; } }));\nvar infura_provider_1 = __webpack_require__(/*! ./infura-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/infura-provider.js\");\nObject.defineProperty(exports, \"InfuraProvider\", ({ enumerable: true, get: function () { return infura_provider_1.InfuraProvider; } }));\nObject.defineProperty(exports, \"InfuraWebSocketProvider\", ({ enumerable: true, get: function () { return infura_provider_1.InfuraWebSocketProvider; } }));\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nObject.defineProperty(exports, \"JsonRpcProvider\", ({ enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcProvider; } }));\nObject.defineProperty(exports, \"JsonRpcSigner\", ({ enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcSigner; } }));\nvar json_rpc_batch_provider_1 = __webpack_require__(/*! ./json-rpc-batch-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js\");\nObject.defineProperty(exports, \"JsonRpcBatchProvider\", ({ enumerable: true, get: function () { return json_rpc_batch_provider_1.JsonRpcBatchProvider; } }));\nvar nodesmith_provider_1 = __webpack_require__(/*! ./nodesmith-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/nodesmith-provider.js\");\nObject.defineProperty(exports, \"NodesmithProvider\", ({ enumerable: true, get: function () { return nodesmith_provider_1.NodesmithProvider; } }));\nvar pocket_provider_1 = __webpack_require__(/*! ./pocket-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/pocket-provider.js\");\nObject.defineProperty(exports, \"PocketProvider\", ({ enumerable: true, get: function () { return pocket_provider_1.PocketProvider; } }));\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nObject.defineProperty(exports, \"StaticJsonRpcProvider\", ({ enumerable: true, get: function () { return url_json_rpc_provider_1.StaticJsonRpcProvider; } }));\nObject.defineProperty(exports, \"UrlJsonRpcProvider\", ({ enumerable: true, get: function () { return url_json_rpc_provider_1.UrlJsonRpcProvider; } }));\nvar web3_provider_1 = __webpack_require__(/*! ./web3-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/web3-provider.js\");\nObject.defineProperty(exports, \"Web3Provider\", ({ enumerable: true, get: function () { return web3_provider_1.Web3Provider; } }));\nvar websocket_provider_1 = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/websocket-provider.js\");\nObject.defineProperty(exports, \"WebSocketProvider\", ({ enumerable: true, get: function () { return websocket_provider_1.WebSocketProvider; } }));\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js\");\nObject.defineProperty(exports, \"Formatter\", ({ enumerable: true, get: function () { return formatter_1.Formatter; } }));\nObject.defineProperty(exports, \"isCommunityResourcable\", ({ enumerable: true, get: function () { return formatter_1.isCommunityResourcable; } }));\nObject.defineProperty(exports, \"isCommunityResource\", ({ enumerable: true, get: function () { return formatter_1.isCommunityResource; } }));\nObject.defineProperty(exports, \"showThrottleMessage\", ({ enumerable: true, get: function () { return formatter_1.showThrottleMessage; } }));\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        var match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new json_rpc_provider_1.JsonRpcProvider(network);\n                case \"ws\":\n                    return new websocket_provider_1.WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    var n = (0, networks_1.getNetwork)(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", logger_1.Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider: fallback_provider_1.FallbackProvider,\n        AlchemyProvider: alchemy_provider_1.AlchemyProvider,\n        CloudflareProvider: cloudflare_provider_1.CloudflareProvider,\n        EtherscanProvider: etherscan_provider_1.EtherscanProvider,\n        InfuraProvider: infura_provider_1.InfuraProvider,\n        JsonRpcProvider: json_rpc_provider_1.JsonRpcProvider,\n        NodesmithProvider: nodesmith_provider_1.NodesmithProvider,\n        PocketProvider: pocket_provider_1.PocketProvider,\n        Web3Provider: web3_provider_1.Web3Provider,\n        IpcProvider: ipc_provider_1.IpcProvider,\n    }, options);\n}\nexports.getDefaultProvider = getDefaultProvider;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLDJCQUEyQixHQUFHLDhCQUE4QixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLG9CQUFvQixHQUFHLDZCQUE2QixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLCtCQUErQixHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLGdDQUFnQyxHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLGdCQUFnQjtBQUNyckIsMEJBQTBCLG1CQUFPLENBQUMsZ0lBQWtDO0FBQ3BFLDRDQUEyQyxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUMzSCxpQkFBaUIsbUJBQU8sQ0FBQyw4R0FBeUI7QUFDbEQsOENBQTZDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3RILHNCQUFzQixtQkFBTyxDQUFDLCtHQUFpQjtBQUMvQyxnREFBK0MsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDL0gsNENBQTJDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3ZILHlCQUF5QixtQkFBTyxDQUFDLHFIQUFvQjtBQUNyRCxtREFBa0QsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDeEksNERBQTJELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQzFKLDRCQUE0QixtQkFBTyxDQUFDLDJIQUF1QjtBQUMzRCxzREFBcUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDakosMkJBQTJCLG1CQUFPLENBQUMseUhBQXNCO0FBQ3pELHFEQUFvRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM5SSwwQkFBMEIsbUJBQU8sQ0FBQyx1SEFBcUI7QUFDdkQsb0RBQW1ELEVBQUUscUNBQXFDLGdEQUFnRCxFQUFDO0FBQzNJLHFCQUFxQixtQkFBTyxDQUFDLDZHQUFnQjtBQUM3QywrQ0FBOEMsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDNUgsd0JBQXdCLG1CQUFPLENBQUMsbUhBQW1CO0FBQ25ELGtEQUFpRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUNySSwyREFBMEQsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDdkosMEJBQTBCLG1CQUFPLENBQUMsdUhBQXFCO0FBQ3ZELG1EQUFrRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUN6SSxpREFBZ0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDckksZ0NBQWdDLG1CQUFPLENBQUMsbUlBQTJCO0FBQ25FLHdEQUF1RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUN6SiwyQkFBMkIsbUJBQU8sQ0FBQyx5SEFBc0I7QUFDekQscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLHdCQUF3QixtQkFBTyxDQUFDLG1IQUFtQjtBQUNuRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckksOEJBQThCLG1CQUFPLENBQUMsK0hBQXlCO0FBQy9ELHlEQUF3RCxFQUFFLHFDQUFxQyx5REFBeUQsRUFBQztBQUN6SixzREFBcUQsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDbkosc0JBQXNCLG1CQUFPLENBQUMsK0dBQWlCO0FBQy9DLGdEQUErQyxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUMvSCwyQkFBMkIsbUJBQU8sQ0FBQyx5SEFBc0I7QUFDekQscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLGtCQUFrQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3ZDLDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCwwREFBeUQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDL0ksdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvaW5kZXguanM/YzNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRm9ybWF0dGVyID0gZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNhYmxlID0gZXhwb3J0cy5pc0NvbW11bml0eVJlc291cmNlID0gZXhwb3J0cy5nZXROZXR3b3JrID0gZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNTaWduZXIgPSBleHBvcnRzLklwY1Byb3ZpZGVyID0gZXhwb3J0cy5XZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuV2ViM1Byb3ZpZGVyID0gZXhwb3J0cy5TdGF0aWNKc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLlBvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0JhdGNoUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLkluZnVyYVByb3ZpZGVyID0gZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gZXhwb3J0cy5BbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IGV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IGV4cG9ydHMuVXJsSnNvblJwY1Byb3ZpZGVyID0gZXhwb3J0cy5SZXNvbHZlciA9IGV4cG9ydHMuQmFzZVByb3ZpZGVyID0gZXhwb3J0cy5Qcm92aWRlciA9IHZvaWQgMDtcbnZhciBhYnN0cmFjdF9wcm92aWRlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFic3RyYWN0X3Byb3ZpZGVyXzEuUHJvdmlkZXI7IH0gfSk7XG52YXIgbmV0d29ya3NfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE5ldHdvcmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldHdvcmtzXzEuZ2V0TmV0d29yazsgfSB9KTtcbnZhciBiYXNlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9iYXNlLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX3Byb3ZpZGVyXzEuQmFzZVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzb2x2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VfcHJvdmlkZXJfMS5SZXNvbHZlcjsgfSB9KTtcbnZhciBhbGNoZW15X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9hbGNoZW15LXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWxjaGVteVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbGNoZW15X3Byb3ZpZGVyXzEuQWxjaGVteVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbGNoZW15X3Byb3ZpZGVyXzEuQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIGNsb3VkZmxhcmVfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2Nsb3VkZmxhcmUtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG91ZGZsYXJlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb3VkZmxhcmVfcHJvdmlkZXJfMS5DbG91ZGZsYXJlUHJvdmlkZXI7IH0gfSk7XG52YXIgZXRoZXJzY2FuX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9ldGhlcnNjYW4tcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcnNjYW5Qcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXRoZXJzY2FuX3Byb3ZpZGVyXzEuRXRoZXJzY2FuUHJvdmlkZXI7IH0gfSk7XG52YXIgZmFsbGJhY2tfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2ZhbGxiYWNrLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmFsbGJhY2tQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsbGJhY2tfcHJvdmlkZXJfMS5GYWxsYmFja1Byb3ZpZGVyOyB9IH0pO1xudmFyIGlwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vaXBjLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSXBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlwY19wcm92aWRlcl8xLklwY1Byb3ZpZGVyOyB9IH0pO1xudmFyIGluZnVyYV9wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vaW5mdXJhLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZnVyYV9wcm92aWRlcl8xLkluZnVyYVByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhV2ViU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZnVyYV9wcm92aWRlcl8xLkluZnVyYVdlYlNvY2tldFByb3ZpZGVyOyB9IH0pO1xudmFyIGpzb25fcnBjX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9qc29uLXJwYy1wcm92aWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9ycGNfcHJvdmlkZXJfMS5Kc29uUnBjUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjU2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX3JwY19wcm92aWRlcl8xLkpzb25ScGNTaWduZXI7IH0gfSk7XG52YXIganNvbl9ycGNfYmF0Y2hfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2pzb24tcnBjLWJhdGNoLXByb3ZpZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblJwY0JhdGNoUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fcnBjX2JhdGNoX3Byb3ZpZGVyXzEuSnNvblJwY0JhdGNoUHJvdmlkZXI7IH0gfSk7XG52YXIgbm9kZXNtaXRoX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9ub2Rlc21pdGgtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb2Rlc21pdGhQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZXNtaXRoX3Byb3ZpZGVyXzEuTm9kZXNtaXRoUHJvdmlkZXI7IH0gfSk7XG52YXIgcG9ja2V0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wb2NrZXQtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcG9ja2V0X3Byb3ZpZGVyXzEuUG9ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgdXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0aWNKc29uUnBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVybF9qc29uX3JwY19wcm92aWRlcl8xLlN0YXRpY0pzb25ScGNQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVybEpzb25ScGNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyOyB9IH0pO1xudmFyIHdlYjNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3dlYjMtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWIzUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYjNfcHJvdmlkZXJfMS5XZWIzUHJvdmlkZXI7IH0gfSk7XG52YXIgd2Vic29ja2V0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXQtcHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2Vic29ja2V0X3Byb3ZpZGVyXzEuV2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG52YXIgZm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi9mb3JtYXR0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb3JtYXR0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcm1hdHRlcl8xLkZvcm1hdHRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQ29tbXVuaXR5UmVzb3VyY2FibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcm1hdHRlcl8xLmlzQ29tbXVuaXR5UmVzb3VyY2FibGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbW11bml0eVJlc291cmNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JtYXR0ZXJfMS5pc0NvbW11bml0eVJlc291cmNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hvd1Rocm90dGxlTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9ybWF0dGVyXzEuc2hvd1Rocm90dGxlTWVzc2FnZTsgfSB9KTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIEZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgIG5ldHdvcmsgPSBcImhvbWVzdGVhZFwiO1xuICAgIH1cbiAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgSXBjUHJvdmlkZXI7IG1heWJlIGlmIGl0IGVuZHMgaW4gXCIuaXBjXCI/XG4gICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcbiAgICAgICAgdmFyIG1hdGNoID0gbmV0d29yay5tYXRjaCgvXih3c3xodHRwKXM/Oi9pKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImh0dHBcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBqc29uX3JwY19wcm92aWRlcl8xLkpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwid3NcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRfcHJvdmlkZXJfMS5XZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgVVJMIHNjaGVtZVwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG4gPSAoMCwgbmV0d29ya3NfMS5nZXROZXR3b3JrKShuZXR3b3JrKTtcbiAgICBpZiAoIW4gfHwgIW4uX2RlZmF1bHRQcm92aWRlcikge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGdldERlZmF1bHRQcm92aWRlciBuZXR3b3JrXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldERlZmF1bHRQcm92aWRlclwiLFxuICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG4uX2RlZmF1bHRQcm92aWRlcih7XG4gICAgICAgIEZhbGxiYWNrUHJvdmlkZXI6IGZhbGxiYWNrX3Byb3ZpZGVyXzEuRmFsbGJhY2tQcm92aWRlcixcbiAgICAgICAgQWxjaGVteVByb3ZpZGVyOiBhbGNoZW15X3Byb3ZpZGVyXzEuQWxjaGVteVByb3ZpZGVyLFxuICAgICAgICBDbG91ZGZsYXJlUHJvdmlkZXI6IGNsb3VkZmxhcmVfcHJvdmlkZXJfMS5DbG91ZGZsYXJlUHJvdmlkZXIsXG4gICAgICAgIEV0aGVyc2NhblByb3ZpZGVyOiBldGhlcnNjYW5fcHJvdmlkZXJfMS5FdGhlcnNjYW5Qcm92aWRlcixcbiAgICAgICAgSW5mdXJhUHJvdmlkZXI6IGluZnVyYV9wcm92aWRlcl8xLkluZnVyYVByb3ZpZGVyLFxuICAgICAgICBKc29uUnBjUHJvdmlkZXI6IGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyLFxuICAgICAgICBOb2Rlc21pdGhQcm92aWRlcjogbm9kZXNtaXRoX3Byb3ZpZGVyXzEuTm9kZXNtaXRoUHJvdmlkZXIsXG4gICAgICAgIFBvY2tldFByb3ZpZGVyOiBwb2NrZXRfcHJvdmlkZXJfMS5Qb2NrZXRQcm92aWRlcixcbiAgICAgICAgV2ViM1Byb3ZpZGVyOiB3ZWIzX3Byb3ZpZGVyXzEuV2ViM1Byb3ZpZGVyLFxuICAgICAgICBJcGNQcm92aWRlcjogaXBjX3Byb3ZpZGVyXzEuSXBjUHJvdmlkZXIsXG4gICAgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGdldERlZmF1bHRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/infura-provider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/infura-provider.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar websocket_provider_1 = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/websocket-provider.js\");\nvar formatter_1 = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/formatter.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar defaultProjectId = \"84842078b09946638c03157f83405213\";\nvar InfuraWebSocketProvider = /** @class */ (function (_super) {\n    __extends(InfuraWebSocketProvider, _super);\n    function InfuraWebSocketProvider(network, apiKey) {\n        var _this = this;\n        var provider = new InfuraProvider(network, apiKey);\n        var connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        var url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        _this = _super.call(this, url, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"apiKey\", provider.projectId);\n        (0, properties_1.defineReadOnly)(_this, \"projectId\", provider.projectId);\n        (0, properties_1.defineReadOnly)(_this, \"projectSecret\", provider.projectSecret);\n        return _this;\n    }\n    InfuraWebSocketProvider.prototype.isCommunityResource = function () {\n        return (this.projectId === defaultProjectId);\n    };\n    return InfuraWebSocketProvider;\n}(websocket_provider_1.WebSocketProvider));\nexports.InfuraWebSocketProvider = InfuraWebSocketProvider;\nvar InfuraProvider = /** @class */ (function (_super) {\n    __extends(InfuraProvider, _super);\n    function InfuraProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    InfuraProvider.getWebSocketProvider = function (network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    };\n    InfuraProvider.getApiKey = function (apiKey) {\n        var apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    };\n    InfuraProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        var connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: function (attempt, url) {\n                if (apiKey.projectId === defaultProjectId) {\n                    (0, formatter_1.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    };\n    InfuraProvider.prototype.isCommunityResource = function () {\n        return (this.projectId === defaultProjectId);\n    };\n    return InfuraProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.InfuraProvider = InfuraProvider;\n//# sourceMappingURL=infura-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2luZnVyYS1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRywrQkFBK0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsa0hBQTJCO0FBQ3RELDJCQUEyQixtQkFBTyxDQUFDLHlIQUFzQjtBQUN6RCxrQkFBa0IsbUJBQU8sQ0FBQyx1R0FBYTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsK0hBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9pbmZ1cmEtcHJvdmlkZXIuanM/NmJiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluZnVyYVByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IHZvaWQgMDtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciB3ZWJzb2NrZXRfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldC1wcm92aWRlclwiKTtcbnZhciBmb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciB1cmxfanNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiKTtcbnZhciBkZWZhdWx0UHJvamVjdElkID0gXCI4NDg0MjA3OGIwOTk0NjYzOGMwMzE1N2Y4MzQwNTIxM1wiO1xudmFyIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gcHJvdmlkZXIuY29ubmVjdGlvbjtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24ucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiSU5GVVJBIFdlYlNvY2tldCBwcm9qZWN0IHNlY3JldHMgdW5zdXBwb3J0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdXJsLCBuZXR3b3JrKSB8fCB0aGlzO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJhcGlLZXlcIiwgcHJvdmlkZXIucHJvamVjdElkKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvamVjdElkXCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcInByb2plY3RTZWNyZXRcIiwgcHJvdmlkZXIucHJvamVjdFNlY3JldCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmlzQ29tbXVuaXR5UmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyO1xufSh3ZWJzb2NrZXRfcHJvdmlkZXJfMS5XZWJTb2NrZXRQcm92aWRlcikpO1xuZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IEluZnVyYVdlYlNvY2tldFByb3ZpZGVyO1xudmFyIEluZnVyYVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZ1cmFQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZ1cmFQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbmZ1cmFQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlciA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpO1xuICAgIH07XG4gICAgSW5mdXJhUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuICAgICAgICB2YXIgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBpS2V5OiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdElkOiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdFNlY3JldDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgPT09IFwic3RyaW5nXCIpLCBcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIiwgXCJwcm9qZWN0SWRcIiwgYXBpS2V5LnByb2plY3RJZCk7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RTZWNyZXQpID09PSBcInN0cmluZ1wiKSwgXCJpbnZhbGlkIHByb2plY3RTZWNyZXRcIiwgXCJwcm9qZWN0U2VjcmV0XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RTZWNyZXQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdElkKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhcGlLZXlPYmouYXBpS2V5ID0gYXBpS2V5T2JqLnByb2plY3RJZDtcbiAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcbiAgICB9O1xuICAgIEluZnVyYVByb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsgPyBuZXR3b3JrLm5hbWUgOiBcInVua25vd25cIikge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJvcHN0ZW4uaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJrb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW11bWJhaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdGltaXNtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc20ta292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHRpbWlzbS1rb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tcmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLXJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBcIi92My9cIiArIGFwaUtleS5wcm9qZWN0SWQpLFxuICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXkucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBmb3JtYXR0ZXJfMS5zaG93VGhyb3R0bGVNZXNzYWdlKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucGFzc3dvcmQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIEluZnVyYVByb3ZpZGVyLnByb3RvdHlwZS5pc0NvbW11bml0eVJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmZ1cmFQcm92aWRlcjtcbn0odXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLkluZnVyYVByb3ZpZGVyID0gSW5mdXJhUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZ1cmEtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/infura-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/ipc-provider.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/ipc-provider.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IpcProvider = void 0;\nvar net_1 = __webpack_require__(/*! net */ \"net\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nvar IpcProvider = /** @class */ (function (_super) {\n    __extends(IpcProvider, _super);\n    function IpcProvider(path, network) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, IpcProvider);\n        if (path == null) {\n            logger.throwError(\"missing path\", logger_1.Logger.errors.MISSING_ARGUMENT, { arg: \"path\" });\n        }\n        _this = _super.call(this, \"ipc://\" + path, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"path\", path);\n        return _this;\n    }\n    // @TODO: Create a connection to the IPC path and use filters instead of polling for block\n    IpcProvider.prototype.send = function (method, params) {\n        // This method is very simple right now. We create a new socket\n        // connection each time, which may be slower, but the main\n        // advantage we are aiming for now is security. This simplifies\n        // multiplexing requests (since we do not need to multiplex).\n        var _this = this;\n        var payload = JSON.stringify({\n            method: method,\n            params: params,\n            id: 42,\n            jsonrpc: \"2.0\"\n        });\n        return new Promise(function (resolve, reject) {\n            var response = Buffer.alloc(0);\n            var stream = (0, net_1.connect)(_this.path);\n            stream.on(\"data\", function (data) {\n                response = Buffer.concat([response, data]);\n            });\n            stream.on(\"end\", function () {\n                try {\n                    resolve(JSON.parse(response.toString()).result);\n                    // @TODO: Better pull apart the error\n                    stream.destroy();\n                }\n                catch (error) {\n                    reject(error);\n                    stream.destroy();\n                }\n            });\n            stream.on(\"error\", function (error) {\n                reject(error);\n                stream.destroy();\n            });\n            stream.write(payload);\n            stream.end();\n        });\n    };\n    return IpcProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.IpcProvider = IpcProvider;\n//# sourceMappingURL=ipc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2lwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG1CQUFtQixtQkFBTyxDQUFDLGtIQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsdUhBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLGFBQWE7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvaXBjLXByb3ZpZGVyLmpzPzM1ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JcGNQcm92aWRlciA9IHZvaWQgMDtcbnZhciBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCIpO1xudmFyIF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvblwiKTtcbnZhciBsb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKF92ZXJzaW9uXzEudmVyc2lvbik7XG52YXIganNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2pzb24tcnBjLXByb3ZpZGVyXCIpO1xudmFyIElwY1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJcGNQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJcGNQcm92aWRlcihwYXRoLCBuZXR3b3JrKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIElwY1Byb3ZpZGVyKTtcbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHBhdGhcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7IGFyZzogXCJwYXRoXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBcImlwYzovL1wiICsgcGF0aCwgbmV0d29yaykgfHwgdGhpcztcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicGF0aFwiLCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQ3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgSVBDIHBhdGggYW5kIHVzZSBmaWx0ZXJzIGluc3RlYWQgb2YgcG9sbGluZyBmb3IgYmxvY2tcbiAgICBJcGNQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyB2ZXJ5IHNpbXBsZSByaWdodCBub3cuIFdlIGNyZWF0ZSBhIG5ldyBzb2NrZXRcbiAgICAgICAgLy8gY29ubmVjdGlvbiBlYWNoIHRpbWUsIHdoaWNoIG1heSBiZSBzbG93ZXIsIGJ1dCB0aGUgbWFpblxuICAgICAgICAvLyBhZHZhbnRhZ2Ugd2UgYXJlIGFpbWluZyBmb3Igbm93IGlzIHNlY3VyaXR5LiBUaGlzIHNpbXBsaWZpZXNcbiAgICAgICAgLy8gbXVsdGlwbGV4aW5nIHJlcXVlc3RzIChzaW5jZSB3ZSBkbyBub3QgbmVlZCB0byBtdWx0aXBsZXgpLlxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogNDIsXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICAgICAgdmFyIHN0cmVhbSA9ICgwLCBuZXRfMS5jb25uZWN0KShfdGhpcy5wYXRoKTtcbiAgICAgICAgICAgIHN0cmVhbS5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEJ1ZmZlci5jb25jYXQoW3Jlc3BvbnNlLCBkYXRhXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHJlc3BvbnNlLnRvU3RyaW5nKCkpLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBCZXR0ZXIgcHVsbCBhcGFydCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSXBjUHJvdmlkZXI7XG59KGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLklwY1Byb3ZpZGVyID0gSXBjUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcGMtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/ipc-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonRpcBatchProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js\");\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\n// Experimental\nvar JsonRpcBatchProvider = /** @class */ (function (_super) {\n    __extends(JsonRpcBatchProvider, _super);\n    function JsonRpcBatchProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    JsonRpcBatchProvider.prototype.send = function (method, params) {\n        var _this = this;\n        var request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        var inflightRequest = { request: request, resolve: null, reject: null };\n        var promise = new Promise(function (resolve, reject) {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(function () {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                var batch = _this._pendingBatch;\n                _this._pendingBatch = null;\n                _this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                var request = batch.map(function (inflight) { return inflight.request; });\n                _this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: (0, properties_1.deepCopy)(request),\n                    provider: _this\n                });\n                return (0, web_1.fetchJson)(_this.connection, JSON.stringify(request)).then(function (result) {\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: _this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach(function (inflightRequest, index) {\n                        var payload = result[index];\n                        if (payload.error) {\n                            var error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, function (error) {\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: _this\n                    });\n                    batch.forEach(function (inflightRequest) {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    };\n    return JsonRpcBatchProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.JsonRpcBatchProvider = JsonRpcBatchProvider;\n//# sourceMappingURL=json-rpc-batch-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2pzb24tcnBjLWJhdGNoLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQsWUFBWSxtQkFBTyxDQUFDLG9HQUFvQjtBQUN4QywwQkFBMEIsbUJBQU8sQ0FBQyx1SEFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMEJBQTBCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIvanNvbi1ycGMtYmF0Y2gtcHJvdmlkZXIuanM/NTliNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGNCYXRjaFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCIpO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG4vLyBFeHBlcmltZW50YWxcbnZhciBKc29uUnBjQmF0Y2hQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSnNvblJwY0JhdGNoUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSnNvblJwY0JhdGNoUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSnNvblJwY0JhdGNoUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQmF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZmxpZ2h0UmVxdWVzdCA9IHsgcmVxdWVzdDogcmVxdWVzdCwgcmVzb2x2ZTogbnVsbCwgcmVqZWN0OiBudWxsIH07XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaC5wdXNoKGluZmxpZ2h0UmVxdWVzdCk7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcikge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYmF0Y2ggZm9yIG5leHQgZXZlbnQgbG9vcCArIHNob3J0IGR1cmF0aW9uXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2hBZ2dyZWdhdG9yID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRlaCBjdXJyZW50IGJhdGNoIGFuZCBjbGVhciBpdCwgc28gbmV3IHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgLy8gZ28gaW50byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IF90aGlzLl9wZW5kaW5nQmF0Y2g7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdCYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdCYXRjaEFnZ3JlZ2F0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVxdWVzdCBhcyBhbiBhcnJheSBvZiByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gYmF0Y2gubWFwKGZ1bmN0aW9uIChpbmZsaWdodCkgeyByZXR1cm4gaW5mbGlnaHQucmVxdWVzdDsgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RCYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiAoMCwgcHJvcGVydGllc18xLmRlZXBDb3B5KShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB3ZWJfMS5mZXRjaEpzb24pKF90aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gd2hldGhlciBpdCB3YXMgYSBzdWNjZXNzIG9yIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goZnVuY3Rpb24gKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gcmVzdWx0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaChmdW5jdGlvbiAoaW5mbGlnaHRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvblJwY0JhdGNoUHJvdmlkZXI7XG59KGpzb25fcnBjX3Byb3ZpZGVyXzEuSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLkpzb25ScGNCYXRjaFByb3ZpZGVyID0gSnNvblJwY0JhdGNoUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1iYXRjaC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsonRpcProvider = exports.JsonRpcSigner = void 0;\nvar abstract_signer_1 = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/abstract-signer/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar hash_1 = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/hash/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nvar transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/index.js\");\nvar web_1 = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar base_provider_1 = __webpack_require__(/*! ./base-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/base-provider.js\");\nvar errorGas = [\"call\", \"estimateGas\"];\nfunction checkError(method, error, params) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === logger_1.Logger.errors.SERVER_ERROR) {\n        var e = error.error;\n        if (e && e.message.match(\"reverted\") && (0, bytes_1.isHexString)(e.data)) {\n            return e.data;\n        }\n        logger.throwError(\"missing revert data in call exception\", logger_1.Logger.errors.CALL_EXCEPTION, {\n            error: error,\n            data: \"0x\"\n        });\n    }\n    var message = error.message;\n    if (error.code === logger_1.Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    var transaction = params.transaction || params.signedTransaction;\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", logger_1.Logger.errors.NONCE_EXPIRED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error: error,\n            method: method,\n            transaction: transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        var error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nvar _constructorGuard = {};\nvar JsonRpcSigner = /** @class */ (function (_super) {\n    __extends(JsonRpcSigner, _super);\n    function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, JsonRpcSigner);\n        _this = _super.call(this) || this;\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        (0, properties_1.defineReadOnly)(_this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            (0, properties_1.defineReadOnly)(_this, \"_address\", _this.provider.formatter.address(addressOrIndex));\n            (0, properties_1.defineReadOnly)(_this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            (0, properties_1.defineReadOnly)(_this, \"_index\", addressOrIndex);\n            (0, properties_1.defineReadOnly)(_this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n        return _this;\n    }\n    JsonRpcSigner.prototype.connect = function (provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    };\n    JsonRpcSigner.prototype.connectUnchecked = function () {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    };\n    JsonRpcSigner.prototype.getAddress = function () {\n        var _this = this;\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then(function (accounts) {\n            if (accounts.length <= _this._index) {\n                logger.throwError(\"unknown account #\" + _this._index, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return _this.provider.formatter.address(accounts[_this._index]);\n        });\n    };\n    JsonRpcSigner.prototype.sendUncheckedTransaction = function (transaction) {\n        var _this = this;\n        transaction = (0, properties_1.shallowCopy)(transaction);\n        var fromAddress = this.getAddress().then(function (address) {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            var estimate = (0, properties_1.shallowCopy)(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(function (to) { return __awaiter(_this, void 0, void 0, function () {\n                var address;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (to == null) {\n                                return [2 /*return*/, null];\n                            }\n                            return [4 /*yield*/, this.provider.resolveName(to)];\n                        case 1:\n                            address = _a.sent();\n                            if (address == null) {\n                                logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                            }\n                            return [2 /*return*/, address];\n                    }\n                });\n            }); });\n        }\n        return (0, properties_1.resolveProperties)({\n            tx: (0, properties_1.resolveProperties)(transaction),\n            sender: fromAddress\n        }).then(function (_a) {\n            var tx = _a.tx, sender = _a.sender;\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return _this.provider.send(\"eth_sendTransaction\", [hexTx]).then(function (hash) {\n                return hash;\n            }, function (error) {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    };\n    JsonRpcSigner.prototype.signTransaction = function (transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    };\n    JsonRpcSigner.prototype.sendTransaction = function (transaction) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumber, hash, error_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval)];\n                    case 1:\n                        blockNumber = _a.sent();\n                        return [4 /*yield*/, this.sendUncheckedTransaction(transaction)];\n                    case 2:\n                        hash = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var tx;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, this.provider.getTransaction(hash)];\n                                        case 1:\n                                            tx = _a.sent();\n                                            if (tx === null) {\n                                                return [2 /*return*/, undefined];\n                                            }\n                                            return [2 /*return*/, this.provider._wrapTransaction(tx, hash, blockNumber)];\n                                    }\n                                });\n                            }); }, { oncePoll: this.provider })];\n                    case 4: \n                    // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                    // for a response, and we need the actual transaction, so we poll\n                    // for it; it should show up very quickly\n                    return [2 /*return*/, _a.sent()];\n                    case 5:\n                        error_1 = _a.sent();\n                        error_1.transactionHash = hash;\n                        throw error_1;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype.signMessage = function (message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var data, address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        data = ((typeof (message) === \"string\") ? (0, strings_1.toUtf8Bytes)(message) : message);\n                        return [4 /*yield*/, this.getAddress()];\n                    case 1:\n                        address = _a.sent();\n                        return [4 /*yield*/, this.provider.send(\"personal_sign\", [(0, bytes_1.hexlify)(data), address.toLowerCase()])];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype._legacySignMessage = function (message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var data, address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        data = ((typeof (message) === \"string\") ? (0, strings_1.toUtf8Bytes)(message) : message);\n                        return [4 /*yield*/, this.getAddress()];\n                    case 1:\n                        address = _a.sent();\n                        return [4 /*yield*/, this.provider.send(\"eth_sign\", [address.toLowerCase(), (0, bytes_1.hexlify)(data)])];\n                    case 2: \n                    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                    return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype._signTypedData = function (domain, types, value) {\n        return __awaiter(this, void 0, void 0, function () {\n            var populated, address;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function (name) {\n                            return _this.provider.resolveName(name);\n                        })];\n                    case 1:\n                        populated = _a.sent();\n                        return [4 /*yield*/, this.getAddress()];\n                    case 2:\n                        address = _a.sent();\n                        return [4 /*yield*/, this.provider.send(\"eth_signTypedData_v4\", [\n                                address.toLowerCase(),\n                                JSON.stringify(hash_1._TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                            ])];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    JsonRpcSigner.prototype.unlock = function (password) {\n        return __awaiter(this, void 0, void 0, function () {\n            var provider, address;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        provider = this.provider;\n                        return [4 /*yield*/, this.getAddress()];\n                    case 1:\n                        address = _a.sent();\n                        return [2 /*return*/, provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null])];\n                }\n            });\n        });\n    };\n    return JsonRpcSigner;\n}(abstract_signer_1.Signer));\nexports.JsonRpcSigner = JsonRpcSigner;\nvar UncheckedJsonRpcSigner = /** @class */ (function (_super) {\n    __extends(UncheckedJsonRpcSigner, _super);\n    function UncheckedJsonRpcSigner() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    UncheckedJsonRpcSigner.prototype.sendTransaction = function (transaction) {\n        var _this = this;\n        return this.sendUncheckedTransaction(transaction).then(function (hash) {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: function (confirmations) { return _this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    };\n    return UncheckedJsonRpcSigner;\n}(JsonRpcSigner));\nvar allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nvar JsonRpcProvider = /** @class */ (function (_super) {\n    __extends(JsonRpcProvider, _super);\n    function JsonRpcProvider(url, network) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, JsonRpcProvider);\n        var networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise(function (resolve, reject) {\n                setTimeout(function () {\n                    _this.detectNetwork().then(function (network) {\n                        resolve(network);\n                    }, function (error) {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        _this = _super.call(this, networkOrReady) || this;\n        // Default URL\n        if (!url) {\n            url = (0, properties_1.getStatic)(_this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            (0, properties_1.defineReadOnly)(_this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            (0, properties_1.defineReadOnly)(_this, \"connection\", Object.freeze((0, properties_1.shallowCopy)(url)));\n        }\n        _this._nextId = 42;\n        return _this;\n    }\n    Object.defineProperty(JsonRpcProvider.prototype, \"_cache\", {\n        get: function () {\n            if (this._eventLoopCache == null) {\n                this._eventLoopCache = {};\n            }\n            return this._eventLoopCache;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    JsonRpcProvider.defaultUrl = function () {\n        return \"http:/\\/localhost:8545\";\n    };\n    JsonRpcProvider.prototype.detectNetwork = function () {\n        var _this = this;\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(function () {\n                _this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    };\n    JsonRpcProvider.prototype._uncachedDetectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var chainId, error_2, error_3, getNetwork;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, timer(0)];\n                    case 1:\n                        _a.sent();\n                        chainId = null;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 9]);\n                        return [4 /*yield*/, this.send(\"eth_chainId\", [])];\n                    case 3:\n                        chainId = _a.sent();\n                        return [3 /*break*/, 9];\n                    case 4:\n                        error_2 = _a.sent();\n                        _a.label = 5;\n                    case 5:\n                        _a.trys.push([5, 7, , 8]);\n                        return [4 /*yield*/, this.send(\"net_version\", [])];\n                    case 6:\n                        chainId = _a.sent();\n                        return [3 /*break*/, 8];\n                    case 7:\n                        error_3 = _a.sent();\n                        return [3 /*break*/, 8];\n                    case 8: return [3 /*break*/, 9];\n                    case 9:\n                        if (chainId != null) {\n                            getNetwork = (0, properties_1.getStatic)(this.constructor, \"getNetwork\");\n                            try {\n                                return [2 /*return*/, getNetwork(bignumber_1.BigNumber.from(chainId).toNumber())];\n                            }\n                            catch (error) {\n                                return [2 /*return*/, logger.throwError(\"could not detect network\", logger_1.Logger.errors.NETWORK_ERROR, {\n                                        chainId: chainId,\n                                        event: \"invalidNetwork\",\n                                        serverError: error\n                                    })];\n                            }\n                        }\n                        return [2 /*return*/, logger.throwError(\"could not detect network\", logger_1.Logger.errors.NETWORK_ERROR, {\n                                event: \"noNetwork\"\n                            })];\n                }\n            });\n        });\n    };\n    JsonRpcProvider.prototype.getSigner = function (addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    };\n    JsonRpcProvider.prototype.getUncheckedSigner = function (addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    };\n    JsonRpcProvider.prototype.listAccounts = function () {\n        var _this = this;\n        return this.send(\"eth_accounts\", []).then(function (accounts) {\n            return accounts.map(function (a) { return _this.formatter.address(a); });\n        });\n    };\n    JsonRpcProvider.prototype.send = function (method, params) {\n        var _this = this;\n        var request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: (0, properties_1.deepCopy)(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        var cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        var result = (0, web_1.fetchJson)(this.connection, JSON.stringify(request), getResult).then(function (result) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: _this\n            });\n            return result;\n        }, function (error) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: _this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(function () {\n                _this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    };\n    JsonRpcProvider.prototype.prepareRequest = function (method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    };\n    JsonRpcProvider.prototype.perform = function (method, params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, feeData, args, error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(method === \"call\" || method === \"estimateGas\")) return [3 /*break*/, 2];\n                        tx = params.transaction;\n                        if (!(tx && tx.type != null && bignumber_1.BigNumber.from(tx.type).isZero())) return [3 /*break*/, 2];\n                        if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.getFeeData()];\n                    case 1:\n                        feeData = _a.sent();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = (0, properties_1.shallowCopy)(params);\n                            params.transaction = (0, properties_1.shallowCopy)(tx);\n                            delete params.transaction.type;\n                        }\n                        _a.label = 2;\n                    case 2:\n                        args = this.prepareRequest(method, params);\n                        if (args == null) {\n                            logger.throwError(method + \" not implemented\", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n                        }\n                        _a.label = 3;\n                    case 3:\n                        _a.trys.push([3, 5, , 6]);\n                        return [4 /*yield*/, this.send(args[0], args[1])];\n                    case 4: return [2 /*return*/, _a.sent()];\n                    case 5:\n                        error_4 = _a.sent();\n                        return [2 /*return*/, checkError(method, error_4, params)];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    JsonRpcProvider.prototype._startEvent = function (event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        _super.prototype._startEvent.call(this, event);\n    };\n    JsonRpcProvider.prototype._startPending = function () {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        var self = this;\n        var pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    var seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch(function (error) { });\n            }\n            poll();\n            return filterId;\n        }).catch(function (error) { });\n    };\n    JsonRpcProvider.prototype._stopEvent = function (event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        _super.prototype._stopEvent.call(this, event);\n    };\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    JsonRpcProvider.hexlifyTransaction = function (transaction, allowExtra) {\n        // Check only allowed properties are given\n        var allowed = (0, properties_1.shallowCopy)(allowedTransactionKeys);\n        if (allowExtra) {\n            for (var key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        (0, properties_1.checkProperties)(transaction, allowed);\n        var result = {};\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            var value = (0, bytes_1.hexValue)(transaction[key]);\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = (0, bytes_1.hexlify)(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = (0, transactions_1.accessListify)(transaction.accessList);\n        }\n        return result;\n    };\n    return JsonRpcProvider;\n}(base_provider_1.BaseProvider));\nexports.JsonRpcProvider = JsonRpcProvider;\n//# sourceMappingURL=json-rpc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL2pzb24tcnBjLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxxQkFBcUI7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsNEhBQWdDO0FBQ2hFLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsa0hBQTJCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLDRHQUF3QjtBQUNoRCxxQkFBcUIsbUJBQU8sQ0FBQyxzSEFBNkI7QUFDMUQsWUFBWSxtQkFBTyxDQUFDLG9HQUFvQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsK0dBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLElBQUksSUFBSSx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0NBQW9DO0FBQ25GLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxZQUFZO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixZQUFZO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILG1CQUFtQjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9qc29uLXJwYy1wcm92aWRlci5qcz81NTA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY1NpZ25lciA9IHZvaWQgMDtcbnZhciBhYnN0cmFjdF9zaWduZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXJcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2hhc2hcIik7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCIpO1xudmFyIHdlYl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3dlYlwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBiYXNlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9iYXNlLXByb3ZpZGVyXCIpO1xudmFyIGVycm9yR2FzID0gW1wiY2FsbFwiLCBcImVzdGltYXRlR2FzXCJdO1xuZnVuY3Rpb24gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCBwYXJhbXMpIHtcbiAgICAvLyBVbmRvIHRoZSBcImNvbnZlbmllbmNlXCIgc29tZSBub2RlcyBhcmUgYXR0ZW1wdGluZyB0byBwcmV2ZW50IGJhY2t3YXJkc1xuICAgIC8vIGluY29tcGF0aWJpbGl0eTsgbWF5YmUgZm9yIHY2IGNvbnNpZGVyIGZvcndhcmRpbmcgcmV2ZXJ0cyBhcyBlcnJvcnNcbiAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIiAmJiBlcnJvci5jb2RlID09PSBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICB2YXIgZSA9IGVycm9yLmVycm9yO1xuICAgICAgICBpZiAoZSAmJiBlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSAmJiAoMCwgYnl0ZXNfMS5pc0hleFN0cmluZykoZS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb25cIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgZGF0YTogXCIweFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09IGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SICYmIGVycm9yLmVycm9yICYmIHR5cGVvZiAoZXJyb3IuZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IuYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmJvZHk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IucmVzcG9uc2VUZXh0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgICBtZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdHJhbnNhY3Rpb24gPSBwYXJhbXMudHJhbnNhY3Rpb24gfHwgcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uO1xuICAgIC8vIFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBnYXMgKiBwcmljZSArIHZhbHVlICsgY29zdChkYXRhKVwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlIHRvbyBsb3cvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3JHYXMuaW5kZXhPZihtZXRob2QpID49IDAgJiYgbWVzc2FnZS5tYXRjaCgvZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlfGFsd2F5cyBmYWlsaW5nIHRyYW5zYWN0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiB0aW1lcih0aW1lb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZXN1bHQocGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG52YXIgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbnZhciBKc29uUnBjU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKc29uUnBjU2lnbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpzb25ScGNTaWduZXIoY29uc3RydWN0b3JHdWFyZCwgcHJvdmlkZXIsIGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEpzb25ScGNTaWduZXIpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG8gbm90IGNhbGwgdGhlIEpzb25ScGNTaWduZXIgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBwcm92aWRlci5nZXRTaWduZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICBpZiAoYWRkcmVzc09ySW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzc09ySW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX2FkZHJlc3NcIiwgX3RoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzc09ySW5kZXgpKTtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9pbmRleFwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcIl9hZGRyZXNzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBpbmRleFwiLCBcImFkZHJlc3NPckluZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuY29ubmVjdFVuY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmNoZWNrZWRKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLnByb3ZpZGVyLCB0aGlzLl9hZGRyZXNzIHx8IHRoaXMuX2luZGV4KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9hZGRyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2FkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oZnVuY3Rpb24gKGFjY291bnRzKSB7XG4gICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDw9IF90aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIiArIF90aGlzLl9pbmRleCwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEFkZHJlc3NcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFjY291bnRzW190aGlzLl9pbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0cmFuc2FjdGlvbiA9ICgwLCBwcm9wZXJ0aWVzXzEuc2hhbGxvd0NvcHkpKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgdmFyIGZyb21BZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzKCkudGhlbihmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgSlNPTi1SUEMgZm9yIGV0aF9zZW5kVHJhbnNhY3Rpb24gdXNlcyA5MDAwMCBnYXM7IGlmIHRoZSB1c2VyXG4gICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSBsb29rIGl0IHVwIGZvciB0aGVtLlxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGVzdGltYXRlID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oZnVuY3Rpb24gKHRvKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKHRvKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHByb3BlcnRpZXNfMS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgdHg6ICgwLCBwcm9wZXJ0aWVzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3NcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0eCA9IF9hLnR4LCBzZW5kZXIgPSBfYS5zZW5kZXI7XG4gICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmZyb20udG9Mb3dlckNhc2UoKSAhPT0gc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IHNlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZXhUeCA9IF90aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCwgeyBmcm9tOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBoZXhUeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwic2lnbmluZyB0cmFuc2FjdGlvbnMgaXMgdW5zdXBwb3J0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduVHJhbnNhY3Rpb25cIlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tOdW1iZXIsIGhhc2gsIGVycm9yXzE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMywgNSwgLCA2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgd2ViXzEucG9sbCkoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucHJvdmlkZXIuX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgYmxvY2tOdW1iZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMucHJvdmlkZXIgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IFxuICAgICAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBKU09OLVJQQyBvbmx5IHByb3ZpZGVzIGFuZCBvcGFxdWUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgaXQ7IGl0IHNob3VsZCBzaG93IHVwIHZlcnkgcXVpY2tseVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEudHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNpZ25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEsIGFkZHJlc3M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gKCh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/ICgwLCBzdHJpbmdzXzEudG9VdGY4Qnl0ZXMpKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEFkZHJlc3MoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF9zaWduXCIsIFsoMCwgYnl0ZXNfMS5oZXhsaWZ5KShkYXRhKSwgYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLl9sZWdhY3lTaWduTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBhZGRyZXNzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyAoMCwgc3RyaW5nc18xLnRvVXRmOEJ5dGVzKShtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRBZGRyZXNzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW2FkZHJlc3MudG9Mb3dlckNhc2UoKSwgKDAsIGJ5dGVzXzEuaGV4bGlmeSkoZGF0YSldKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuX3NpZ25UeXBlZERhdGEgPSBmdW5jdGlvbiAoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvcHVsYXRlZCwgYWRkcmVzcztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGhhc2hfMS5fVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1bGF0ZWQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEFkZHJlc3MoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoaGFzaF8xLl9UeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnVubG9jayA9IGZ1bmN0aW9uIChwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIsIGFkZHJlc3M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHRoaXMucHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEFkZHJlc3MoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIiwgW2FkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxdKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb25ScGNTaWduZXI7XG59KGFic3RyYWN0X3NpZ25lcl8xLlNpZ25lcikpO1xuZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0gSnNvblJwY1NpZ25lcjtcbnZhciBVbmNoZWNrZWRKc29uUnBjU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbmNoZWNrZWRKc29uUnBjU2lnbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuY2hlY2tlZEpzb25ScGNTaWduZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVW5jaGVja2VkSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGdhc0xpbWl0OiBudWxsLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zOiAwLFxuICAgICAgICAgICAgICAgIGZyb206IG51bGwsXG4gICAgICAgICAgICAgICAgd2FpdDogZnVuY3Rpb24gKGNvbmZpcm1hdGlvbnMpIHsgcmV0dXJuIF90aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBjb25maXJtYXRpb25zKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5jaGVja2VkSnNvblJwY1NpZ25lcjtcbn0oSnNvblJwY1NpZ25lcikpO1xudmFyIGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZVxufTtcbnZhciBKc29uUnBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpzb25ScGNQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKc29uUnBjUHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEpzb25ScGNQcm92aWRlcik7XG4gICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IG5ldHdvcms7XG4gICAgICAgIC8vIFRoZSBuZXR3b3JrIGlzIHVua25vd24sIHF1ZXJ5IHRoZSBKU09OLVJQQyBmb3IgaXRcbiAgICAgICAgaWYgKG5ldHdvcmtPclJlYWR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihmdW5jdGlvbiAobmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV0d29ya09yUmVhZHkpIHx8IHRoaXM7XG4gICAgICAgIC8vIERlZmF1bHQgVVJMXG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB1cmwgPSAoMCwgcHJvcGVydGllc18xLmdldFN0YXRpYykoX3RoaXMuY29uc3RydWN0b3IsIFwiZGVmYXVsdFVybFwiKSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSgoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KSh1cmwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX25leHRJZCA9IDQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLCBcIl9jYWNoZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50TG9vcENhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudExvb3BDYWNoZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9vcENhY2hlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSnNvblJwY1Byb3ZpZGVyLmRlZmF1bHRVcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgfTtcbiAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0gPSB0aGlzLl91bmNhY2hlZERldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoaXMgY2FjaGUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl07XG4gICAgfTtcbiAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl91bmNhY2hlZERldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbklkLCBlcnJvcl8yLCBlcnJvcl8zLCBnZXROZXR3b3JrO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aW1lcigwKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDQsICwgOV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzUsIDcsICwgOF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIiwgW10pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXROZXR3b3JrID0gKDAsIHByb3BlcnRpZXNfMS5nZXRTdGF0aWMpKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0TmV0d29ya1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0TmV0d29yayhiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJjb3VsZCBub3QgZGV0ZWN0IG5ldHdvcmtcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJpbnZhbGlkTmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwibm9OZXR3b3JrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5nZXRTaWduZXIgPSBmdW5jdGlvbiAoYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLCBhZGRyZXNzT3JJbmRleCk7XG4gICAgfTtcbiAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmdldFVuY2hlY2tlZFNpZ25lciA9IGZ1bmN0aW9uIChhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaWduZXIoYWRkcmVzc09ySW5kZXgpLmNvbm5lY3RVbmNoZWNrZWQoKTtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUubGlzdEFjY291bnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50cykge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gX3RoaXMuZm9ybWF0dGVyLmFkZHJlc3MoYSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6ICgwLCBwcm9wZXJ0aWVzXzEuZGVlcENvcHkpKHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXG4gICAgICAgIHZhciBjYWNoZSA9IChbXCJldGhfY2hhaW5JZFwiLCBcImV0aF9ibG9ja051bWJlclwiXS5pbmRleE9mKG1ldGhvZCkgPj0gMCk7XG4gICAgICAgIGlmIChjYWNoZSAmJiB0aGlzLl9jYWNoZVttZXRob2RdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIHdlYl8xLmZldGNoSnNvbikodGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSwgZ2V0UmVzdWx0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGZldGNoLCBidXQgY2xlYXIgaXQgb24gdGhlIG5leHQgZXZlbnQgbG9vcFxuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSByZXN1bHQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5wcmVwYXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9ibG9ja051bWJlclwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLCBbcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLCBbcGFyYW1zLmJsb2NrVGFnLCAhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCbG9ja0J5SGFzaFwiLCBbcGFyYW1zLmJsb2NrSGFzaCwgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBbcGFyYW1zLnRyYW5zYWN0aW9uSGFzaF1dO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgICAgIHZhciBoZXhsaWZ5VHJhbnNhY3Rpb24gPSAoMCwgcHJvcGVydGllc18xLmdldFN0YXRpYykodGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgaGV4bGlmeVRyYW5zYWN0aW9uID0gKDAsIHByb3BlcnRpZXNfMS5nZXRTdGF0aWMpKHRoaXMuY29uc3RydWN0b3IsIFwiaGV4bGlmeVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZXN0aW1hdGVHYXNcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlciAmJiBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocGFyYW1zLmZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRMb2dzXCIsIFtwYXJhbXMuZmlsdGVyXV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eCwgZmVlRGF0YSwgYXJncywgZXJyb3JfNDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgbWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gcGFyYW1zLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHggJiYgdHgudHlwZSAhPSBudWxsICYmIGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHR4LnR5cGUpLmlzWmVybygpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEZlZURhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlZURhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qga25vdyBhYm91dCBFSVAtMTU1OSAoYW5kIGhlbmNlIHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHJhbnNhY3Rpb24gPSAoMCwgcHJvcGVydGllc18xLnNoYWxsb3dDb3B5KSh0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy50cmFuc2FjdGlvbi50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfNCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3JfNCwgcGFyYW1zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UGVuZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl9zdGFydFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwZW5kaW5nRmlsdGVyID0gdGhpcy5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdGaWx0ZXIgPSBwZW5kaW5nRmlsdGVyO1xuICAgICAgICBwZW5kaW5nRmlsdGVyLnRoZW4oZnVuY3Rpb24gKGZpbHRlcklkKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2xsKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pLnRoZW4oZnVuY3Rpb24gKGhhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYXQgc29tZSBwb2ludC4uLiBIb3c/IFdoZW4/XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkW1widDpcIiArIGhhc2gudG9Mb3dlckNhc2UoKV0gPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcSA9IHNlcS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRUcmFuc2FjdGlvbihoYXNoKS50aGVuKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJwZW5kaW5nXCIsIHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBwb2xsKCk7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyB9KTtcbiAgICB9O1xuICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFnID09PSBcInBlbmRpbmdcIiAmJiB0aGlzLmxpc3RlbmVyQ291bnQoXCJwZW5kaW5nXCIpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9zdG9wRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICAvLyBDb252ZXJ0IGFuIGV0aGVycy5qcyB0cmFuc2FjdGlvbiBpbnRvIGEgSlNPTi1SUEMgdHJhbnNhY3Rpb25cbiAgICAvLyAgLSBnYXNMaW1pdCA9PiBnYXNcbiAgICAvLyAgLSBBbGwgdmFsdWVzIGhleGxpZmllZFxuICAgIC8vICAtIEFsbCBudW1lcmljIHZhbHVlcyB6ZXJvLXN0cmlwZWRcbiAgICAvLyAgLSBBbGwgYWRkcmVzc2VzIGFyZSBsb3dlcmNhc2VkXG4gICAgLy8gTk9URTogVGhpcyBhbGxvd3MgYSBUcmFuc2FjdGlvblJlcXVlc3QsIGJ1dCBhbGwgdmFsdWVzIHNob3VsZCBiZSByZXNvbHZlZFxuICAgIC8vICAgICAgIGJlZm9yZSB0aGlzIGlzIGNhbGxlZFxuICAgIC8vIEBUT0RPOiBUaGlzIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIGFuZCBwcmVwYXJlUmVxdWVzdFxuICAgIC8vICAgICAgICB3aWxsIGJlIHRoZSBwcmVmZXJyZWQgbWV0aG9kIGZvciB0aGlzLlxuICAgIEpzb25ScGNQcm92aWRlci5oZXhsaWZ5VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGFsbG93RXh0cmEpIHtcbiAgICAgICAgLy8gQ2hlY2sgb25seSBhbGxvd2VkIHByb3BlcnRpZXMgYXJlIGdpdmVuXG4gICAgICAgIHZhciBhbGxvd2VkID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgICAgIGlmIChhbGxvd0V4dHJhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5jaGVja1Byb3BlcnRpZXMpKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBTb21lIG5vZGVzIChJTkZVUkEgcm9wc3RlbjsgSU5GVVJBIG1haW5uZXQgaXMgZmluZSkgZG8gbm90IGxpa2UgbGVhZGluZyB6ZXJvcy5cbiAgICAgICAgW1wiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gKDAsIGJ5dGVzXzEuaGV4VmFsdWUpKHRyYW5zYWN0aW9uW2tleV0pO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gXCJnYXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gKDAsIGJ5dGVzXzEuaGV4bGlmeSkodHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9ICgwLCB0cmFuc2FjdGlvbnNfMS5hY2Nlc3NMaXN0aWZ5KSh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEpzb25ScGNQcm92aWRlcjtcbn0oYmFzZV9wcm92aWRlcl8xLkJhc2VQcm92aWRlcikpO1xuZXhwb3J0cy5Kc29uUnBjUHJvdmlkZXIgPSBKc29uUnBjUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/nodesmith-provider.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/nodesmith-provider.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/* istanbul ignore file */\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodesmithProvider = void 0;\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n// Special API key provided by Nodesmith for ethers.js\nvar defaultApiKey = \"ETHERS_JS_SHARED\";\nvar NodesmithProvider = /** @class */ (function (_super) {\n    __extends(NodesmithProvider, _super);\n    function NodesmithProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NodesmithProvider.getApiKey = function (apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    };\n    NodesmithProvider.getUrl = function (network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        var host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    };\n    return NodesmithProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.NodesmithProvider = NodesmithProvider;\n//# sourceMappingURL=nodesmith-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL25vZGVzbWl0aC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qiw4QkFBOEIsbUJBQU8sQ0FBQywrSEFBeUI7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLDBHQUF1QjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQyxxR0FBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi9ub2Rlc21pdGgtcHJvdmlkZXIuanM/NzhhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IHZvaWQgMDtcbnZhciB1cmxfanNvbl9ycGNfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbi8vIFNwZWNpYWwgQVBJIGtleSBwcm92aWRlZCBieSBOb2Rlc21pdGggZm9yIGV0aGVycy5qc1xudmFyIGRlZmF1bHRBcGlLZXkgPSBcIkVUSEVSU19KU19TSEFSRURcIjtcbnZhciBOb2Rlc21pdGhQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9kZXNtaXRoUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9kZXNtaXRoUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiAoYXBpS2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaUtleSB8fCBkZWZhdWx0QXBpS2V5O1xuICAgIH07XG4gICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsb2dnZXIud2FybihcIk5vZGVTbWl0aCB3aWxsIGJlIGRpc2NvbnRpbnVlZCBvbiAyMDE5LTEyLTIwOyBwbGVhc2UgbWlncmF0ZSB0byBhbm90aGVyIHBsYXRmb3JtLlwiKTtcbiAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9tYWlubmV0L2pzb25ycGNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JvcHN0ZW4vanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvcmlua2VieS9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2dvZXJsaS9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEva292YW4vanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGhvc3QgKyBcIj9hcGlLZXk9XCIgKyBhcGlLZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGVzbWl0aFByb3ZpZGVyO1xufSh1cmxfanNvbl9ycGNfcHJvdmlkZXJfMS5VcmxKc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuTm9kZXNtaXRoUHJvdmlkZXIgPSBOb2Rlc21pdGhQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGVzbWl0aC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/nodesmith-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/pocket-provider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/pocket-provider.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PocketProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar url_json_rpc_provider_1 = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\");\n// These are load-balancer-based application IDs\nvar defaultApplicationIds = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\nvar PocketProvider = /** @class */ (function (_super) {\n    __extends(PocketProvider, _super);\n    function PocketProvider(network, apiKey) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n        var _newTarget = this.constructor;\n        var _this = this;\n        if (apiKey == null) {\n            var n = (0, properties_1.getStatic)(_newTarget, \"getNetwork\")(network);\n            if (n) {\n                var applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n        }\n        _this = _super.call(this, network, apiKey) || this;\n        return _this;\n    }\n    PocketProvider.getApiKey = function (apiKey) {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n        var apiKeyObj = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"), \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    };\n    PocketProvider.getUrl = function (network, apiKey) {\n        var host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", logger_1.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        var url = null;\n        if (apiKey.loadBalancer) {\n            url = \"https://\" + host + \"/v1/lb/\" + apiKey.applicationId;\n        }\n        else {\n            url = \"https://\" + host + \"/v1/\" + apiKey.applicationId;\n        }\n        var connection = { url: url };\n        // Initialize empty headers\n        connection.headers = {};\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    };\n    PocketProvider.prototype.isCommunityResource = function () {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    };\n    return PocketProvider;\n}(url_json_rpc_provider_1.UrlJsonRpcProvider));\nexports.PocketProvider = PocketProvider;\n//# sourceMappingURL=pocket-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3BvY2tldC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsbUJBQW1CLG1CQUFPLENBQUMsa0hBQTJCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMscUdBQVk7QUFDckM7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQywrSEFBeUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3BvY2tldC1wcm92aWRlci5qcz9hOWRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSB2b2lkIDA7XG52YXIgcHJvcGVydGllc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCIpO1xudmFyIF92ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9fdmVyc2lvblwiKTtcbnZhciBsb2dnZXIgPSBuZXcgbG9nZ2VyXzEuTG9nZ2VyKF92ZXJzaW9uXzEudmVyc2lvbik7XG52YXIgdXJsX2pzb25fcnBjX3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIik7XG4vLyBUaGVzZSBhcmUgbG9hZC1iYWxhbmNlci1iYXNlZCBhcHBsaWNhdGlvbiBJRHNcbnZhciBkZWZhdWx0QXBwbGljYXRpb25JZHMgPSB7XG4gICAgaG9tZXN0ZWFkOiBcIjYwMDRiY2QxMDA0MDI2MTYzM2FkZTk5MFwiLFxuICAgIHJvcHN0ZW46IFwiNjAwNGJkNGQwMDQwMjYxNjMzYWRlOTkxXCIsXG4gICAgcmlua2VieTogXCI2MDA0YmRhMjAwNDAyNjE2MzNhZGU5OTRcIixcbiAgICBnb2VybGk6IFwiNjAwNGJkODYwMDQwMjYxNjMzYWRlOTkyXCIsXG59O1xudmFyIFBvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb2NrZXRQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBhIGJpdCBvZiBjcmVhdGl2aXR5IGluIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlXG4gICAgICAgIC8vIFBvY2tldCB1c2VzIGRpZmZlcmVudCBkZWZhdWx0IEFQSSBrZXlzIGJhc2VkIG9uIHRoZSBuZXR3b3JrXG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbiA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIHZhciBhcHBsaWNhdGlvbklkID0gZGVmYXVsdEFwcGxpY2F0aW9uSWRzW24ubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpY2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpS2V5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb25JZDogYXBwbGljYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNlcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbnkgaXNzdWUgYWJvdmUsIHdlIGRvbid0IGtub3cgdGhpcyBuZXR3b3JrXG4gICAgICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcIm5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldHdvcmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldHdvcmssIGFwaUtleSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb2NrZXRQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG4gICAgICAgIC8vIE1vc3QgQVBJIFByb3ZpZGVycyBhbGxvdyBudWxsIHRvIGdldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLCBidXRcbiAgICAgICAgLy8gUG9ja2V0IHJlcXVpcmVzIHRoZSBuZXR3b3JrIHRvIGRlY2lkZSB0aGUgZGVmYXVsdCBwcm92aWRlciwgc28gd2VcbiAgICAgICAgLy8gcmVseSBvbiBoaWphY2tpbmcgdGhlIGNvbnN0cnVjdG9yIHRvIGFkZCBhIHNlbnNpYmxlIGRlZmF1bHQgZm9yIHVzXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIlBvY2tldFByb3ZpZGVyLmdldEFwaUtleSBkb2VzIG5vdCBzdXBwb3J0IG51bGwgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFwaUtleU9iaiA9IHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQ6IG51bGwsXG4gICAgICAgICAgICBsb2FkQmFsYW5jZXI6IGZhbHNlLFxuICAgICAgICAgICAgYXBwbGljYXRpb25TZWNyZXRLZXk6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGFyc2UgYXBwbGljYXRpb25JZCBhbmQgYXBwbGljYXRpb25TZWNyZXRLZXlcbiAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQgPSBhcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodHlwZW9mIChhcGlLZXkuYXBwbGljYXRpb25JZCkgPT09IFwic3RyaW5nXCIpLCBcImFwcGxpY2F0aW9uU2VjcmV0S2V5IHJlcXVpcmVzIGFuIGFwcGxpY2F0aW9uSWRcIiwgXCJhcHBsaWNhdGlvbklkXCIsIGFwaUtleS5hcHBsaWNhdGlvbklkKTtcbiAgICAgICAgICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodHlwZW9mIChhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkpID09PSBcInN0cmluZ1wiKSwgXCJpbnZhbGlkIGFwcGxpY2F0aW9uU2VjcmV0S2V5XCIsIFwiYXBwbGljYXRpb25TZWNyZXRLZXlcIiwgXCJbUkVEQUNURURdXCIpO1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uSWQgPSBhcGlLZXkuYXBwbGljYXRpb25JZDtcbiAgICAgICAgICAgIGFwaUtleU9iai5hcHBsaWNhdGlvblNlY3JldEtleSA9IGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleTtcbiAgICAgICAgICAgIGFwaUtleU9iai5sb2FkQmFsYW5jZXIgPSAhIWFwaUtleS5sb2FkQmFsYW5jZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBpS2V5LmFwcGxpY2F0aW9uSWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodHlwZW9mIChhcGlLZXkuYXBwbGljYXRpb25JZCkgPT09IFwic3RyaW5nXCIpLCBcImFwaUtleS5hcHBsaWNhdGlvbklkIG11c3QgYmUgYSBzdHJpbmdcIiwgXCJhcGlLZXkuYXBwbGljYXRpb25JZFwiLCBhcGlLZXkuYXBwbGljYXRpb25JZCk7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleS5hcHBsaWNhdGlvbklkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLmxvYWRCYWxhbmNlciA9ICEhYXBpS2V5LmxvYWRCYWxhbmNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBQb2NrZXRQcm92aWRlciBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpS2V5T2JqO1xuICAgIH07XG4gICAgUG9ja2V0UHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICB2YXIgaG9zdCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobmV0d29yayA/IG5ldHdvcmsubmFtZSA6IFwidW5rbm93blwiKSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJvcHN0ZW4uZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLXJpbmtlYnkuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtZ29lcmxpLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSBudWxsO1xuICAgICAgICBpZiAoYXBpS2V5LmxvYWRCYWxhbmNlcikge1xuICAgICAgICAgICAgdXJsID0gXCJodHRwczovL1wiICsgaG9zdCArIFwiL3YxL2xiL1wiICsgYXBpS2V5LmFwcGxpY2F0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSBcImh0dHBzOi8vXCIgKyBob3N0ICsgXCIvdjEvXCIgKyBhcGlLZXkuYXBwbGljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHsgdXJsOiB1cmwgfTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBoZWFkZXJzXG4gICAgICAgIGNvbm5lY3Rpb24uaGVhZGVycyA9IHt9O1xuICAgICAgICAvLyBBcHBseSBhcHBsaWNhdGlvbiBzZWNyZXQga2V5XG4gICAgICAgIGlmIChhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucGFzc3dvcmQgPSBhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBQb2NrZXRQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwcGxpY2F0aW9uSWQgPT09IGRlZmF1bHRBcHBsaWNhdGlvbklkc1t0aGlzLm5ldHdvcmsubmFtZV0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBvY2tldFByb3ZpZGVyO1xufSh1cmxfanNvbl9ycGNfcHJvdmlkZXJfMS5VcmxKc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSBQb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvY2tldC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/pocket-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UrlJsonRpcProvider = exports.StaticJsonRpcProvider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nvar StaticJsonRpcProvider = /** @class */ (function (_super) {\n    __extends(StaticJsonRpcProvider, _super);\n    function StaticJsonRpcProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StaticJsonRpcProvider.prototype.detectNetwork = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var network;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        network = this.network;\n                        if (!(network == null)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, _super.prototype.detectNetwork.call(this)];\n                    case 1:\n                        network = _a.sent();\n                        if (!network) {\n                            logger.throwError(\"no network detected\", logger_1.Logger.errors.UNKNOWN_ERROR, {});\n                        }\n                        // If still not set, set it\n                        if (this._network == null) {\n                            // A static network does not support \"any\"\n                            (0, properties_1.defineReadOnly)(this, \"_network\", network);\n                            this.emit(\"network\", network, null);\n                        }\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, network];\n                }\n            });\n        });\n    };\n    return StaticJsonRpcProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.StaticJsonRpcProvider = StaticJsonRpcProvider;\nvar UrlJsonRpcProvider = /** @class */ (function (_super) {\n    __extends(UrlJsonRpcProvider, _super);\n    function UrlJsonRpcProvider(network, apiKey) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkAbstract(_newTarget, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = (0, properties_1.getStatic)(_newTarget, \"getNetwork\")(network);\n        apiKey = (0, properties_1.getStatic)(_newTarget, \"getApiKey\")(apiKey);\n        var connection = (0, properties_1.getStatic)(_newTarget, \"getUrl\")(network, apiKey);\n        _this = _super.call(this, connection, network) || this;\n        if (typeof (apiKey) === \"string\") {\n            (0, properties_1.defineReadOnly)(_this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach(function (key) {\n                (0, properties_1.defineReadOnly)(_this, key, apiKey[key]);\n            });\n        }\n        return _this;\n    }\n    UrlJsonRpcProvider.prototype._startPending = function () {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    };\n    UrlJsonRpcProvider.prototype.isCommunityResource = function () {\n        return false;\n    };\n    UrlJsonRpcProvider.prototype.getSigner = function (address) {\n        return logger.throwError(\"API provider does not support signing\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    };\n    UrlJsonRpcProvider.prototype.listAccounts = function () {\n        return Promise.resolve([]);\n    };\n    // Return a defaultApiKey if null, otherwise validate the API key\n    UrlJsonRpcProvider.getApiKey = function (apiKey) {\n        return apiKey;\n    };\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    UrlJsonRpcProvider.getUrl = function (network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", logger_1.Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    };\n    return UrlJsonRpcProvider;\n}(StaticJsonRpcProvider));\nexports.UrlJsonRpcProvider = UrlJsonRpcProvider;\n//# sourceMappingURL=url-json-rpc-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3VybC1qc29uLXJwYy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsNkJBQTZCO0FBQzFELG1CQUFtQixtQkFBTyxDQUFDLGtIQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsdUhBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILHdCQUF3QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi91cmwtanNvbi1ycGMtcHJvdmlkZXIuanM/MmUzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcmxKc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLlN0YXRpY0pzb25ScGNQcm92aWRlciA9IHZvaWQgMDtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG4vLyBBIFN0YXRpY0pzb25ScGNQcm92aWRlciBpcyB1c2VmdWwgd2hlbiB5b3UgKmtub3cqIGZvciBjZXJ0YWluIHRoYXRcbi8vIHRoZSBiYWNrZW5kIHdpbGwgbmV2ZXIgY2hhbmdlLCBhcyBpdCBuZXZlciBjYWxscyBldGhfY2hhaW5JZCB0b1xuLy8gdmVyaWZ5IGl0cyBiYWNrZW5kLiBIb3dldmVyLCBpZiB0aGUgYmFja2VuZCBkb2VzIGNoYW5nZSwgdGhlIGVmZmVjdHNcbi8vIGFyZSB1bmRlZmluZWQgYW5kIG1heSBpbmNsdWRlOlxuLy8gLSBpbmNvbnNpc3RlbnQgcmVzdWx0c1xuLy8gLSBsb2NraW5nIHVwIHRoZSBVSVxuLy8gLSBibG9jayBza2V3IHdhcm5pbmdzXG4vLyAtIHdyb25nIHJlc3VsdHNcbi8vIElmIHRoZSBuZXR3b3JrIGlzIG5vdCBleHBsaWNpdCAoaS5lLiBhdXRvLWRldGVjdGlvbiBpcyBleHBlY3RlZCksIHRoZVxuLy8gbm9kZSBNVVNUIGJlIHJ1bm5pbmcgYW5kIGF2YWlsYWJsZSB0byByZXNwb25kIHRvIHJlcXVlc3RzIEJFRk9SRSB0aGlzXG4vLyBpcyBpbnN0YW50aWF0ZWQuXG52YXIgU3RhdGljSnNvblJwY1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGF0aWNKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdGljSnNvblJwY1Byb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN0YXRpY0pzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yayA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfc3VwZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsuY2FsbCh0aGlzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGlsbCBub3Qgc2V0LCBzZXQgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHN0YXRpYyBuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgXCJhbnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKHRoaXMsIFwiX25ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29ya107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0pzb25ScGNQcm92aWRlcjtcbn0oanNvbl9ycGNfcHJvdmlkZXJfMS5Kc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuU3RhdGljSnNvblJwY1Byb3ZpZGVyID0gU3RhdGljSnNvblJwY1Byb3ZpZGVyO1xudmFyIFVybEpzb25ScGNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVXJsSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVybEpzb25ScGNQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBVcmxKc29uUnBjUHJvdmlkZXIpO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIE5ldHdvcmsgYW5kIEFQSSBLZXlcbiAgICAgICAgbmV0d29yayA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG4gICAgICAgIGFwaUtleSA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldEFwaUtleVwiKShhcGlLZXkpO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9ICgwLCBwcm9wZXJ0aWVzXzEuZ2V0U3RhdGljKShfbmV3VGFyZ2V0LCBcImdldFVybFwiKShuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbm5lY3Rpb24sIG5ldHdvcmspIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFwaUtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcGlLZXkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBrZXksIGFwaUtleVtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IEFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVyc1wiKTtcbiAgICB9O1xuICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuaXNDb21tdW5pdHlSZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5nZXRTaWduZXIgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJnZXRTaWduZXJcIiB9KTtcbiAgICB9O1xuICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUubGlzdEFjY291bnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9O1xuICAgIC8vIFJldHVybiBhIGRlZmF1bHRBcGlLZXkgaWYgbnVsbCwgb3RoZXJ3aXNlIHZhbGlkYXRlIHRoZSBBUEkga2V5XG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIHVybCBvciBjb25uZWN0aW9uIGZvciB0aGUgZ2l2ZW4gbmV0d29yayBhbmQgQVBJIGtleS4gVGhlXG4gICAgLy8gQVBJIGtleSB3aWxsIGhhdmUgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGdldEFwaUtleSBmaXJzdCwgc28gYW55IHZhbGlkYXRpb25cbiAgICAvLyBvciB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGRvbmUgdGhlcmUuXG4gICAgVXJsSnNvblJwY1Byb3ZpZGVyLmdldFVybCA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwibm90IGltcGxlbWVudGVkOyBzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldFVybFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldFVybFwiXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVybEpzb25ScGNQcm92aWRlcjtcbn0oU3RhdGljSnNvblJwY1Byb3ZpZGVyKSk7XG5leHBvcnRzLlVybEpzb25ScGNQcm92aWRlciA9IFVybEpzb25ScGNQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/web3-provider.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/web3-provider.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Web3Provider = void 0;\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nvar _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    var fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        var _this = this;\n        var request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise(function (resolve, reject) {\n            _this.emit(\"debug\", {\n                action: \"request\",\n                fetcher: fetcher,\n                request: (0, properties_1.deepCopy)(request),\n                provider: _this\n            });\n            sendFunc(request, function (error, response) {\n                if (error) {\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher: fetcher,\n                        error: error,\n                        request: request,\n                        provider: _this\n                    });\n                    return reject(error);\n                }\n                _this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher: fetcher,\n                    request: request,\n                    response: response,\n                    provider: _this\n                });\n                if (response.error) {\n                    var error_1 = new Error(response.error.message);\n                    error_1.code = response.error.code;\n                    error_1.data = response.error.data;\n                    return reject(error_1);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        var _this = this;\n        if (params == null) {\n            params = [];\n        }\n        var request = { method: method, params: params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: (0, properties_1.deepCopy)(request),\n            provider: this\n        });\n        return provider.request(request).then(function (response) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request: request,\n                response: response,\n                provider: _this\n            });\n            return response;\n        }, function (error) {\n            _this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request: request,\n                error: error,\n                provider: _this\n            });\n            throw error;\n        });\n    };\n}\nvar Web3Provider = /** @class */ (function (_super) {\n    __extends(Web3Provider, _super);\n    function Web3Provider(provider, network) {\n        var _newTarget = this.constructor;\n        var _this = this;\n        logger.checkNew(_newTarget, Web3Provider);\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        var path = null;\n        var jsonRpcFetchFunc = null;\n        var subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        _this = _super.call(this, path, network) || this;\n        (0, properties_1.defineReadOnly)(_this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        (0, properties_1.defineReadOnly)(_this, \"provider\", subprovider);\n        return _this;\n    }\n    Web3Provider.prototype.send = function (method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    };\n    return Web3Provider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.Web3Provider = Web3Provider;\n//# sourceMappingURL=web3-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dlYjMtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLGtIQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsdUhBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dlYjMtcHJvdmlkZXIuanM/M2Q2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYjNQcm92aWRlciA9IHZvaWQgMDtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG52YXIgX25leHRJZCA9IDE7XG5mdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuICAgIHZhciBmZXRjaGVyID0gXCJXZWIzTGVnYWN5RmV0Y2hlclwiO1xuICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6IChfbmV4dElkKyspLFxuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IGZldGNoZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogKDAsIHByb3BlcnRpZXNfMS5kZWVwQ29weSkocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbmRGdW5jKHJlcXVlc3QsIGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlcjogZmV0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlcjogZmV0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yXzEgPSBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXzEuY29kZSA9IHJlc3BvbnNlLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXzEuZGF0YSA9IHJlc3BvbnNlLmVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdCA9IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogcGFyYW1zIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICByZXF1ZXN0OiAoMCwgcHJvcGVydGllc18xLmRlZXBDb3B5KShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdChyZXF1ZXN0KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG52YXIgV2ViM1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWIzUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViM1Byb3ZpZGVyKHByb3ZpZGVyLCBuZXR3b3JrKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIFdlYjNQcm92aWRlcik7XG4gICAgICAgIGlmIChwcm92aWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IG51bGw7XG4gICAgICAgIHZhciBqc29uUnBjRmV0Y2hGdW5jID0gbnVsbDtcbiAgICAgICAgdmFyIHN1YnByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiAocHJvdmlkZXIpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG4gICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gcHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcHJvdmlkZXIuaG9zdCB8fCBwcm92aWRlci5wYXRoIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXBhdGggJiYgcHJvdmlkZXIuaXNNZXRhTWFzaykge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIm1ldGFtYXNrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gXCJlaXAtMTE5MzpcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZEFzeW5jKSB7XG4gICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHByb3ZpZGVyLnNlbmRBc3luYy5iaW5kKHByb3ZpZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci5zZW5kKSB7XG4gICAgICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHByb3ZpZGVyLnNlbmQuYmluZChwcm92aWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIHByb3ZpZGVyXCIsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IFwidW5rbm93bjpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhdGgsIG5ldHdvcmspIHx8IHRoaXM7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcImpzb25ScGNGZXRjaEZ1bmNcIiwganNvblJwY0ZldGNoRnVuYyk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKF90aGlzLCBcInByb3ZpZGVyXCIsIHN1YnByb3ZpZGVyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXZWIzUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViM1Byb3ZpZGVyO1xufShqc29uX3JwY19wcm92aWRlcl8xLkpzb25ScGNQcm92aWRlcikpO1xuZXhwb3J0cy5XZWIzUHJvdmlkZXIgPSBXZWIzUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWIzLXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/web3-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/websocket-provider.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/websocket-provider.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocketProvider = void 0;\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar json_rpc_provider_1 = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/json-rpc-provider.js\");\nvar ws_1 = __webpack_require__(/*! ./ws */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/ws.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nvar NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nvar WebSocketProvider = /** @class */ (function (_super) {\n    __extends(WebSocketProvider, _super);\n    function WebSocketProvider(url, network) {\n        var _this = this;\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        _this = _super.call(this, url, network) || this;\n        _this._pollingInterval = -1;\n        _this._wsReady = false;\n        (0, properties_1.defineReadOnly)(_this, \"_websocket\", new ws_1.WebSocket(_this.connection.url));\n        (0, properties_1.defineReadOnly)(_this, \"_requests\", {});\n        (0, properties_1.defineReadOnly)(_this, \"_subs\", {});\n        (0, properties_1.defineReadOnly)(_this, \"_subIds\", {});\n        (0, properties_1.defineReadOnly)(_this, \"_detectNetwork\", _super.prototype.detectNetwork.call(_this));\n        // Stall sending requests until the socket is open...\n        _this._websocket.onopen = function () {\n            _this._wsReady = true;\n            Object.keys(_this._requests).forEach(function (id) {\n                _this._websocket.send(_this._requests[id].payload);\n            });\n        };\n        _this._websocket.onmessage = function (messageEvent) {\n            var data = messageEvent.data;\n            var result = JSON.parse(data);\n            if (result.id != null) {\n                var id = String(result.id);\n                var request = _this._requests[id];\n                delete _this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: _this\n                    });\n                }\n                else {\n                    var error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        (0, properties_1.defineReadOnly)(error, \"code\", result.error.code || null);\n                        (0, properties_1.defineReadOnly)(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    _this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: _this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                var sub = _this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        var fauxPoll = setInterval(function () {\n            _this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n        return _this;\n    }\n    WebSocketProvider.prototype.detectNetwork = function () {\n        return this._detectNetwork;\n    };\n    Object.defineProperty(WebSocketProvider.prototype, \"pollingInterval\", {\n        get: function () {\n            return 0;\n        },\n        set: function (value) {\n            logger.throwError(\"cannot set polling interval on WebSocketProvider\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setPollingInterval\"\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WebSocketProvider.prototype.resetEventsBlock = function (blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    };\n    WebSocketProvider.prototype.poll = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, null];\n            });\n        });\n    };\n    Object.defineProperty(WebSocketProvider.prototype, \"polling\", {\n        set: function (value) {\n            if (!value) {\n                return;\n            }\n            logger.throwError(\"cannot set polling on WebSocketProvider\", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setPolling\"\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WebSocketProvider.prototype.send = function (method, params) {\n        var _this = this;\n        var rid = NextId++;\n        return new Promise(function (resolve, reject) {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            var payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            _this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: _this\n            });\n            _this._requests[String(rid)] = { callback: callback, payload: payload };\n            if (_this._wsReady) {\n                _this._websocket.send(payload);\n            }\n        });\n    };\n    WebSocketProvider.defaultUrl = function () {\n        return \"ws:/\\/localhost:8546\";\n    };\n    WebSocketProvider.prototype._subscribe = function (tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function () {\n            var subIdPromise, subId;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        subIdPromise = this._subIds[tag];\n                        if (subIdPromise == null) {\n                            subIdPromise = Promise.all(param).then(function (param) {\n                                return _this.send(\"eth_subscribe\", param);\n                            });\n                            this._subIds[tag] = subIdPromise;\n                        }\n                        return [4 /*yield*/, subIdPromise];\n                    case 1:\n                        subId = _a.sent();\n                        this._subs[subId] = { tag: tag, processFunc: processFunc };\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WebSocketProvider.prototype._startEvent = function (event) {\n        var _this = this;\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], function (result) {\n                    var blockNumber = bignumber_1.BigNumber.from(result.number).toNumber();\n                    _this._emitted.block = blockNumber;\n                    _this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], function (result) {\n                    _this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], function (result) {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    _this.emit(event.filter, _this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                var emitReceipt_1 = function (event) {\n                    var hash = event.hash;\n                    _this.getTransactionReceipt(hash).then(function (receipt) {\n                        if (!receipt) {\n                            return;\n                        }\n                        _this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt_1(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], function (result) {\n                    _this._events.filter(function (e) { return (e.type === \"tx\"); }).forEach(emitReceipt_1);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    };\n    WebSocketProvider.prototype._stopEvent = function (event) {\n        var _this = this;\n        var tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter(function (e) { return (e.type === \"tx\"); }).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        var subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then(function (subId) {\n            if (!_this._subs[subId]) {\n                return;\n            }\n            delete _this._subs[subId];\n            _this.send(\"eth_unsubscribe\", [subId]);\n        });\n    };\n    WebSocketProvider.prototype.destroy = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this._websocket.readyState === ws_1.WebSocket.CONNECTING)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, (new Promise(function (resolve) {\n                                _this._websocket.onopen = function () {\n                                    resolve(true);\n                                };\n                                _this._websocket.onerror = function () {\n                                    resolve(false);\n                                };\n                            }))];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        // Hangup\n                        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n                        this._websocket.close(1000);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return WebSocketProvider;\n}(json_rpc_provider_1.JsonRpcProvider));\nexports.WebSocketProvider = WebSocketProvider;\n//# sourceMappingURL=websocket-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dlYnNvY2tldC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQsMEJBQTBCLG1CQUFPLENBQUMsdUhBQXFCO0FBQ3ZELFdBQVcsbUJBQU8sQ0FBQyx5RkFBTTtBQUN6QixlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHFHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELDJEQUEyRDtBQUMzRCw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwyQkFBMkI7QUFDbkYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDJCQUEyQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dlYnNvY2tldC1wcm92aWRlci5qcz83ZTA3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xudmFyIGJpZ251bWJlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBqc29uX3JwY19wcm92aWRlcl8xID0gcmVxdWlyZShcIi4vanNvbi1ycGMtcHJvdmlkZXJcIik7XG52YXIgd3NfMSA9IHJlcXVpcmUoXCIuL3dzXCIpO1xudmFyIGxvZ2dlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiKTtcbnZhciBfdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vX3ZlcnNpb25cIik7XG52YXIgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihfdmVyc2lvbl8xLnZlcnNpb24pO1xuLyoqXG4gKiAgTm90ZXM6XG4gKlxuICogIFRoaXMgcHJvdmlkZXIgZGlmZmVycyBhIGJpdCBmcm9tIHRoZSBwb2xsaW5nIHByb3ZpZGVycy4gT25lIG1haW5cbiAqICBkaWZmZXJlbmNlIGlzIGhvdyBpdCBoYW5kbGVzIGNvbnNpc3RlbmN5LiBUaGUgcG9sbGluZyBwcm92aWRlcnNcbiAqICB3aWxsIHN0YWxsIHJlc3BvbnNlcyB0byBlbnN1cmUgYSBjb25zaXN0ZW50IHN0YXRlLCB3aGlsZSB0aGlzXG4gKiAgV2ViU29ja2V0IHByb3ZpZGVyIGFzc3VtZXMgdGhlIGNvbm5lY3RlZCBiYWNrZW5kIHdpbGwgbWFuYWdlIHRoaXMuXG4gKlxuICogIEZvciBleGFtcGxlLCBpZiBhIHBvbGxpbmcgcHJvdmlkZXIgZW1pdHMgYW4gZXZlbnQgd2hpY2ggaW5kaWNhdGVzXG4gKiAgdGhlIGV2ZW50IG9jY3VycmVkIGluIGJsb2NraGFzaCBYWFgsIGEgY2FsbCB0byBmZXRjaCB0aGF0IGJsb2NrIGJ5XG4gKiAgaXRzIGhhc2ggWFhYLCBpZiBub3QgcHJlc2VudCB3aWxsIHJldHJ5IHVudGlsIGl0IGlzIHByZXNlbnQuIFRoaXNcbiAqICBjYW4gb2NjdXIgd2hlbiBxdWVyeWluZyBhIHBvb2wgb2Ygbm9kZXMgdGhhdCBhcmUgbWlsZGx5IG91dCBvZiBzeW5jXG4gKiAgd2l0aCBlYWNoIG90aGVyLlxuICovXG52YXIgTmV4dElkID0gMTtcbi8vIEZvciBtb3JlIGluZm8gYWJvdXQgdGhlIFJlYWwtdGltZSBFdmVudCBBUEkgc2VlOlxuLy8gICBodHRwczovL2dldGguZXRoZXJldW0ub3JnL2RvY3MvcnBjL3B1YnN1YlxudmFyIFdlYlNvY2tldFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXZWJTb2NrZXRQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWJTb2NrZXRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGFkZGVkIGluIHRoZSBmdXR1cmU7IHBsZWFzZSBvcGVuIGFuIGlzc3VlIHRvIGV4cGVkaXRlXG4gICAgICAgIGlmIChuZXR3b3JrID09PSBcImFueVwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJ2FueScgbmV0d29yayB5ZXRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV0d29yazphbnlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cmwsIG5ldHdvcmspIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgX3RoaXMuX3dzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX3dlYnNvY2tldFwiLCBuZXcgd3NfMS5XZWJTb2NrZXQoX3RoaXMuY29ubmVjdGlvbi51cmwpKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX3JlcXVlc3RzXCIsIHt9KTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX3N1YnNcIiwge30pO1xuICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShfdGhpcywgXCJfc3ViSWRzXCIsIHt9KTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkoX3RoaXMsIFwiX2RldGVjdE5ldHdvcmtcIiwgX3N1cGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrLmNhbGwoX3RoaXMpKTtcbiAgICAgICAgLy8gU3RhbGwgc2VuZGluZyByZXF1ZXN0cyB1bnRpbCB0aGUgc29ja2V0IGlzIG9wZW4uLi5cbiAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fd3NSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpcy5fcmVxdWVzdHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5zZW5kKF90aGlzLl9yZXF1ZXN0c1tpZF0ucGF5bG9hZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX3dlYnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG1lc3NhZ2VFdmVudC5kYXRhO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBTdHJpbmcocmVzdWx0LmlkKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IF90aGlzLl9yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHJlcXVlc3QucGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBwcm9wZXJ0aWVzXzEuZGVmaW5lUmVhZE9ubHkpKGVycm9yLCBcImNvZGVcIiwgcmVzdWx0LmVycm9yLmNvZGUgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgcHJvcGVydGllc18xLmRlZmluZVJlYWRPbmx5KShlcnJvciwgXCJyZXNwb25zZVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHJlcXVlc3QucGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0Lm1ldGhvZCA9PT0gXCJldGhfc3Vic2NyaXB0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBTdWJzY3JpcHRpb24uLi5cbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3RoaXMuX3N1YnNbcmVzdWx0LnBhcmFtcy5zdWJzY3JpcHRpb25dO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmVtaXQuYXBwbHkodGhpcywgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBzdWIucHJvY2Vzc0Z1bmMocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgUHJvdmlkZXIgZG9lcyBub3QgYWN0dWFsbHkgcG9sbCwgYnV0IHdlIHdhbnQgdG8gdHJpZ2dlclxuICAgICAgICAvLyBwb2xsIGV2ZW50cyBmb3IgdGhpbmdzIHRoYXQgZGVwZW5kIG9uIHRoZW0gKGxpa2Ugc3RhbGxpbmcgZm9yXG4gICAgICAgIC8vIGJsb2NrIGFuZCB0cmFuc2FjdGlvbiBsb29rdXBzKVxuICAgICAgICB2YXIgZmF1eFBvbGwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicG9sbFwiKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIGlmIChmYXV4UG9sbC51bnJlZikge1xuICAgICAgICAgICAgZmF1eFBvbGwudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGV0ZWN0TmV0d29yaztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ0ludGVydmFsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIGludGVydmFsIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdJbnRlcnZhbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5yZXNldEV2ZW50c0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHJlc2V0IGV2ZW50cyBibG9jayBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc2V0RXZlbnRCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmlkID0gTmV4dElkKys7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaWQ6IHJpZCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHBheWxvYWQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fcmVxdWVzdHNbU3RyaW5nKHJpZCldID0geyBjYWxsYmFjazogY2FsbGJhY2ssIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fd3NSZWFkeSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl93ZWJzb2NrZXQuc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRQcm92aWRlci5kZWZhdWx0VXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ3czovXFwvbG9jYWxob3N0Ojg1NDZcIjtcbiAgICB9O1xuICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdWJJZFByb21pc2UsIHN1YklkO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IHRoaXMuX3N1Yklkc1t0YWddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YklkUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gUHJvbWlzZS5hbGwocGFyYW0pLnRoZW4oZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZW5kKFwiZXRoX3N1YnNjcmliZVwiLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdWJJZFByb21pc2VdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJJZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWc6IHRhZywgcHJvY2Vzc0Z1bmM6IHByb2Nlc3NGdW5jIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwiYmxvY2tcIiwgW1wibmV3SGVhZHNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20ocmVzdWx0Lm51bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwicGVuZGluZ1wiLCBbXCJuZXdQZW5kaW5nVHJhbnNhY3Rpb25zXCJdLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChldmVudC5maWx0ZXIsIF90aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidHhcIjoge1xuICAgICAgICAgICAgICAgIHZhciBlbWl0UmVjZWlwdF8xID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gZXZlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoaGFzaCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBpdCBpcyBhbHJlYWR5IG1pbmVkXG4gICAgICAgICAgICAgICAgZW1pdFJlY2VpcHRfMShldmVudCk7XG4gICAgICAgICAgICAgICAgLy8gVG8ga2VlcCB0aGluZ3Mgc2ltcGxlLCB3ZSBzdGFydCB1cCBhIHNpbmdsZSBuZXdIZWFkcyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAvLyB0byBrZWVwIGFuIGV5ZSBvdXQgZm9yIHRyYW5zYWN0aW9ucyB3ZSBhcmUgd2F0Y2hpbmcgZm9yLlxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGEgc3Vic2NyaXB0aW9uIGZvciBhbiBldmVudCAoaS5lLiBcInR4XCIpIHRoYXQgaXMgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIHJ1bm5pbmcgaXMgKGJhc2ljYWxseSkgYSBub3AuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwidHhcIiwgW1wibmV3SGVhZHNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChlLnR5cGUgPT09IFwidHhcIik7IH0pLmZvckVhY2goZW1pdFJlY2VpcHRfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGlzIG5lZWRlZFxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwicG9sbFwiOlxuICAgICAgICAgICAgY2FzZSBcIndpbGxQb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlkUG9sbFwiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5oYW5kbGVkOlwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fc3RvcEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YWcgPSBldmVudC50YWc7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcInR4XCIpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUudHlwZSA9PT0gXCJ0eFwiKTsgfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XG4gICAgICAgIGlmICghc3ViSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fc3ViSWRzW3RhZ107XG4gICAgICAgIHN1YklkLnRoZW4oZnVuY3Rpb24gKHN1YklkKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9zdWJzW3N1YklkXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fc3Vic1tzdWJJZF07XG4gICAgICAgICAgICBfdGhpcy5zZW5kKFwiZXRoX3Vuc3Vic2NyaWJlXCIsIFtzdWJJZF0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IHdzXzEuV2ViU29ja2V0LkNPTk5FQ1RJTkcpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93ZWJzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZ3VwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LmNsb3NlKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBXZWJTb2NrZXRQcm92aWRlcjtcbn0oanNvbl9ycGNfcHJvdmlkZXJfMS5Kc29uUnBjUHJvdmlkZXIpKTtcbmV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSBXZWJTb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/websocket-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/ws.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/providers/lib/ws.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebSocket = void 0;\nvar ws_1 = __importDefault(__webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/index.js\"));\nexports.WebSocket = ws_1.default;\n//# sourceMappingURL=ws.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLDJCQUEyQixtQkFBTyxDQUFDLDRDQUFJO0FBQ3ZDLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliL3dzLmpzPzg3YzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHZvaWQgMDtcbnZhciB3c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ3c1wiKSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHdzXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/providers/lib/ws.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/random/lib/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shuffled = exports.randomBytes = void 0;\nvar random_1 = __webpack_require__(/*! ./random */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/random.js\");\nObject.defineProperty(exports, \"randomBytes\", ({ enumerable: true, get: function () { return random_1.randomBytes; } }));\nvar shuffle_1 = __webpack_require__(/*! ./shuffle */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/shuffle.js\");\nObject.defineProperty(exports, \"shuffled\", ({ enumerable: true, get: function () { return shuffle_1.shuffled; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLG1CQUFtQjtBQUN0QyxlQUFlLG1CQUFPLENBQUMsOEZBQVU7QUFDakMsK0NBQThDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3RILGdCQUFnQixtQkFBTyxDQUFDLGdHQUFXO0FBQ25DLDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliL2luZGV4LmpzPzQwNjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNodWZmbGVkID0gZXhwb3J0cy5yYW5kb21CeXRlcyA9IHZvaWQgMDtcbnZhciByYW5kb21fMSA9IHJlcXVpcmUoXCIuL3JhbmRvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJhbmRvbUJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5kb21fMS5yYW5kb21CeXRlczsgfSB9KTtcbnZhciBzaHVmZmxlXzEgPSByZXF1aXJlKFwiLi9zaHVmZmxlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2h1ZmZsZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNodWZmbGVfMS5zaHVmZmxlZDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/random.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/random/lib/random.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = void 0;\nvar crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nfunction randomBytes(length) {\n    return (0, bytes_1.arrayify)((0, crypto_1.randomBytes)(length));\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliL3JhbmRvbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JhbmRvbS9saWIvcmFuZG9tLmpzPzM0OWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gdm9pZCAwO1xudmFyIGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmFycmF5aWZ5KSgoMCwgY3J5cHRvXzEucmFuZG9tQnl0ZXMpKGxlbmd0aCkpO1xufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/random.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/shuffle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/random/lib/shuffle.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shuffled = void 0;\nfunction shuffled(array) {\n    array = array.slice();\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n    return array;\n}\nexports.shuffled = shuffled;\n//# sourceMappingURL=shuffle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliL3NodWZmbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliL3NodWZmbGUuanM/MWM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2h1ZmZsZWQgPSB2b2lkIDA7XG5mdW5jdGlvbiBzaHVmZmxlZChhcnJheSkge1xuICAgIGFycmF5ID0gYXJyYXkuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICB2YXIgdG1wID0gYXJyYXlbaV07XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgIGFycmF5W2pdID0gdG1wO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLnNodWZmbGVkID0gc2h1ZmZsZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaHVmZmxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/random/lib/shuffle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/_version.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/rlp/lib/_version.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"rlp/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi9fdmVyc2lvbi5qcz8wNDA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJybHAvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/rlp/lib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = void 0;\n//See: https://github.com/ethereum/wiki/wiki/RLP\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction arrayifyInteger(value) {\n    var result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    var result = 0;\n    for (var i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        var payload_1 = [];\n        object.forEach(function (child) {\n            payload_1 = payload_1.concat(_encode(child));\n        });\n        if (payload_1.length <= 55) {\n            payload_1.unshift(0xc0 + payload_1.length);\n            return payload_1;\n        }\n        var length_1 = arrayifyInteger(payload_1.length);\n        length_1.unshift(0xf7 + length_1.length);\n        return length_1.concat(payload_1);\n    }\n    if (!(0, bytes_1.isBytesLike)(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    var data = Array.prototype.slice.call((0, bytes_1.arrayify)(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    var length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nfunction encode(object) {\n    return (0, bytes_1.hexlify)(_encode(object));\n}\nexports.encode = encode;\nfunction _decodeChildren(data, offset, childOffset, length) {\n    var result = [];\n    while (childOffset < offset + 1 + length) {\n        var decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        var lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length_2 > data.length) {\n            logger.throwError(\"data long segment too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);\n    }\n    else if (data[offset] >= 0xc0) {\n        var length_3 = data[offset] - 0xc0;\n        if (offset + 1 + length_3 > data.length) {\n            logger.throwError(\"data array too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length_3);\n    }\n    else if (data[offset] >= 0xb8) {\n        var lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length_4 > data.length) {\n            logger.throwError(\"data array too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        var result = (0, bytes_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));\n        return { consumed: (1 + lengthLength + length_4), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        var length_5 = data[offset] - 0x80;\n        if (offset + 1 + length_5 > data.length) {\n            logger.throwError(\"data too short\", logger_1.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        var result = (0, bytes_1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));\n        return { consumed: (1 + length_5), result: result };\n    }\n    return { consumed: 1, result: (0, bytes_1.hexlify)(data[offset]) };\n}\nfunction decode(data) {\n    var bytes = (0, bytes_1.arrayify)(data);\n    var decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\nexports.decode = decode;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLCtGQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliL2luZGV4LmpzP2M1ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbmZ1bmN0aW9uIGFycmF5aWZ5SW50ZWdlcih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHZhciBwYXlsb2FkXzEgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkXzEgPSBwYXlsb2FkXzEuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkXzEubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkXzEudW5zaGlmdCgweGMwICsgcGF5bG9hZF8xLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZF8xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGhfMSA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkXzEubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoXzEudW5zaGlmdCgweGY3ICsgbGVuZ3RoXzEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aF8xLmNvbmNhdChwYXlsb2FkXzEpO1xuICAgIH1cbiAgICBpZiAoISgwLCBieXRlc18xLmlzQnl0ZXNMaWtlKShvYmplY3QpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKG9iamVjdCkpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgIGRhdGEudW5zaGlmdCgweDgwICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuZnVuY3Rpb24gZW5jb2RlKG9iamVjdCkge1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KShfZW5jb2RlKG9iamVjdCkpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBjaGlsZE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICBpZiAoY2hpbGRPZmZzZXQgPiBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xufVxuLy8gcmV0dXJucyB7IGNvbnN1bWVkOiBudW1iZXIsIHJlc3VsdDogT2JqZWN0IH1cbmZ1bmN0aW9uIF9kZWNvZGUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgIH1cbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgdmFyIGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aF8yID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGhfMiA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgbG9uZyBzZWdtZW50IHRvbyBzaG9ydFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIGxlbmd0aExlbmd0aCArIGxlbmd0aF8yKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgdmFyIGxlbmd0aF8zID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhfMyA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoXzMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICB2YXIgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aF80ID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGhfNCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGJ5dGVzXzEuaGV4bGlmeSkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzQpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoXzQpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHg4MCkge1xuICAgICAgICB2YXIgbGVuZ3RoXzUgPSBkYXRhW29mZnNldF0gLSAweDgwO1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aF81ID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgYnl0ZXNfMS5oZXhsaWZ5KShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGhfNSkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGhfNSksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6ICgwLCBieXRlc18xLmhleGxpZnkpKGRhdGFbb2Zmc2V0XSkgfTtcbn1cbmZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgdmFyIGJ5dGVzID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGRhdGEpO1xuICAgIHZhciBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG4gICAgaWYgKGRlY29kZWQuY29uc3VtZWQgIT09IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/_version.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/sha2/lib/_version.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"sha2/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliL192ZXJzaW9uLmpzPzIzZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSBcInNoYTIvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/sha2/lib/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SupportedAlgorithm = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.computeHmac = void 0;\nvar sha2_1 = __webpack_require__(/*! ./sha2 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/sha2.js\");\nObject.defineProperty(exports, \"computeHmac\", ({ enumerable: true, get: function () { return sha2_1.computeHmac; } }));\nObject.defineProperty(exports, \"ripemd160\", ({ enumerable: true, get: function () { return sha2_1.ripemd160; } }));\nObject.defineProperty(exports, \"sha256\", ({ enumerable: true, get: function () { return sha2_1.sha256; } }));\nObject.defineProperty(exports, \"sha512\", ({ enumerable: true, get: function () { return sha2_1.sha512; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/types.js\");\nObject.defineProperty(exports, \"SupportedAlgorithm\", ({ enumerable: true, get: function () { return types_1.SupportedAlgorithm; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLG1CQUFtQjtBQUN0RyxhQUFhLG1CQUFPLENBQUMsd0ZBQVE7QUFDN0IsK0NBQThDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ3BILDZDQUE0QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUNoSCwwQ0FBeUMsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDMUcsMENBQXlDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQzFHLGNBQWMsbUJBQU8sQ0FBQywwRkFBUztBQUMvQixzREFBcUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDbkkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIvaW5kZXguanM/MmZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3VwcG9ydGVkQWxnb3JpdGhtID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5jb21wdXRlSG1hYyA9IHZvaWQgMDtcbnZhciBzaGEyXzEgPSByZXF1aXJlKFwiLi9zaGEyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZUhtYWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYTJfMS5jb21wdXRlSG1hYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcGVtZDE2MFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl8xLnJpcGVtZDE2MDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl8xLnNoYTI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYTUxMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhMl8xLnNoYTUxMjsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdXBwb3J0ZWRBbGdvcml0aG1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuU3VwcG9ydGVkQWxnb3JpdGhtOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/sha2.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/sha2/lib/sha2.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computeHmac = exports.sha512 = exports.sha256 = exports.ripemd160 = void 0;\nvar crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/types.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction ripemd160(data) {\n    return \"0x\" + (0, crypto_1.createHash)(\"ripemd160\").update(Buffer.from((0, bytes_1.arrayify)(data))).digest(\"hex\");\n}\nexports.ripemd160 = ripemd160;\nfunction sha256(data) {\n    return \"0x\" + (0, crypto_1.createHash)(\"sha256\").update(Buffer.from((0, bytes_1.arrayify)(data))).digest(\"hex\");\n}\nexports.sha256 = sha256;\nfunction sha512(data) {\n    return \"0x\" + (0, crypto_1.createHash)(\"sha512\").update(Buffer.from((0, bytes_1.arrayify)(data))).digest(\"hex\");\n}\nexports.sha512 = sha512;\nfunction computeHmac(algorithm, key, data) {\n    /* istanbul ignore if */\n    if (!types_1.SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm - \" + algorithm, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"computeHmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + (0, crypto_1.createHmac)(algorithm, Buffer.from((0, bytes_1.arrayify)(key))).update(Buffer.from((0, bytes_1.arrayify)(data))).digest(\"hex\");\n}\nexports.computeHmac = computeHmac;\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi9zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsaUJBQWlCO0FBQ3pFLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQywwRkFBUztBQUMvQixlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLGdHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi9zaGEyLmpzP2QyZmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVIbWFjID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMucmlwZW1kMTYwID0gdm9pZCAwO1xudmFyIGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbmZ1bmN0aW9uIHJpcGVtZDE2MChkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArICgwLCBjcnlwdG9fMS5jcmVhdGVIYXNoKShcInJpcGVtZDE2MFwiKS51cGRhdGUoQnVmZmVyLmZyb20oKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGRhdGEpKSkuZGlnZXN0KFwiaGV4XCIpO1xufVxuZXhwb3J0cy5yaXBlbWQxNjAgPSByaXBlbWQxNjA7XG5mdW5jdGlvbiBzaGEyNTYoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoMCwgY3J5cHRvXzEuY3JlYXRlSGFzaCkoXCJzaGEyNTZcIikudXBkYXRlKEJ1ZmZlci5mcm9tKCgwLCBieXRlc18xLmFycmF5aWZ5KShkYXRhKSkpLmRpZ2VzdChcImhleFwiKTtcbn1cbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuZnVuY3Rpb24gc2hhNTEyKGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKDAsIGNyeXB0b18xLmNyZWF0ZUhhc2gpKFwic2hhNTEyXCIpLnVwZGF0ZShCdWZmZXIuZnJvbSgoMCwgYnl0ZXNfMS5hcnJheWlmeSkoZGF0YSkpKS5kaWdlc3QoXCJoZXhcIik7XG59XG5leHBvcnRzLnNoYTUxMiA9IHNoYTUxMjtcbmZ1bmN0aW9uIGNvbXB1dGVIbWFjKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0eXBlc18xLlN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIC0gXCIgKyBhbGdvcml0aG0sIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29tcHV0ZUhtYWNcIixcbiAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgKDAsIGNyeXB0b18xLmNyZWF0ZUhtYWMpKGFsZ29yaXRobSwgQnVmZmVyLmZyb20oKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGtleSkpKS51cGRhdGUoQnVmZmVyLmZyb20oKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGRhdGEpKSkuZGlnZXN0KFwiaGV4XCIpO1xufVxuZXhwb3J0cy5jb21wdXRlSG1hYyA9IGNvbXB1dGVIbWFjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/types.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/sha2/lib/types.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SupportedAlgorithm = void 0;\nvar SupportedAlgorithm;\n(function (SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));\n;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRCwwQkFBMEIsS0FBSztBQUN0RjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliL3R5cGVzLmpzPzM5ZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSA9IHZvaWQgMDtcbnZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG4oZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG4gICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcbn0pKFN1cHBvcnRlZEFsZ29yaXRobSA9IGV4cG9ydHMuU3VwcG9ydGVkQWxnb3JpdGhtIHx8IChleHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSA9IHt9KSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/sha2/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/_version.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/_version.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"signing-key/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIvX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIvX3ZlcnNpb24uanM/NTI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbmV4cG9ydHMudmVyc2lvbiA9IFwic2lnbmluZy1rZXkvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/elliptic.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/elliptic.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EC = void 0;\nvar elliptic_1 = __importDefault(__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\"));\nvar EC = elliptic_1.default.ec;\nexports.EC = EC;\n//# sourceMappingURL=elliptic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIvZWxsaXB0aWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxVQUFVO0FBQ1YsaUNBQWlDLG1CQUFPLENBQUMsK0RBQVU7QUFDbkQ7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliL2VsbGlwdGljLmpzPzY3Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVDID0gdm9pZCAwO1xudmFyIGVsbGlwdGljXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImVsbGlwdGljXCIpKTtcbnZhciBFQyA9IGVsbGlwdGljXzEuZGVmYXVsdC5lYztcbmV4cG9ydHMuRUMgPSBFQztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsbGlwdGljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/elliptic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;\nvar elliptic_1 = __webpack_require__(/*! ./elliptic */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/elliptic.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new elliptic_1.EC(\"secp256k1\");\n    }\n    return _curve;\n}\nvar SigningKey = /** @class */ (function () {\n    function SigningKey(privateKey) {\n        (0, properties_1.defineReadOnly)(this, \"curve\", \"secp256k1\");\n        (0, properties_1.defineReadOnly)(this, \"privateKey\", (0, bytes_1.hexlify)(privateKey));\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\n        (0, properties_1.defineReadOnly)(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        (0, properties_1.defineReadOnly)(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        (0, properties_1.defineReadOnly)(this, \"_isSigningKey\", true);\n    }\n    SigningKey.prototype._addPoint = function (other) {\n        var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));\n        var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    };\n    SigningKey.prototype.signDigest = function (digest) {\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\n        var digestBytes = (0, bytes_1.arrayify)(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        var signature = keyPair.sign(digestBytes, { canonical: true });\n        return (0, bytes_1.splitSignature)({\n            recoveryParam: signature.recoveryParam,\n            r: (0, bytes_1.hexZeroPad)(\"0x\" + signature.r.toString(16), 32),\n            s: (0, bytes_1.hexZeroPad)(\"0x\" + signature.s.toString(16), 32),\n        });\n    };\n    SigningKey.prototype.computeSharedSecret = function (otherKey) {\n        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));\n        var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey(otherKey)));\n        return (0, bytes_1.hexZeroPad)(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    };\n    SigningKey.isSigningKey = function (value) {\n        return !!(value && value._isSigningKey);\n    };\n    return SigningKey;\n}());\nexports.SigningKey = SigningKey;\nfunction recoverPublicKey(digest, signature) {\n    var sig = (0, bytes_1.splitSignature)(signature);\n    var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction computePublicKey(key, compressed) {\n    var bytes = (0, bytes_1.arrayify)(key);\n    if (bytes.length === 32) {\n        var signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return (0, bytes_1.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return (0, bytes_1.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\nexports.computePublicKey = computePublicKey;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCO0FBQ3hFLGlCQUFpQixtQkFBTyxDQUFDLHVHQUFZO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsa0hBQTJCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsdUdBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIvaW5kZXguanM/M2UzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcHV0ZVB1YmxpY0tleSA9IGV4cG9ydHMucmVjb3ZlclB1YmxpY0tleSA9IGV4cG9ydHMuU2lnbmluZ0tleSA9IHZvaWQgMDtcbnZhciBlbGxpcHRpY18xID0gcmVxdWlyZShcIi4vZWxsaXB0aWNcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBfY3VydmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q3VydmUoKSB7XG4gICAgaWYgKCFfY3VydmUpIHtcbiAgICAgICAgX2N1cnZlID0gbmV3IGVsbGlwdGljXzEuRUMoXCJzZWNwMjU2azFcIik7XG4gICAgfVxuICAgIHJldHVybiBfY3VydmU7XG59XG52YXIgU2lnbmluZ0tleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaWduaW5nS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJjdXJ2ZVwiLCBcInNlY3AyNTZrMVwiKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwcml2YXRlS2V5XCIsICgwLCBieXRlc18xLmhleGxpZnkpKHByaXZhdGVLZXkpKTtcbiAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKCgwLCBieXRlc18xLmFycmF5aWZ5KSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJwdWJsaWNLZXlcIiwgXCIweFwiICsga2V5UGFpci5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJjb21wcmVzc2VkUHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpKTtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfMS5kZWZpbmVSZWFkT25seSkodGhpcywgXCJfaXNTaWduaW5nS2V5XCIsIHRydWUpO1xuICAgIH1cbiAgICBTaWduaW5nS2V5LnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHAwID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKCgwLCBieXRlc18xLmFycmF5aWZ5KSh0aGlzLnB1YmxpY0tleSkpO1xuICAgICAgICB2YXIgcDEgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKG90aGVyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwMC5wdWIuYWRkKHAxLnB1YikuZW5jb2RlQ29tcHJlc3NlZChcImhleFwiKTtcbiAgICB9O1xuICAgIFNpZ25pbmdLZXkucHJvdG90eXBlLnNpZ25EaWdlc3QgPSBmdW5jdGlvbiAoZGlnZXN0KSB7XG4gICAgICAgIHZhciBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZSgoMCwgYnl0ZXNfMS5hcnJheWlmeSkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIHZhciBkaWdlc3RCeXRlcyA9ICgwLCBieXRlc18xLmFycmF5aWZ5KShkaWdlc3QpO1xuICAgICAgICBpZiAoZGlnZXN0Qnl0ZXMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGtleVBhaXIuc2lnbihkaWdlc3RCeXRlcywgeyBjYW5vbmljYWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5zcGxpdFNpZ25hdHVyZSkoe1xuICAgICAgICAgICAgcmVjb3ZlcnlQYXJhbTogc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0sXG4gICAgICAgICAgICByOiAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKShcIjB4XCIgKyBzaWduYXR1cmUuci50b1N0cmluZygxNiksIDMyKSxcbiAgICAgICAgICAgIHM6ICgwLCBieXRlc18xLmhleFplcm9QYWQpKFwiMHhcIiArIHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZ25pbmdLZXkucHJvdG90eXBlLmNvbXB1dGVTaGFyZWRTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXJLZXkpIHtcbiAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKCgwLCBieXRlc18xLmFycmF5aWZ5KSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgdmFyIG90aGVyS2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYygoMCwgYnl0ZXNfMS5hcnJheWlmeSkoY29tcHV0ZVB1YmxpY0tleShvdGhlcktleSkpKTtcbiAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmhleFplcm9QYWQpKFwiMHhcIiArIGtleVBhaXIuZGVyaXZlKG90aGVyS2V5UGFpci5nZXRQdWJsaWMoKSkudG9TdHJpbmcoMTYpLCAzMik7XG4gICAgfTtcbiAgICBTaWduaW5nS2V5LmlzU2lnbmluZ0tleSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmluZ0tleSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2lnbmluZ0tleTtcbn0oKSk7XG5leHBvcnRzLlNpZ25pbmdLZXkgPSBTaWduaW5nS2V5O1xuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHZhciBzaWcgPSAoMCwgYnl0ZXNfMS5zcGxpdFNpZ25hdHVyZSkoc2lnbmF0dXJlKTtcbiAgICB2YXIgcnMgPSB7IHI6ICgwLCBieXRlc18xLmFycmF5aWZ5KShzaWcuciksIHM6ICgwLCBieXRlc18xLmFycmF5aWZ5KShzaWcucykgfTtcbiAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5yZWNvdmVyUHViS2V5KCgwLCBieXRlc18xLmFycmF5aWZ5KShkaWdlc3QpLCBycywgc2lnLnJlY292ZXJ5UGFyYW0pLmVuY29kZShcImhleFwiLCBmYWxzZSk7XG59XG5leHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5O1xuZnVuY3Rpb24gY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICB2YXIgYnl0ZXMgPSAoMCwgYnl0ZXNfMS5hcnJheWlmeSkoa2V5KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICB2YXIgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGJ5dGVzKTtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXkucHVibGljS2V5O1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDMzKSB7XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4bGlmeSkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyhmYWxzZSwgXCJoZXhcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgaWYgKCFjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4bGlmeSkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHB1YmxpYyBvciBwcml2YXRlIGtleVwiLCBcImtleVwiLCBcIltSRURBQ1RFRF1cIik7XG59XG5leHBvcnRzLmNvbXB1dGVQdWJsaWNLZXkgPSBjb21wdXRlUHVibGljS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/_version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/strings/lib/_version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"strings/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliL192ZXJzaW9uLmpzPzYyOTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSBcInN0cmluZ3MvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/bytes32.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/strings/lib/bytes32.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseBytes32String = exports.formatBytes32String = void 0;\nvar constants_1 = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar utf8_1 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/utf8.js\");\nfunction formatBytes32String(text) {\n    // Get the bytes\n    var bytes = (0, utf8_1.toUtf8Bytes)(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\n    }\n    // Zero-pad (implicitly null-terminates)\n    return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes, constants_1.HashZero]).slice(0, 32));\n}\nexports.formatBytes32String = formatBytes32String;\nfunction parseBytes32String(bytes) {\n    var data = (0, bytes_1.arrayify)(bytes);\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n    }\n    if (data[31] !== 0) {\n        throw new Error(\"invalid bytes32 string - no null terminator\");\n    }\n    // Find the null termination\n    var length = 31;\n    while (data[length - 1] === 0) {\n        length--;\n    }\n    // Determine the string value\n    return (0, utf8_1.toUtf8String)(data.slice(0, length));\n}\nexports.parseBytes32String = parseBytes32String;\n//# sourceMappingURL=bytes32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi9ieXRlczMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLDJCQUEyQjtBQUN4RCxrQkFBa0IsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsMkZBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi9ieXRlczMyLmpzPzgwYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuZm9ybWF0Qnl0ZXMzMlN0cmluZyA9IHZvaWQgMDtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciB1dGY4XzEgPSByZXF1aXJlKFwiLi91dGY4XCIpO1xuZnVuY3Rpb24gZm9ybWF0Qnl0ZXMzMlN0cmluZyh0ZXh0KSB7XG4gICAgLy8gR2V0IHRoZSBieXRlc1xuICAgIHZhciBieXRlcyA9ICgwLCB1dGY4XzEudG9VdGY4Qnl0ZXMpKHRleHQpO1xuICAgIC8vIENoZWNrIHdlIGhhdmUgcm9vbSBmb3IgbnVsbC10ZXJtaW5hdGlvblxuICAgIGlmIChieXRlcy5sZW5ndGggPiAzMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJieXRlczMyIHN0cmluZyBtdXN0IGJlIGxlc3MgdGhhbiAzMiBieXRlc1wiKTtcbiAgICB9XG4gICAgLy8gWmVyby1wYWQgKGltcGxpY2l0bHkgbnVsbC10ZXJtaW5hdGVzKVxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KSgoMCwgYnl0ZXNfMS5jb25jYXQpKFtieXRlcywgY29uc3RhbnRzXzEuSGFzaFplcm9dKS5zbGljZSgwLCAzMikpO1xufVxuZXhwb3J0cy5mb3JtYXRCeXRlczMyU3RyaW5nID0gZm9ybWF0Qnl0ZXMzMlN0cmluZztcbmZ1bmN0aW9uIHBhcnNlQnl0ZXMzMlN0cmluZyhieXRlcykge1xuICAgIHZhciBkYXRhID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGJ5dGVzKTtcbiAgICAvLyBNdXN0IGJlIDMyIGJ5dGVzIHdpdGggYSBudWxsLXRlcm1pbmF0aW9uXG4gICAgaWYgKGRhdGEubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgLSBub3QgMzIgYnl0ZXMgbG9uZ1wiKTtcbiAgICB9XG4gICAgaWYgKGRhdGFbMzFdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMzMiBzdHJpbmcgLSBubyBudWxsIHRlcm1pbmF0b3JcIik7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIG51bGwgdGVybWluYXRpb25cbiAgICB2YXIgbGVuZ3RoID0gMzE7XG4gICAgd2hpbGUgKGRhdGFbbGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgfVxuICAgIC8vIERldGVybWluZSB0aGUgc3RyaW5nIHZhbHVlXG4gICAgcmV0dXJuICgwLCB1dGY4XzEudG9VdGY4U3RyaW5nKShkYXRhLnNsaWNlKDAsIGxlbmd0aCkpO1xufVxuZXhwb3J0cy5wYXJzZUJ5dGVzMzJTdHJpbmcgPSBwYXJzZUJ5dGVzMzJTdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlczMyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/bytes32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/idna.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/strings/lib/idna.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = void 0;\nvar utf8_1 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/utf8.js\");\nfunction bytes2(data) {\n    if ((data.length % 4) !== 0) {\n        throw new Error(\"bad data\");\n    }\n    var result = [];\n    for (var i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\nfunction createTable(data, func) {\n    if (!func) {\n        func = function (value) { return [parseInt(value, 16)]; };\n    }\n    var lo = 0;\n    var result = {};\n    data.split(\",\").forEach(function (pair) {\n        var comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n    return result;\n}\nfunction createRangeTable(data) {\n    var hi = 0;\n    return data.split(\",\").map(function (v) {\n        var comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        }\n        else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n        var lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\nfunction matchMap(value, ranges) {\n    var lo = 0;\n    for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) {\n                continue;\n            }\n            return range;\n        }\n    }\n    return null;\n}\nvar Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n// @TODO: Make this relative...\nvar Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map(function (v) { return parseInt(v, 16); });\nvar Table_B_2_ranges = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [23], l: 127 },\n    { h: 54, s: 1, e: [48], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\n    { h: 26, s: 32, e: [17], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [38], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\n    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [17], l: 56 },\n    { h: 24, s: -119601, e: [17], l: 58 },\n    { h: 24, s: -119659, e: [17], l: 58 },\n    { h: 24, s: -119717, e: [17], l: 58 },\n    { h: 24, s: -119775, e: [17], l: 58 }\n];\nvar Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nvar Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nvar Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\nvar Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\nfunction flatten(values) {\n    return values.reduce(function (accum, value) {\n        value.forEach(function (value) { accum.push(value); });\n        return accum;\n    }, []);\n}\nfunction _nameprepTableA1(codepoint) {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\nexports._nameprepTableA1 = _nameprepTableA1;\nfunction _nameprepTableB2(codepoint) {\n    var range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) {\n        return [codepoint + range.s];\n    }\n    var codes = Table_B_2_lut_abs[codepoint];\n    if (codes) {\n        return codes;\n    }\n    var shift = Table_B_2_lut_rel[codepoint];\n    if (shift) {\n        return [codepoint + shift[0]];\n    }\n    var complex = Table_B_2_complex[codepoint];\n    if (complex) {\n        return complex;\n    }\n    return null;\n}\nexports._nameprepTableB2 = _nameprepTableB2;\nfunction _nameprepTableC(codepoint) {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\nexports._nameprepTableC = _nameprepTableC;\nfunction nameprep(value) {\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\n        return value.toLowerCase();\n    }\n    // Get the code points (keeping the current normalization)\n    var codes = (0, utf8_1.toUtf8CodePoints)(value);\n    codes = flatten(codes.map(function (code) {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) {\n            return [];\n        }\n        if (code >= 0xfe00 && code <= 0xfe0f) {\n            return [];\n        }\n        // Substitute Table B.2 (Case Folding)\n        var codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) {\n            return codesTableB2;\n        }\n        // No Substitution\n        return [code];\n    }));\n    // Normalize using form KC\n    codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach(function (code) {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach(function (code) {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n    // IDNA extras\n    var name = (0, utf8_1._toUtf8String)(codes);\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n    // IDNA: 4.2.4\n    if (name.length > 63) {\n        throw new Error(\"too long\");\n    }\n    return name;\n}\nexports.nameprep = nameprep;\n//# sourceMappingURL=idna.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi9pZG5hLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QjtBQUNoRyxhQUFhLG1CQUFPLENBQUMsMkZBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcseUJBQXlCO0FBQ25JO0FBQ0EsTUFBTSxxQkFBcUI7QUFDM0IsTUFBTSwrQkFBK0I7QUFDckMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSx3Q0FBd0M7QUFDOUMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwyQ0FBMkM7QUFDakQsTUFBTSwrQkFBK0I7QUFDckMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSxxQkFBcUI7QUFDM0IsTUFBTSxxQkFBcUI7QUFDM0IsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSxxQkFBcUI7QUFDM0IsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSxzQkFBc0I7QUFDNUIsTUFBTSxzQkFBc0I7QUFDNUIsTUFBTSx3QkFBd0I7QUFDOUIsTUFBTSx1QkFBdUI7QUFDN0IsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwREFBMEQ7QUFDaEUsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSw0Q0FBNEM7QUFDbEQsTUFBTSxxREFBcUQ7QUFDM0QsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTSxtQ0FBbUM7QUFDekMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliL2lkbmEuanM/ZGM2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmFtZXByZXAgPSBleHBvcnRzLl9uYW1lcHJlcFRhYmxlQyA9IGV4cG9ydHMuX25hbWVwcmVwVGFibGVCMiA9IGV4cG9ydHMuX25hbWVwcmVwVGFibGVBMSA9IHZvaWQgMDtcbnZhciB1dGY4XzEgPSByZXF1aXJlKFwiLi91dGY4XCIpO1xuZnVuY3Rpb24gYnl0ZXMyKGRhdGEpIHtcbiAgICBpZiAoKGRhdGEubGVuZ3RoICUgNCkgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGRhdGFcIik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoZGF0YS5zdWJzdHJpbmcoaSwgaSArIDQpLCAxNikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGUoZGF0YSwgZnVuYykge1xuICAgIGlmICghZnVuYykge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBbcGFyc2VJbnQodmFsdWUsIDE2KV07IH07XG4gICAgfVxuICAgIHZhciBsbyA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGRhdGEuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgdmFyIGNvbXBzID0gcGFpci5zcGxpdChcIjpcIik7XG4gICAgICAgIGxvICs9IHBhcnNlSW50KGNvbXBzWzBdLCAxNik7XG4gICAgICAgIHJlc3VsdFtsb10gPSBmdW5jKGNvbXBzWzFdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlUmFuZ2VUYWJsZShkYXRhKSB7XG4gICAgdmFyIGhpID0gMDtcbiAgICByZXR1cm4gZGF0YS5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBjb21wcyA9IHYuc3BsaXQoXCItXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb21wc1sxXSA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBzWzFdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb21wc1sxXSA9IFwiMVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsbyA9IGhpICsgcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcbiAgICAgICAgaGkgPSBwYXJzZUludChjb21wc1sxXSwgMTYpO1xuICAgICAgICByZXR1cm4geyBsOiBsbywgaDogaGkgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoTWFwKHZhbHVlLCByYW5nZXMpIHtcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbG8gKz0gcmFuZ2UubDtcbiAgICAgICAgaWYgKHZhbHVlID49IGxvICYmIHZhbHVlIDw9IGxvICsgcmFuZ2UuaCAmJiAoKHZhbHVlIC0gbG8pICUgKHJhbmdlLmQgfHwgMSkpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZSAmJiByYW5nZS5lLmluZGV4T2YodmFsdWUgLSBsbykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgVGFibGVfQV8xX3JhbmdlcyA9IGNyZWF0ZVJhbmdlVGFibGUoXCIyMjEsMTMtMWIsNWYtLDQwLTEwLDUxLWYsMTEtMywzLTMsMi0yLDItNCw4LDIsMTUsMmQsMjgtOCw4OCw0OCwyNy0sMy01LDExLTIwLDI3LSw4LDI4LDMtNSwxMiwxOCxiLWEsMWMtNCw2LTE2LDItZCwyLTIsMiwxYi00LDE3LTksOGYtLDEwLGYsMWYtMiwxYy0zNCwzMy0xNGUsNCwzNi0sMTMtLDYtMiwxYS1mLDQsOS0sMy0sMTcsOCwyLTIsNS0sMiw4LSwzLSw0LTgsMi0zLDMsNi0sMTYtNiwyLSw3LTMsMy0sMTcsOCwzLDMsMy0sMiw2LTMsMy0sNC1hLDUsMi02LDEwLWIsNCw4LDIsNCwxNyw4LDMsNi0sYiw0LDQtLDItZSwyLTQsYi0xMCw0LDktLDMtLDE3LDgsMy0sNS0sOS0yLDMtLDQtNywzLTMsMyw0LTMsYy0xMCwzLDctMiw0LDUtMiwzLDIsMy0yLDMtMiw0LTIsOSw0LTMsNi0yLDQsNS04LDItZSxkLWQsNCw5LDQsMTgsYiw2LTMsOCw0LDUtNiwzLTgsMy0zLGItMTEsMyw5LDQsMTgsYiw2LTMsOCw0LDUtNiwzLTYsMiwzLTMsYi0xMSwzLDksNCwxOCwxMS0zLDctLDQsNS04LDItNywzLTMsYi0xMSwzLDEzLTIsMTksYSwyLSw4LTIsMi0zLDcsMiw5LTExLDQtYiwzYi0zLDFlLTI0LDMsMi0sMywyLSwyLTUsNSw4LDQsMiwyLSwzLGUsNC0sNiwyLDctLGItLDMtMjEsNDksMjMtNSwxYy0zLDksMjUsMTAtLDItMmYsMjMsNiwzLDgtMiw1LTUsMWItNDUsMjctOSwyYS0sMi0zLDViLTQsNDUtNCw1My01LDgsNDAsMiw1LSw4LDIsNS0sMjgsMiw1LSwyMCwyLDUtLDgsMiw1LSw4LDgsMTgsMjAsMiw1LSw4LDI4LDE0LTUsMWQtMjIsNTYtYiwyNzctOCwxZS0yLDUyLWUsZSw4LWEsMTgtOCwxNS1iLGUsNCwzLWIsNWUtMixiLTE1LDEwLGItNSw1OS03LDJiLTU1NSw5ZC0zLDViLTUsMTctLDctLDI3LSw3LSw5LDIsMiwyLDIwLSwzNiwxMCxmLSw3LDE0LSw0LGEsNTQtMywyLTYsNi01LDktLDFjLTEwLDEzLTFkLDFjLTE0LDNjLSwxMC02LDMyLWIsMjQwLTMwLDI4LTE4LGMtMTQsYTAsMTE1LSwzLDY2LSxiLTc2LDUsNS0sMWQsMjQsMiw1LTIsMiw4LSwzNS0yLDE5LGYtMTAsMWQtMywzMTEtMzdmLDFiLDVhLWIsZDctMTksZC0zLDQxLDU3LSw2OC00LDI5LTMsNWYsMjktMzcsMmUtMiwyNS1jLDJjLTIsNGUtMywzMCw3OC0zLDY0LSwyMCwxOWI3LTQ5LDUxYTctNTksNDhlLTIsMzgtNzM4LDJiYTUtNWIsMjIyZi0sM2MtOTQsOC1iLDYtNCwxYiw2LDIsMywzLDZkLTIwLDE2ZS1mLDQxLSwzNy03LDJlLTIsMTEtZiw1LWIsMTgtLGIsMTQsNS0zLDYsODgtLDIsYmYtMiw3LSw3LSw3LSw0LTIsOCw4LTksOC0yZmYsMjAsNS1iLDFjLWI0LDI3LSwyNy1jYmIxLGY3LTksMjgtMixiNS0yMjEsNTYsNDgsMy0sMi0sMy0sNSxkLDIsNSwzLDQyLDUtLDksOCwxZCw1LDYsMi0yLDgsMTUzLTMsMTIzLTMsMzMtMjdmZCxhNmRhLTUxMjgsMjFmLTVkZiwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMsMi0xZCw2MS1mZjdkXCIpO1xuLy8gQFRPRE86IE1ha2UgdGhpcyByZWxhdGl2ZS4uLlxudmFyIFRhYmxlX0JfMV9mbGFncyA9IFwiYWQsMzRmLDE4MDYsMTgwYiwxODBjLDE4MGQsMjAwYiwyMDBjLDIwMGQsMjA2MCxmZWZmXCIuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcGFyc2VJbnQodiwgMTYpOyB9KTtcbnZhciBUYWJsZV9CXzJfcmFuZ2VzID0gW1xuICAgIHsgaDogMjUsIHM6IDMyLCBsOiA2NSB9LFxuICAgIHsgaDogMzAsIHM6IDMyLCBlOiBbMjNdLCBsOiAxMjcgfSxcbiAgICB7IGg6IDU0LCBzOiAxLCBlOiBbNDhdLCBsOiA2NCwgZDogMiB9LFxuICAgIHsgaDogMTQsIHM6IDEsIGw6IDU3LCBkOiAyIH0sXG4gICAgeyBoOiA0NCwgczogMSwgbDogMTcsIGQ6IDIgfSxcbiAgICB7IGg6IDEwLCBzOiAxLCBlOiBbMiwgNiwgOF0sIGw6IDYxLCBkOiAyIH0sXG4gICAgeyBoOiAxNiwgczogMSwgbDogNjgsIGQ6IDIgfSxcbiAgICB7IGg6IDg0LCBzOiAxLCBlOiBbMTgsIDI0LCA2Nl0sIGw6IDE5LCBkOiAyIH0sXG4gICAgeyBoOiAyNiwgczogMzIsIGU6IFsxN10sIGw6IDQzNSB9LFxuICAgIHsgaDogMjIsIHM6IDEsIGw6IDcxLCBkOiAyIH0sXG4gICAgeyBoOiAxNSwgczogODAsIGw6IDQwIH0sXG4gICAgeyBoOiAzMSwgczogMzIsIGw6IDE2IH0sXG4gICAgeyBoOiAzMiwgczogMSwgbDogODAsIGQ6IDIgfSxcbiAgICB7IGg6IDUyLCBzOiAxLCBsOiA0MiwgZDogMiB9LFxuICAgIHsgaDogMTIsIHM6IDEsIGw6IDU1LCBkOiAyIH0sXG4gICAgeyBoOiA0MCwgczogMSwgZTogWzM4XSwgbDogMTUsIGQ6IDIgfSxcbiAgICB7IGg6IDE0LCBzOiAxLCBsOiA0OCwgZDogMiB9LFxuICAgIHsgaDogMzcsIHM6IDQ4LCBsOiA0OSB9LFxuICAgIHsgaDogMTQ4LCBzOiAxLCBsOiA2MzUxLCBkOiAyIH0sXG4gICAgeyBoOiA4OCwgczogMSwgbDogMTYwLCBkOiAyIH0sXG4gICAgeyBoOiAxNSwgczogMTYsIGw6IDcwNCB9LFxuICAgIHsgaDogMjUsIHM6IDI2LCBsOiA4NTQgfSxcbiAgICB7IGg6IDI1LCBzOiAzMiwgbDogNTU5MTUgfSxcbiAgICB7IGg6IDM3LCBzOiA0MCwgbDogMTI0NyB9LFxuICAgIHsgaDogMjUsIHM6IC0xMTk3MTEsIGw6IDUzMjQ4IH0sXG4gICAgeyBoOiAyNSwgczogLTExOTc2MywgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTE5ODE1LCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMTk4NjcsIGU6IFsxLCA0LCA1LCA3LCA4LCAxMSwgMTIsIDE3XSwgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTE5OTE5LCBsOiA1MiB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk5NzEsIGU6IFsyLCA3LCA4LCAxN10sIGw6IDUyIH0sXG4gICAgeyBoOiAyNCwgczogLTEyMDAyMywgZTogWzIsIDcsIDEzLCAxNSwgMTYsIDE3XSwgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTIwMDc1LCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMjAxMjcsIGw6IDUyIH0sXG4gICAgeyBoOiAyNSwgczogLTEyMDE3OSwgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTIwMjMxLCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMjAyODMsIGw6IDUyIH0sXG4gICAgeyBoOiAyNSwgczogLTEyMDMzNSwgbDogNTIgfSxcbiAgICB7IGg6IDI0LCBzOiAtMTE5NTQzLCBlOiBbMTddLCBsOiA1NiB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk2MDEsIGU6IFsxN10sIGw6IDU4IH0sXG4gICAgeyBoOiAyNCwgczogLTExOTY1OSwgZTogWzE3XSwgbDogNTggfSxcbiAgICB7IGg6IDI0LCBzOiAtMTE5NzE3LCBlOiBbMTddLCBsOiA1OCB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk3NzUsIGU6IFsxN10sIGw6IDU4IH1cbl07XG52YXIgVGFibGVfQl8yX2x1dF9hYnMgPSBjcmVhdGVUYWJsZShcImI1OjNiYyxjMzpmZiw3OjczLDI6MjUzLDU6MjU0LDM6MjU2LDE6MjU3LDU6MjU5LDE6MjViLDM6MjYwLDE6MjYzLDI6MjY5LDE6MjY4LDU6MjZmLDE6MjcyLDI6Mjc1LDc6MjgwLDM6MjgzLDU6Mjg4LDM6MjhhLDE6MjhiLDU6MjkyLDNmOjE5NSwxOjFiZiwyOToxOWUsMTI1OjNiOSw4YjozYjIsMTozYjgsMTozYzUsMzozYzYsMTozYzAsMWE6M2JhLDE6M2MxLDE6M2MzLDI6M2I4LDE6M2I1LDFiYzk6M2I5LDFjOjFmNzYsMToxZjc3LGY6MWY3YSwxOjFmN2IsZDoxZjc4LDE6MWY3OSwxOjFmN2MsMToxZjdkLDEwNzo2Myw1OjI1Yiw0OjY4LDE6NjgsMTo2OCwzOjY5LDE6NjksMTo2YywzOjZlLDQ6NzAsMTo3MSwxOjcyLDE6NzIsMTo3Miw3OjdhLDI6M2M5LDI6N2EsMjo2YiwxOmU1LDE6NjIsMTo2MywzOjY1LDE6NjYsMjo2ZCxiOjNiMywxOjNjMCw2OjY0LDFiNTc0OjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjM1wiKTtcbnZhciBUYWJsZV9CXzJfbHV0X3JlbCA9IGNyZWF0ZVRhYmxlKFwiMTc5OjEsMjoxLDI6MSw1OjEsMjoxLGE6NGYsYToxLDg6MSwyOjEsMjoxLDM6MSw1OjEsMzoxLDQ6MSwyOjEsMzoxLDQ6MSw4OjIsMToxLDI6MiwxOjEsMjoyLDI3OjIsMTk1OjI2LDI6MjUsMToyNSwxOjI1LDI6NDAsMjozZiwxOjNmLDMzOjEsMTE6LTYsMTotOSwxYWM3Oi0zYSw2ZDotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LGI6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYzotOCwyOi04LDI6LTgsMjotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsNDk6LTgsMTotOCwxOi00YSwxOi00YSxkOi01NiwxOi01NiwxOi01NiwxOi01NixkOi04LDE6LTgsZjotOCwxOi04LDM6LTdcIik7XG52YXIgVGFibGVfQl8yX2NvbXBsZXggPSBjcmVhdGVUYWJsZShcImRmOjAwNzMwMDczLDUxOjAwNjkwMzA3LDE5OjAyQkMwMDZFLGE3OjAwNkEwMzBDLDE4YTowMDIwMDNCOSwxNjowM0I5MDMwODAzMDEsMjA6MDNDNTAzMDgwMzAxLDFkNzowNTY1MDU4MiwxOTBmOjAwNjgwMzMxLDE6MDA3NDAzMDgsMTowMDc3MDMwQSwxOjAwNzkwMzBBLDE6MDA2MTAyQkUsYjY6MDNDNTAzMTMsMjowM0M1MDMxMzAzMDAsMjowM0M1MDMxMzAzMDEsMjowM0M1MDMxMzAzNDIsMmE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDM6MUY3MDAzQjksMTowM0IxMDNCOSwxOjAzQUMwM0I5LDI6MDNCMTAzNDIsMTowM0IxMDM0MjAzQjksNTowM0IxMDNCOSw2OjFGNzQwM0I5LDE6MDNCNzAzQjksMTowM0FFMDNCOSwyOjAzQjcwMzQyLDE6MDNCNzAzNDIwM0I5LDU6MDNCNzAzQjksNjowM0I5MDMwODAzMDAsMTowM0I5MDMwODAzMDEsMzowM0I5MDM0MiwxOjAzQjkwMzA4MDM0MixiOjAzQzUwMzA4MDMwMCwxOjAzQzUwMzA4MDMwMSwxOjAzQzEwMzEzLDI6MDNDNTAzNDIsMTowM0M1MDMwODAzNDIsYjoxRjdDMDNCOSwxOjAzQzkwM0I5LDE6MDNDRTAzQjksMjowM0M5MDM0MiwxOjAzQzkwMzQyMDNCOSw1OjAzQzkwM0I5LGFjOjAwNzIwMDczLDViOjAwQjAwMDYzLDY6MDBCMDAwNjYsZDowMDZFMDA2RixhOjAwNzMwMDZELDE6MDA3NDAwNjUwMDZDLDE6MDA3NDAwNkQsMTI0ZjowMDY4MDA3MDAwNjEsMjowMDYxMDA3NSwyOjAwNkYwMDc2LGI6MDA3MDAwNjEsMTowMDZFMDA2MSwxOjAzQkMwMDYxLDE6MDA2RDAwNjEsMTowMDZCMDA2MSwxOjAwNkIwMDYyLDE6MDA2RDAwNjIsMTowMDY3MDA2MiwzOjAwNzAwMDY2LDE6MDA2RTAwNjYsMTowM0JDMDA2Niw0OjAwNjgwMDdBLDE6MDA2QjAwNjgwMDdBLDE6MDA2RDAwNjgwMDdBLDE6MDA2NzAwNjgwMDdBLDE6MDA3NDAwNjgwMDdBLDE1OjAwNzAwMDYxLDE6MDA2QjAwNzAwMDYxLDE6MDA2RDAwNzAwMDYxLDE6MDA2NzAwNzAwMDYxLDg6MDA3MDAwNzYsMTowMDZFMDA3NiwxOjAzQkMwMDc2LDE6MDA2RDAwNzYsMTowMDZCMDA3NiwxOjAwNkQwMDc2LDE6MDA3MDAwNzcsMTowMDZFMDA3NywxOjAzQkMwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAzQzksMTowMDZEMDNDOSwyOjAwNjIwMDcxLDM6MDA2MzIyMTUwMDZCMDA2NywxOjAwNjMwMDZGMDAyRSwxOjAwNjQwMDYyLDE6MDA2NzAwNzksMjowMDY4MDA3MCwyOjAwNkIwMDZCLDE6MDA2QjAwNkQsOTowMDcwMDA2OCwyOjAwNzAwMDcwMDA2RCwxOjAwNzAwMDcyLDI6MDA3MzAwNzYsMTowMDc3MDA2MixjNzIzOjAwNjYwMDY2LDE6MDA2NjAwNjksMTowMDY2MDA2QywxOjAwNjYwMDY2MDA2OSwxOjAwNjYwMDY2MDA2QywxOjAwNzMwMDc0LDE6MDA3MzAwNzQsZDowNTc0MDU3NiwxOjA1NzQwNTY1LDE6MDU3NDA1NkIsMTowNTdFMDU3NiwxOjA1NzQwNTZEXCIsIGJ5dGVzMik7XG52YXIgVGFibGVfQ19yYW5nZXMgPSBjcmVhdGVSYW5nZVRhYmxlKFwiODAtMjAsMmEwLSwzOWMsMzIsZjcxLDE4ZSw3ZjItZiwxOS03LDMwLTQsNy01LGY4MS1iLDUsYTgwMC0yMGZmLDRkMS0xZiwxMTAsZmEtNixkMTc0LTcsMmU4NC0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sZmZmZi0sMiwxZi01ZixmZjdmLTIwMDAxXCIpO1xuZnVuY3Rpb24gZmxhdHRlbih2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IGFjY3VtLnB1c2godmFsdWUpOyB9KTtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQTEoY29kZXBvaW50KSB7XG4gICAgcmV0dXJuICEhbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9BXzFfcmFuZ2VzKTtcbn1cbmV4cG9ydHMuX25hbWVwcmVwVGFibGVBMSA9IF9uYW1lcHJlcFRhYmxlQTE7XG5mdW5jdGlvbiBfbmFtZXByZXBUYWJsZUIyKGNvZGVwb2ludCkge1xuICAgIHZhciByYW5nZSA9IG1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQl8yX3Jhbmdlcyk7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBbY29kZXBvaW50ICsgcmFuZ2Uuc107XG4gICAgfVxuICAgIHZhciBjb2RlcyA9IFRhYmxlX0JfMl9sdXRfYWJzW2NvZGVwb2ludF07XG4gICAgaWYgKGNvZGVzKSB7XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9XG4gICAgdmFyIHNoaWZ0ID0gVGFibGVfQl8yX2x1dF9yZWxbY29kZXBvaW50XTtcbiAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgcmV0dXJuIFtjb2RlcG9pbnQgKyBzaGlmdFswXV07XG4gICAgfVxuICAgIHZhciBjb21wbGV4ID0gVGFibGVfQl8yX2NvbXBsZXhbY29kZXBvaW50XTtcbiAgICBpZiAoY29tcGxleCkge1xuICAgICAgICByZXR1cm4gY29tcGxleDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLl9uYW1lcHJlcFRhYmxlQjIgPSBfbmFtZXByZXBUYWJsZUIyO1xuZnVuY3Rpb24gX25hbWVwcmVwVGFibGVDKGNvZGVwb2ludCkge1xuICAgIHJldHVybiAhIW1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQ19yYW5nZXMpO1xufVxuZXhwb3J0cy5fbmFtZXByZXBUYWJsZUMgPSBfbmFtZXByZXBUYWJsZUM7XG5mdW5jdGlvbiBuYW1lcHJlcCh2YWx1ZSkge1xuICAgIC8vIFRoaXMgYWxsb3dzIHBsYXRmb3JtcyB3aXRoIGluY29tcGxldGUgbm9ybWFsaXplIHRvIGJ5cGFzc1xuICAgIC8vIGl0IGZvciB2ZXJ5IGJhc2ljIG5hbWVzIHdoaWNoIHRoZSBidWlsdC1pbiB0b0xvd2VyQ2FzZVxuICAgIC8vIHdpbGwgY2VydGFpbmx5IGhhbmRsZSBjb3JyZWN0bHlcbiAgICBpZiAodmFsdWUubWF0Y2goL15bYS16MC05LV0qJC9pKSAmJiB2YWx1ZS5sZW5ndGggPD0gNTkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgY29kZSBwb2ludHMgKGtlZXBpbmcgdGhlIGN1cnJlbnQgbm9ybWFsaXphdGlvbilcbiAgICB2YXIgY29kZXMgPSAoMCwgdXRmOF8xLnRvVXRmOENvZGVQb2ludHMpKHZhbHVlKTtcbiAgICBjb2RlcyA9IGZsYXR0ZW4oY29kZXMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgVGFibGUgQi4xIChNYXBzIHRvIE5vdGhpbmcpXG4gICAgICAgIGlmIChUYWJsZV9CXzFfZmxhZ3MuaW5kZXhPZihjb2RlKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUgPj0gMHhmZTAwICYmIGNvZGUgPD0gMHhmZTBmKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3Vic3RpdHV0ZSBUYWJsZSBCLjIgKENhc2UgRm9sZGluZylcbiAgICAgICAgdmFyIGNvZGVzVGFibGVCMiA9IF9uYW1lcHJlcFRhYmxlQjIoY29kZSk7XG4gICAgICAgIGlmIChjb2Rlc1RhYmxlQjIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2Rlc1RhYmxlQjI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gU3Vic3RpdHV0aW9uXG4gICAgICAgIHJldHVybiBbY29kZV07XG4gICAgfSkpO1xuICAgIC8vIE5vcm1hbGl6ZSB1c2luZyBmb3JtIEtDXG4gICAgY29kZXMgPSAoMCwgdXRmOF8xLnRvVXRmOENvZGVQb2ludHMpKCgwLCB1dGY4XzEuX3RvVXRmOFN0cmluZykoY29kZXMpLCB1dGY4XzEuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO1xuICAgIC8vIFByb2hpYml0IFRhYmxlcyBDLjEuMiwgQy4yLjIsIEMuMywgQy40LCBDLjUsIEMuNiwgQy43LCBDLjgsIEMuOVxuICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQyhjb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1RSSU5HUFJFUF9DT05UQUlOU19QUk9ISUJJVEVEXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gUHJvaGliaXQgVW5hc3NpZ25lZCBDb2RlIFBvaW50cyAoVGFibGUgQS4xKVxuICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQTEoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNUUklOR1BSRVBfQ09OVEFJTlNfVU5BU1NJR05FRFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElETkEgZXh0cmFzXG4gICAgdmFyIG5hbWUgPSAoMCwgdXRmOF8xLl90b1V0ZjhTdHJpbmcpKGNvZGVzKTtcbiAgICAvLyBJRE5BOiA0LjIuMy4xXG4gICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIiB8fCBuYW1lLnN1YnN0cmluZygyLCA0KSA9PT0gXCItLVwiIHx8IG5hbWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoIC0gMSkgPT09IFwiLVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaHlwaGVuXCIpO1xuICAgIH1cbiAgICAvLyBJRE5BOiA0LjIuNFxuICAgIGlmIChuYW1lLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBsb25nXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmV4cG9ydHMubmFtZXByZXAgPSBuYW1lcHJlcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkbmEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/idna.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = void 0;\nvar bytes32_1 = __webpack_require__(/*! ./bytes32 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/bytes32.js\");\nObject.defineProperty(exports, \"formatBytes32String\", ({ enumerable: true, get: function () { return bytes32_1.formatBytes32String; } }));\nObject.defineProperty(exports, \"parseBytes32String\", ({ enumerable: true, get: function () { return bytes32_1.parseBytes32String; } }));\nvar idna_1 = __webpack_require__(/*! ./idna */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/idna.js\");\nObject.defineProperty(exports, \"nameprep\", ({ enumerable: true, get: function () { return idna_1.nameprep; } }));\nvar utf8_1 = __webpack_require__(/*! ./utf8 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/utf8.js\");\nObject.defineProperty(exports, \"_toEscapedUtf8String\", ({ enumerable: true, get: function () { return utf8_1._toEscapedUtf8String; } }));\nObject.defineProperty(exports, \"toUtf8Bytes\", ({ enumerable: true, get: function () { return utf8_1.toUtf8Bytes; } }));\nObject.defineProperty(exports, \"toUtf8CodePoints\", ({ enumerable: true, get: function () { return utf8_1.toUtf8CodePoints; } }));\nObject.defineProperty(exports, \"toUtf8String\", ({ enumerable: true, get: function () { return utf8_1.toUtf8String; } }));\nObject.defineProperty(exports, \"UnicodeNormalizationForm\", ({ enumerable: true, get: function () { return utf8_1.UnicodeNormalizationForm; } }));\nObject.defineProperty(exports, \"Utf8ErrorFuncs\", ({ enumerable: true, get: function () { return utf8_1.Utf8ErrorFuncs; } }));\nObject.defineProperty(exports, \"Utf8ErrorReason\", ({ enumerable: true, get: function () { return utf8_1.Utf8ErrorReason; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxnQ0FBZ0MsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyw0QkFBNEI7QUFDeFEsZ0JBQWdCLG1CQUFPLENBQUMsaUdBQVc7QUFDbkMsdURBQXNELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3ZJLHNEQUFxRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNySSxhQUFhLG1CQUFPLENBQUMsMkZBQVE7QUFDN0IsNENBQTJDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzlHLGFBQWEsbUJBQU8sQ0FBQywyRkFBUTtBQUM3Qix3REFBdUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDdEksK0NBQThDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ3BILG9EQUFtRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM5SCxnREFBK0MsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDdEgsNERBQTJELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQzlJLGtEQUFpRCxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUMxSCxtREFBa0QsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDNUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIvaW5kZXguanM/NzM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmFtZXByZXAgPSBleHBvcnRzLnBhcnNlQnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuZm9ybWF0Qnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0gZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSBleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSBleHBvcnRzLnRvVXRmOENvZGVQb2ludHMgPSBleHBvcnRzLnRvVXRmOEJ5dGVzID0gZXhwb3J0cy5fdG9Fc2NhcGVkVXRmOFN0cmluZyA9IHZvaWQgMDtcbnZhciBieXRlczMyXzEgPSByZXF1aXJlKFwiLi9ieXRlczMyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0Qnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMzMl8xLmZvcm1hdEJ5dGVzMzJTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUJ5dGVzMzJTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzMzJfMS5wYXJzZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG52YXIgaWRuYV8xID0gcmVxdWlyZShcIi4vaWRuYVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5hbWVwcmVwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZG5hXzEubmFtZXByZXA7IH0gfSk7XG52YXIgdXRmOF8xID0gcmVxdWlyZShcIi4vdXRmOFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl90b0VzY2FwZWRVdGY4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4XzEuX3RvRXNjYXBlZFV0ZjhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOF8xLnRvVXRmOEJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4Q29kZVBvaW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOF8xLnRvVXRmOENvZGVQb2ludHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjhfMS50b1V0ZjhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjhfMS5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGY4RXJyb3JGdW5jc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRmOF8xLlV0ZjhFcnJvckZ1bmNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRmOEVycm9yUmVhc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4XzEuVXRmOEVycm9yUmVhc29uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/utf8.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/strings/lib/utf8.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(\"invalid codepoint at offset \" + offset + \"; \" + reason, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        var i = 0;\n        for (var o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nexports.Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = exports.Utf8ErrorFuncs.error;\n    }\n    bytes = (0, bytes_1.arrayify)(bytes);\n    var result = [];\n    var i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        var c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        var extraLength = null;\n        var overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (var j = 0; j < extraLength; j++) {\n            var nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    var result = [];\n    for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            var c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return (0, bytes_1.arrayify)(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\nfunction escapeChar(value) {\n    var hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nexports._toEscapedUtf8String = _toEscapedUtf8String;\nfunction _toUtf8String(codePoints) {\n    return codePoints.map(function (codePoint) {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nexports._toUtf8String = _toUtf8String;\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nexports.toUtf8String = toUtf8String;\nfunction toUtf8CodePoints(str, form) {\n    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\nexports.toUtf8CodePoints = toUtf8CodePoints;\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi91dGY4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLDRCQUE0QixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLGdDQUFnQztBQUNsTixjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsbUdBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrRUFBa0UsZ0NBQWdDLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsQ0FBQyxnREFBZ0QsdUJBQXVCLEtBQUs7QUFDN0U7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi91dGY4LmpzP2VjMzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVXRmOENvZGVQb2ludHMgPSBleHBvcnRzLnRvVXRmOFN0cmluZyA9IGV4cG9ydHMuX3RvVXRmOFN0cmluZyA9IGV4cG9ydHMuX3RvRXNjYXBlZFV0ZjhTdHJpbmcgPSBleHBvcnRzLnRvVXRmOEJ5dGVzID0gZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IGV4cG9ydHMuVXRmOEVycm9yUmVhc29uID0gZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSB2b2lkIDA7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG4oZnVuY3Rpb24gKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSkge1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GQ1wiXSA9IFwiTkZDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZEXCJdID0gXCJORkRcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLRFwiXSA9IFwiTkZLRFwiO1xufSkoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0gZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfHwgKGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0ge30pKTtcbjtcbnZhciBVdGY4RXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKFV0ZjhFcnJvclJlYXNvbikge1xuICAgIC8vIEEgY29udGludWF0aW9uIGJ5dGUgd2FzIHByZXNlbnQgd2hlcmUgdGhlcmUgd2FzIG5vdGhpbmcgdG8gY29udGludWVcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVU5FWFBFQ1RFRF9DT05USU5VRVwiXSA9IFwidW5leHBlY3RlZCBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIEFuIGludmFsaWQgKG5vbi1jb250aW51YXRpb24pIGJ5dGUgdG8gc3RhcnQgYSBVVEYtOCBjb2RlcG9pbnQgd2FzIGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIkJBRF9QUkVGSVhcIl0gPSBcImJhZCBjb2RlcG9pbnQgcHJlZml4XCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyB0b28gc2hvcnQgdG8gcHJvY2VzcyB0aGUgZXhwZWN0ZWQgY29kZXBvaW50XG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJSVU5cIl0gPSBcInN0cmluZyBvdmVycnVuXCI7XG4gICAgLy8gQSBtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBidXQgbm90IGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBhdFxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk1JU1NJTkdfQ09OVElOVUVcIl0gPSBcIm1pc3NpbmcgY29udGludWF0aW9uIGJ5dGVcIjtcbiAgICAvLyBUaGUgY29tcHV0ZWQgY29kZSBwb2ludCBpcyBvdXRzaWRlIHRoZSByYW5nZSBmb3IgVVRGLThcbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBvdXRzaWRlIHRoZSBVVEYtOCByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCI7XG4gICAgLy8gVVRGLTggc3RyaW5ncyBtYXkgbm90IGNvbnRhaW4gVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyc1xuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGluc2lkZSB0aGUgVVRGLTE2IHN1cnJvZ2F0ZSByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIlVURjE2X1NVUlJPR0FURVwiXSA9IFwiVVRGLTE2IHN1cnJvZ2F0ZVwiO1xuICAgIC8vIFRoZSBzdHJpbmcgaXMgYW4gb3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBhbHJlYWR5IGJvdW5kcyBjaGVja2VkXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUkxPTkdcIl0gPSBcIm92ZXJsb25nIHJlcHJlc2VudGF0aW9uXCI7XG59KShVdGY4RXJyb3JSZWFzb24gPSBleHBvcnRzLlV0ZjhFcnJvclJlYXNvbiB8fCAoZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSB7fSkpO1xuO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCBcIiArIG9mZnNldCArIFwiOyBcIiArIHJlYXNvbiwgXCJieXRlc1wiLCBieXRlcyk7XG59XG5mdW5jdGlvbiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbnZhbGlkIHByZWZpeCAoaW5jbHVkaW5nIHN0cmF5IGNvbnRpbnVhdGlvbiksIHNraXAgYW55IGFkZGl0aW9uYWwgY29udGludWF0aW9uIGJ5dGVzXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVggfHwgcmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAodmFyIG8gPSBvZmZzZXQgKyAxOyBvIDwgYnl0ZXMubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChieXRlc1tvXSA+PiA2ICE9PSAweDAyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8vIFRoaXMgYnl0ZSBydW5zIHVzIHBhc3QgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzbyBqdXN0IGp1bXAgdG8gdGhlIGVuZFxuICAgIC8vIChidXQgdGhlIGZpcnN0IGJ5dGUgd2FzIHJlYWQgYWxyZWFkeSByZWFkIGFuZCB0aGVyZWZvcmUgc2tpcHBlZClcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTikge1xuICAgICAgICByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IC0gMTtcbiAgICB9XG4gICAgLy8gTm90aGluZyB0byBza2lwXG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gT3ZlcmxvbmcgcmVwcmVzZW50YXRpb25zIGFyZSBvdGhlcndpc2UgXCJ2YWxpZFwiIGNvZGUgcG9pbnRzOyBqdXN0IG5vbi1kZWlzdGluZ3Rpc2hlZFxuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORykge1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vLyBDb21tb24gZXJyb3IgaGFuZGluZyBzdHJhdGVnaWVzXG5leHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MuZXJyb3I7XG4gICAgfVxuICAgIGJ5dGVzID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKGJ5dGVzKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IGJ5dGVzW2krK107XG4gICAgICAgIC8vIDB4eHggeHh4eFxuICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XG4gICAgICAgIHZhciBleHRyYUxlbmd0aCA9IG51bGw7XG4gICAgICAgIHZhciBvdmVybG9uZ01hc2sgPSBudWxsO1xuICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xuICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcbiAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVgsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIHdlIGhhdmUgZW5vdWdoIGJ5dGVzIGluIG91ciBkYXRhP1xuICAgICAgICBpZiAoaSAtIDEgKyBleHRyYUxlbmd0aCA+PSBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGNoYXJcbiAgICAgICAgdmFyIHJlcyA9IGMgJiAoKDEgPDwgKDggLSBleHRyYUxlbmd0aCAtIDEpKSAtIDEpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV4dHJhTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgLy8gSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICAgICAgaWYgKChuZXh0Q2hhciAmIDB4YzApICE9IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk1JU1NJTkdfQ09OVElOVUUsIGksIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG4gICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVVRfT0ZfUkFOR0UsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgaWYgKHJlcyA+PSAweGQ4MDAgJiYgcmVzIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VVEYxNl9TVVJST0dBVEUsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3Igb3Zlcmxvbmcgc2VxdWVuY2VzIChtb3JlIGJ5dGVzIHRoYW4gbmVlZGVkKVxuICAgICAgICBpZiAocmVzIDw9IG92ZXJsb25nTWFzaykge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORywgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcbmZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgIGlmIChmb3JtID09PSB2b2lkIDApIHsgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50OyB9XG4gICAgaWYgKGZvcm0gIT0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTm9ybWFsaXplKCk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB2YXIgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgdmFyIHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmFycmF5aWZ5KShyZXN1bHQpO1xufVxuZXhwb3J0cy50b1V0ZjhCeXRlcyA9IHRvVXRmOEJ5dGVzO1xuO1xuZnVuY3Rpb24gZXNjYXBlQ2hhcih2YWx1ZSkge1xuICAgIHZhciBoZXggPSAoXCIwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIHJldHVybiBcIlxcXFx1XCIgKyBoZXguc3Vic3RyaW5nKGhleC5sZW5ndGggLSA0KTtcbn1cbmZ1bmN0aW9uIF90b0VzY2FwZWRVdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuICdcIicgKyBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikubWFwKGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDI1Nikge1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBcIlxcXFxiXCI7XG4gICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gXCJcXFxcdFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDM0OiByZXR1cm4gXCJcXFxcXFxcIlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgOTI6IHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID49IDMyICYmIGNvZGVQb2ludCA8IDEyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVDaGFyKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBlc2NhcGVDaGFyKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCkgKyBlc2NhcGVDaGFyKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApO1xuICAgIH0pLmpvaW4oXCJcIikgKyAnXCInO1xufVxuZXhwb3J0cy5fdG9Fc2NhcGVkVXRmOFN0cmluZyA9IF90b0VzY2FwZWRVdGY4U3RyaW5nO1xuZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5leHBvcnRzLl90b1V0ZjhTdHJpbmcgPSBfdG9VdGY4U3RyaW5nO1xuZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbmV4cG9ydHMudG9VdGY4U3RyaW5nID0gdG9VdGY4U3RyaW5nO1xuZnVuY3Rpb24gdG9VdGY4Q29kZVBvaW50cyhzdHIsIGZvcm0pIHtcbiAgICBpZiAoZm9ybSA9PT0gdm9pZCAwKSB7IGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudDsgfVxuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbmV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHRvVXRmOENvZGVQb2ludHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/_version.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/transactions/lib/_version.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"transactions/5.5.0\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnMvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi9fdmVyc2lvbi5qcz8wZmI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJ0cmFuc2FjdGlvbnMvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/transactions/lib/index.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = exports.serialize = exports.accessListify = exports.recoverAddress = exports.computeAddress = exports.TransactionTypes = void 0;\nvar address_1 = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/address/lib/index.js\");\nvar bignumber_1 = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bignumber/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar constants_1 = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/constants/lib/index.js\");\nvar keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/keccak256/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar RLP = __importStar(__webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/rlp/lib/index.js\"));\nvar signing_key_1 = __webpack_require__(/*! @ethersproject/signing-key */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/signing-key/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar TransactionTypes;\n(function (TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes = exports.TransactionTypes || (exports.TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0, address_1.getAddress)(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return constants_1.Zero;\n    }\n    return bignumber_1.BigNumber.from(value);\n}\n// Legacy Transaction Fields\nvar transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nvar allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n};\nfunction computeAddress(key) {\n    var publicKey = (0, signing_key_1.computePublicKey)(key);\n    return (0, address_1.getAddress)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.hexDataSlice)(publicKey, 1)), 12));\n}\nexports.computeAddress = computeAddress;\nfunction recoverAddress(digest, signature) {\n    return computeAddress((0, signing_key_1.recoverPublicKey)((0, bytes_1.arrayify)(digest), signature));\n}\nexports.recoverAddress = recoverAddress;\nfunction formatNumber(value, name) {\n    var result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0, address_1.getAddress)(addr),\n        storageKeys: (storageKeys || []).map(function (storageKey, index) {\n            if ((0, bytes_1.hexDataLength)(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", \"accessList[\" + addr + \":\" + index + \"]\", storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (set, index) {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", \"value[\" + index + \"]\", set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    var result = Object.keys(value).map(function (addr) {\n        var storageKeys = value[addr].reduce(function (accum, storageKey) {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort(function (a, b) { return (a.address.localeCompare(b.address)); });\n    return result;\n}\nexports.accessListify = accessListify;\nfunction formatAccessList(value) {\n    return accessListify(value).map(function (set) { return [set.address, set.storageKeys]; });\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        var gasPrice = bignumber_1.BigNumber.from(transaction.gasPrice);\n        var maxFeePerGas = bignumber_1.BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice: gasPrice,\n                maxFeePerGas: maxFeePerGas\n            });\n        }\n    }\n    var fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? (0, address_1.getAddress)(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        var sig = (0, bytes_1.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0, bytes_1.stripZeros)(sig.r));\n        fields.push((0, bytes_1.stripZeros)(sig.s));\n    }\n    return (0, bytes_1.hexConcat)([\"0x02\", RLP.encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    var fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? (0, address_1.getAddress)(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        var sig = (0, bytes_1.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0, bytes_1.stripZeros)(sig.r));\n        fields.push((0, bytes_1.stripZeros)(sig.s));\n    }\n    return (0, bytes_1.hexConcat)([\"0x01\", RLP.encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    (0, properties_1.checkProperties)(transaction, allowedTransactionKeys);\n    var raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        var value = transaction[fieldInfo.name] || ([]);\n        var options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = (0, bytes_1.arrayify)((0, bytes_1.hexlify)(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = (0, bytes_1.stripZeros)(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push((0, bytes_1.hexlify)(value));\n    });\n    var chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !(0, bytes_1.isBytesLike)(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push((0, bytes_1.hexlify)(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    var sig = (0, bytes_1.splitSignature)(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    var v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push((0, bytes_1.hexlify)(v));\n    raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.r)));\n    raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.s)));\n    return RLP.encode(raw);\n}\nfunction serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return logger.throwError(\"unsupported transaction type: \" + transaction.type, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nexports.serialize = serialize;\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        var recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    }\n    catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = (0, bytes_1.hexZeroPad)(fields[1], 32);\n    tx.s = (0, bytes_1.hexZeroPad)(fields[2], 32);\n    try {\n        var digest = (0, keccak256_1.keccak256)(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    }\n    catch (error) {\n        console.log(error);\n    }\n}\nfunction _parseEip1559(payload) {\n    var transaction = RLP.decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", (0, bytes_1.hexlify)(payload));\n    }\n    var maxPriorityFeePerGas = handleNumber(transaction[2]);\n    var maxFeePerGas = handleNumber(transaction[3]);\n    var tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8]),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = (0, keccak256_1.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    var transaction = RLP.decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", (0, bytes_1.hexlify)(payload));\n    }\n    var tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = (0, keccak256_1.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    var transaction = RLP.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    var tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = bignumber_1.BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        console.log(error);\n        return tx;\n    }\n    tx.r = (0, bytes_1.hexZeroPad)(transaction[7], 32);\n    tx.s = (0, bytes_1.hexZeroPad)(transaction[8], 32);\n    if (bignumber_1.BigNumber.from(tx.r).isZero() && bignumber_1.BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        var recoveryParam = tx.v - 27;\n        var raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push((0, bytes_1.hexlify)(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        var digest = (0, keccak256_1.keccak256)(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: (0, bytes_1.hexlify)(tx.r), s: (0, bytes_1.hexlify)(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) {\n            console.log(error);\n        }\n        tx.hash = (0, keccak256_1.keccak256)(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nfunction parse(rawTransaction) {\n    var payload = (0, bytes_1.arrayify)(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return logger.throwError(\"unsupported transaction type: \" + payload[0], logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\nexports.parse = parse;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGlCQUFpQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QjtBQUN0SSxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBd0I7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsZ0hBQTBCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsZ0hBQTBCO0FBQ3BELGtCQUFrQixtQkFBTyxDQUFDLGdIQUEwQjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQsdUJBQXVCLG1CQUFPLENBQUMsb0dBQW9CO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLG9IQUE0QjtBQUN4RCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHdHQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSxnREFBZ0Q7QUFDdEQsTUFBTSxnREFBZ0Q7QUFDdEQsTUFBTSx3QkFBd0I7QUFDOUIsTUFBTSw2Q0FBNkM7QUFDbkQsTUFBTSxjQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0EsS0FBSztBQUNMLGtDQUFrQyw4Q0FBOEM7QUFDaEY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFEQUFxRCx3Q0FBd0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0RkFBNEY7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIvaW5kZXguanM/YTk3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZSA9IGV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5hY2Nlc3NMaXN0aWZ5ID0gZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBleHBvcnRzLlRyYW5zYWN0aW9uVHlwZXMgPSB2b2lkIDA7XG52YXIgYWRkcmVzc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIik7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCIpO1xudmFyIGtlY2NhazI1Nl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBSTFAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3JscFwiKSk7XG52YXIgc2lnbmluZ19rZXlfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleVwiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBUcmFuc2FjdGlvblR5cGVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblR5cGVzKSB7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wibGVnYWN5XCJdID0gMF0gPSBcImxlZ2FjeVwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDI5MzBcIl0gPSAxXSA9IFwiZWlwMjkzMFwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDE1NTlcIl0gPSAyXSA9IFwiZWlwMTU1OVwiO1xufSkoVHJhbnNhY3Rpb25UeXBlcyA9IGV4cG9ydHMuVHJhbnNhY3Rpb25UeXBlcyB8fCAoZXhwb3J0cy5UcmFuc2FjdGlvblR5cGVzID0ge30pKTtcbjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBhZGRyZXNzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50c18xLlplcm87XG4gICAgfVxuICAgIHJldHVybiBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG59XG4vLyBMZWdhY3kgVHJhbnNhY3Rpb24gRmllbGRzXG52YXIgdHJhbnNhY3Rpb25GaWVsZHMgPSBbXG4gICAgeyBuYW1lOiBcIm5vbmNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwiZ2FzUHJpY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJnYXNMaW1pdFwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcInRvXCIsIGxlbmd0aDogMjAgfSxcbiAgICB7IG5hbWU6IFwidmFsdWVcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJkYXRhXCIgfSxcbl07XG52YXIgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcbiAgICBjaGFpbklkOiB0cnVlLCBkYXRhOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB0bzogdHJ1ZSwgdHlwZTogdHJ1ZSwgdmFsdWU6IHRydWVcbn07XG5mdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICB2YXIgcHVibGljS2V5ID0gKDAsIHNpZ25pbmdfa2V5XzEuY29tcHV0ZVB1YmxpY0tleSkoa2V5KTtcbiAgICByZXR1cm4gKDAsIGFkZHJlc3NfMS5nZXRBZGRyZXNzKSgoMCwgYnl0ZXNfMS5oZXhEYXRhU2xpY2UpKCgwLCBrZWNjYWsyNTZfMS5rZWNjYWsyNTYpKCgwLCBieXRlc18xLmhleERhdGFTbGljZSkocHVibGljS2V5LCAxKSksIDEyKSk7XG59XG5leHBvcnRzLmNvbXB1dGVBZGRyZXNzID0gY29tcHV0ZUFkZHJlc3M7XG5mdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBjb21wdXRlQWRkcmVzcygoMCwgc2lnbmluZ19rZXlfMS5yZWNvdmVyUHVibGljS2V5KSgoMCwgYnl0ZXNfMS5hcnJheWlmeSkoZGlnZXN0KSwgc2lnbmF0dXJlKSk7XG59XG5leHBvcnRzLnJlY292ZXJBZGRyZXNzID0gcmVjb3ZlckFkZHJlc3M7XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gKDAsIGJ5dGVzXzEuc3RyaXBaZXJvcykoYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCkpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIG5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgbmFtZSksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6ICgwLCBhZGRyZXNzXzEuZ2V0QWRkcmVzcykoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiAoc3RvcmFnZUtleXMgfHwgW10pLm1hcChmdW5jdGlvbiAoc3RvcmFnZUtleSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICgoMCwgYnl0ZXNfMS5oZXhEYXRhTGVuZ3RoKShzdG9yYWdlS2V5KSAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhY2Nlc3MgbGlzdCBzdG9yYWdlS2V5XCIsIFwiYWNjZXNzTGlzdFtcIiArIGFkZHIgKyBcIjpcIiArIGluZGV4ICsgXCJdXCIsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChzZXQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhY2Nlc3MgbGlzdCBleHBlY3RlZCB0byBiZSBbIGFkZHJlc3MsIHN0b3JhZ2VLZXlzW10gXVwiLCBcInZhbHVlW1wiICsgaW5kZXggKyBcIl1cIiwgc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sIHNldFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoZnVuY3Rpb24gKGFkZHIpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgc3RvcmFnZUtleSkge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYWNjZXNzTGlzdGlmeSA9IGFjY2Vzc0xpc3RpZnk7XG5mdW5jdGlvbiBmb3JtYXRBY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpLm1hcChmdW5jdGlvbiAoc2V0KSB7IHJldHVybiBbc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5c107IH0pO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDE1NTkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4cGxpY2l0IGdhc1ByaWNlLCBtYWtlIHN1cmUgaXQgbWF0Y2hlcyB0aGVcbiAgICAvLyBFSVAtMTU1OSBmZWVzOyBvdGhlcndpc2UgdGhleSBtYXkgbm90IHVuZGVyc3RhbmQgd2hhdCB0aGV5XG4gICAgLy8gdGhpbmsgdGhleSBhcmUgc2V0dGluZyBpbiB0ZXJtcyBvZiBmZWUuXG4gICAgaWYgKHRyYW5zYWN0aW9uLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGdhc1ByaWNlID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24uZ2FzUHJpY2UpO1xuICAgICAgICB2YXIgbWF4RmVlUGVyR2FzID0gYmlnbnVtYmVyXzEuQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDApO1xuICAgICAgICBpZiAoIWdhc1ByaWNlLmVxKG1heEZlZVBlckdhcykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNtYXRjaCBFSVAtMTU1OSBnYXNQcmljZSAhPSBtYXhGZWVQZXJHYXNcIiwgXCJ0eFwiLCB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkgPyAoMCwgYWRkcmVzc18xLmdldEFkZHJlc3MpKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIHNpZyA9ICgwLCBieXRlc18xLnNwbGl0U2lnbmF0dXJlKShzaWduYXR1cmUpO1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnJlY292ZXJ5UGFyYW0sIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKCgwLCBieXRlc18xLnN0cmlwWmVyb3MpKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKCgwLCBieXRlc18xLnN0cmlwWmVyb3MpKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhDb25jYXQpKFtcIjB4MDJcIiwgUkxQLmVuY29kZShmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgdmFyIGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gKDAsIGFkZHJlc3NfMS5nZXRBZGRyZXNzKSh0cmFuc2FjdGlvbi50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBzaWcgPSAoMCwgYnl0ZXNfMS5zcGxpdFNpZ25hdHVyZSkoc2lnbmF0dXJlKTtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgYnl0ZXNfMS5zdHJpcFplcm9zKShzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgYnl0ZXNfMS5zdHJpcFplcm9zKShzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuaGV4Q29uY2F0KShbXCIweDAxXCIsIFJMUC5lbmNvZGUoZmllbGRzKV0pO1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9ucyBhbmQgRUlQLTE1NVxuZnVuY3Rpb24gX3NlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgKDAsIHByb3BlcnRpZXNfMS5jaGVja1Byb3BlcnRpZXMpKHRyYW5zYWN0aW9uLCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzKTtcbiAgICB2YXIgcmF3ID0gW107XG4gICAgdHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zYWN0aW9uW2ZpZWxkSW5mby5uYW1lXSB8fCAoW10pO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoZmllbGRJbmZvLm51bWVyaWMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGV4UGFkID0gXCJsZWZ0XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSAoMCwgYnl0ZXNfMS5hcnJheWlmeSkoKDAsIGJ5dGVzXzEuaGV4bGlmeSkodmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgLy8gRml4ZWQtd2lkdGggZmllbGRcbiAgICAgICAgaWYgKGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSBmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZS13aWR0aCAod2l0aCBhIG1heGltdW0pXG4gICAgICAgIGlmIChmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCBieXRlc18xLnN0cmlwWmVyb3MpKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJhdy5wdXNoKCgwLCBieXRlc18xLmhleGxpZnkpKHZhbHVlKSk7XG4gICAgfSk7XG4gICAgdmFyIGNoYWluSWQgPSAwO1xuICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbi5jaGFpbklkXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpZ25hdHVyZSAmJiAhKDAsIGJ5dGVzXzEuaXNCeXRlc0xpa2UpKHNpZ25hdHVyZSkgJiYgc2lnbmF0dXJlLnYgPiAyOCkge1xuICAgICAgICAvLyBObyBjaGFpbklkIHByb3ZpZGVkLCBidXQgdGhlIHNpZ25hdHVyZSBpcyBzaWduaW5nIHdpdGggRUlQLTE1NTsgZGVyaXZlIGNoYWluSWRcbiAgICAgICAgY2hhaW5JZCA9IE1hdGguZmxvb3IoKHNpZ25hdHVyZS52IC0gMzUpIC8gMik7XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICByYXcucHVzaCgoMCwgYnl0ZXNfMS5oZXhsaWZ5KShjaGFpbklkKSk7IC8vIEBUT0RPOiBoZXhWYWx1ZT9cbiAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICB9XG4gICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG4gICAgfVxuICAgIC8vIFRoZSBzcGxpdFNpZ25hdHVyZSB3aWxsIGVuc3VyZSB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgcmVjb3ZlcnlQYXJhbSBpbiB0aGVcbiAgICAvLyBjYXNlIHRoYXQgdGhlIHNpZ25UcmFuc2FjdGlvbiBmdW5jdGlvbiBvbmx5IGFkZHMgYSB2LlxuICAgIHZhciBzaWcgPSAoMCwgYnl0ZXNfMS5zcGxpdFNpZ25hdHVyZSkoc2lnbmF0dXJlKTtcbiAgICAvLyBXZSBwdXNoZWQgYSBjaGFpbklkIGFuZCBudWxsIHIsIHMgb24gZm9yIGhhc2hpbmcgb25seTsgcmVtb3ZlIHRob3NlXG4gICAgdmFyIHYgPSAyNyArIHNpZy5yZWNvdmVyeVBhcmFtO1xuICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHYgKz0gY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICAvLyBJZiBhbiBFSVAtMTU1IHYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHk7IG1heWJlIF92cykgd2FzIHByb3ZpZGVkLCBjaGVjayBpdCFcbiAgICAgICAgaWYgKHNpZy52ID4gMjggJiYgc2lnLnYgIT09IHYpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lnLnYgIT09IHYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgcmF3LnB1c2goKDAsIGJ5dGVzXzEuaGV4bGlmeSkodikpO1xuICAgIHJhdy5wdXNoKCgwLCBieXRlc18xLnN0cmlwWmVyb3MpKCgwLCBieXRlc18xLmFycmF5aWZ5KShzaWcucikpKTtcbiAgICByYXcucHVzaCgoMCwgYnl0ZXNfMS5zdHJpcFplcm9zKSgoMCwgYnl0ZXNfMS5hcnJheWlmeSkoc2lnLnMpKSk7XG4gICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgLy8gTGVnYWN5IGFuZCBFSVAtMTU1IFRyYW5zYWN0aW9uc1xuICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09IG51bGwgfHwgdHJhbnNhY3Rpb24udHlwZSA9PT0gMCkge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW50eXBlZCB0cmFuc2FjdGlvbnMgZG8gbm90IHN1cHBvcnQgYWNjZXNzTGlzdDsgaW5jbHVkZSB0eXBlOiAxXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgIH1cbiAgICAvLyBUeXBlZCBUcmFuc2FjdGlvbnMgKEVJUC0yNzE4KVxuICAgIHN3aXRjaCAodHJhbnNhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiBcIiArIHRyYW5zYWN0aW9uLnR5cGUsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJzZXJpYWxpemVUcmFuc2FjdGlvblwiLFxuICAgICAgICB0cmFuc2FjdGlvblR5cGU6IHRyYW5zYWN0aW9uLnR5cGVcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZnVuY3Rpb24gX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMsIHNlcmlhbGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciByZWNpZCA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0pLnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChyZWNpZCAhPT0gMCAmJiByZWNpZCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlY2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR4LnYgPSByZWNpZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHYgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJ2XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIHR4LnIgPSAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKShmaWVsZHNbMV0sIDMyKTtcbiAgICB0eC5zID0gKDAsIGJ5dGVzXzEuaGV4WmVyb1BhZCkoZmllbGRzWzJdLCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGRpZ2VzdCA9ICgwLCBrZWNjYWsyNTZfMS5rZWNjYWsyNTYpKHNlcmlhbGl6ZSh0eCkpO1xuICAgICAgICB0eC5mcm9tID0gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCB7IHI6IHR4LnIsIHM6IHR4LnMsIHJlY292ZXJ5UGFyYW06IHR4LnYgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShwYXlsb2FkKSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShwYXlsb2FkLnNsaWNlKDEpKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA5ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gMTIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29tcG9uZW50IGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAyXCIsIFwicGF5bG9hZFwiLCAoMCwgYnl0ZXNfMS5oZXhsaWZ5KShwYXlsb2FkKSk7XG4gICAgfVxuICAgIHZhciBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSk7XG4gICAgdmFyIG1heEZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblszXSk7XG4gICAgdmFyIHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMV0pLnRvTnVtYmVyKCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMsXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzRdKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzZdKSxcbiAgICAgICAgZGF0YTogdHJhbnNhY3Rpb25bN10sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb25bOF0pLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9ICgwLCBrZWNjYWsyNTZfMS5rZWNjYWsyNTYpKHBheWxvYWQpO1xuICAgIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgdHJhbnNhY3Rpb24uc2xpY2UoOSksIF9zZXJpYWxpemVFaXAxNTU5KTtcbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAyOTMwKHBheWxvYWQpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDggJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJwYXlsb2FkXCIsICgwLCBieXRlc18xLmhleGxpZnkpKHBheWxvYWQpKTtcbiAgICB9XG4gICAgdmFyIHR4ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMV0pLnRvTnVtYmVyKCksXG4gICAgICAgIGdhc1ByaWNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzNdKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bNF0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzVdKSxcbiAgICAgICAgZGF0YTogdHJhbnNhY3Rpb25bNl0sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb25bN10pXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5oYXNoID0gKDAsIGtlY2NhazI1Nl8xLmtlY2NhazI1NikocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg4KSwgX3NlcmlhbGl6ZUVpcDI5MzApO1xuICAgIHJldHVybiB0eDtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9wYXJzZShyYXdUcmFuc2FjdGlvbikge1xuICAgIHZhciB0cmFuc2FjdGlvbiA9IFJMUC5kZWNvZGUocmF3VHJhbnNhY3Rpb24pO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJhdyB0cmFuc2FjdGlvblwiLCBcInJhd1RyYW5zYWN0aW9uXCIsIHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgdmFyIHR4ID0ge1xuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzNdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzVdLFxuICAgICAgICBjaGFpbklkOiAwXG4gICAgfTtcbiAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdHgudiA9IGJpZ251bWJlcl8xLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uWzZdKS50b051bWJlcigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4LnIgPSAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKSh0cmFuc2FjdGlvbls3XSwgMzIpO1xuICAgIHR4LnMgPSAoMCwgYnl0ZXNfMS5oZXhaZXJvUGFkKSh0cmFuc2FjdGlvbls4XSwgMzIpO1xuICAgIGlmIChiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSAmJiBiaWdudW1iZXJfMS5CaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB0eC52O1xuICAgICAgICB0eC52ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNpZ25lZCBUcmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuICAgICAgICBpZiAodHguY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgIHR4LmNoYWluSWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWNvdmVyeVBhcmFtID0gdHgudiAtIDI3O1xuICAgICAgICB2YXIgcmF3ID0gdHJhbnNhY3Rpb24uc2xpY2UoMCwgNik7XG4gICAgICAgIGlmICh0eC5jaGFpbklkICE9PSAwKSB7XG4gICAgICAgICAgICByYXcucHVzaCgoMCwgYnl0ZXNfMS5oZXhsaWZ5KSh0eC5jaGFpbklkKSk7XG4gICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIHJlY292ZXJ5UGFyYW0gLT0gdHguY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWdlc3QgPSAoMCwga2VjY2FrMjU2XzEua2VjY2FrMjU2KShSTFAuZW5jb2RlKHJhdykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KSh0eC5yKSwgczogKDAsIGJ5dGVzXzEuaGV4bGlmeSkodHgucyksIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHguaGFzaCA9ICgwLCBrZWNjYWsyNTZfMS5rZWNjYWsyNTYpKHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgdHgudHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gcGFyc2UocmF3VHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcGF5bG9hZCA9ICgwLCBieXRlc18xLmFycmF5aWZ5KShyYXdUcmFuc2FjdGlvbik7XG4gICAgLy8gTGVnYWN5IGFuZCBFSVAtMTU1IFRyYW5zYWN0aW9uc1xuICAgIGlmIChwYXlsb2FkWzBdID4gMHg3Zikge1xuICAgICAgICByZXR1cm4gX3BhcnNlKHBheWxvYWQpO1xuICAgIH1cbiAgICAvLyBUeXBlZCBUcmFuc2FjdGlvbiAoRUlQLTI3MTgpXG4gICAgc3dpdGNoIChwYXlsb2FkWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBfcGFyc2VFaXAyOTMwKHBheWxvYWQpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3BhcnNlRWlwMTU1OShwYXlsb2FkKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiBcIiArIHBheWxvYWRbMF0sIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJwYXJzZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogcGF5bG9hZFswXVxuICAgIH0pO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/transactions/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/_version.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/web/lib/_version.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = \"web/5.5.1\";\n//# sourceMappingURL=_version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi9fdmVyc2lvbi5qcz85OGJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gXCJ3ZWIvNS41LjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/geturl.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/web/lib/geturl.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUrl = void 0;\nvar http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\nvar https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nvar zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nvar url_1 = __webpack_require__(/*! url */ \"url\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nfunction getResponse(request) {\n    return new Promise(function (resolve, reject) {\n        request.once(\"response\", function (resp) {\n            var response = {\n                statusCode: resp.statusCode,\n                statusMessage: resp.statusMessage,\n                headers: Object.keys(resp.headers).reduce(function (accum, name) {\n                    var value = resp.headers[name];\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {}),\n                body: null\n            };\n            //resp.setEncoding(\"utf8\");\n            resp.on(\"data\", function (chunk) {\n                if (response.body == null) {\n                    response.body = new Uint8Array(0);\n                }\n                response.body = (0, bytes_1.concat)([response.body, chunk]);\n            });\n            resp.on(\"end\", function () {\n                if (response.headers[\"content-encoding\"] === \"gzip\") {\n                    //const size = response.body.length;\n                    response.body = (0, bytes_1.arrayify)((0, zlib_1.gunzipSync)(response.body));\n                    //console.log(\"Delta:\", response.body.length - size, Buffer.from(response.body).toString());\n                }\n                resolve(response);\n            });\n            resp.on(\"error\", function (error) {\n                /* istanbul ignore next */\n                error.response = response;\n                reject(error);\n            });\n        });\n        request.on(\"error\", function (error) { reject(error); });\n    });\n}\n// The URL.parse uses null instead of the empty string\nfunction nonnull(value) {\n    if (value == null) {\n        return \"\";\n    }\n    return value;\n}\nfunction getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function () {\n        var url, request, req, response;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (options == null) {\n                        options = {};\n                    }\n                    url = (0, url_1.parse)(href);\n                    request = {\n                        protocol: nonnull(url.protocol),\n                        hostname: nonnull(url.hostname),\n                        port: nonnull(url.port),\n                        path: (nonnull(url.pathname) + nonnull(url.search)),\n                        method: (options.method || \"GET\"),\n                        headers: (0, properties_1.shallowCopy)(options.headers || {}),\n                    };\n                    if (options.allowGzip) {\n                        request.headers[\"accept-encoding\"] = \"gzip\";\n                    }\n                    req = null;\n                    switch (nonnull(url.protocol)) {\n                        case \"http:\":\n                            req = http_1.default.request(request);\n                            break;\n                        case \"https:\":\n                            req = https_1.default.request(request);\n                            break;\n                        default:\n                            /* istanbul ignore next */\n                            logger.throwError(\"unsupported protocol \" + url.protocol, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {\n                                protocol: url.protocol,\n                                operation: \"request\"\n                            });\n                    }\n                    if (options.body) {\n                        req.write(Buffer.from(options.body));\n                    }\n                    req.end();\n                    return [4 /*yield*/, getResponse(req)];\n                case 1:\n                    response = _a.sent();\n                    return [2 /*return*/, response];\n            }\n        });\n    });\n}\nexports.getUrl = getUrl;\n//# sourceMappingURL=geturl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliL2dldHVybC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsNkJBQTZCLG1CQUFPLENBQUMsa0JBQU07QUFDM0MsOEJBQThCLG1CQUFPLENBQUMsb0JBQU87QUFDN0MsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixjQUFjLG1CQUFPLENBQUMsd0dBQXNCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLGtIQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsMEdBQXVCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLCtGQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCwrQ0FBK0MsZ0JBQWdCO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi9nZXR1cmwuanM/MGQ0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFVybCA9IHZvaWQgMDtcbnZhciBodHRwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh0dHBcIikpO1xudmFyIGh0dHBzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh0dHBzXCIpKTtcbnZhciB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbnZhciB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbmZ1bmN0aW9uIGdldFJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXF1ZXN0Lm9uY2UoXCJyZXNwb25zZVwiLCBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3Auc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiByZXNwLnN0YXR1c01lc3NhZ2UsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmtleXMocmVzcC5oZWFkZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3AuaGVhZGVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgIGJvZHk6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL3Jlc3Auc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgcmVzcC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSAoMCwgYnl0ZXNfMS5jb25jYXQpKFtyZXNwb25zZS5ib2R5LCBjaHVua10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtZW5jb2RpbmdcIl0gPT09IFwiZ3ppcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3Qgc2l6ZSA9IHJlc3BvbnNlLmJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gKDAsIGJ5dGVzXzEuYXJyYXlpZnkpKCgwLCB6bGliXzEuZ3VuemlwU3luYykocmVzcG9uc2UuYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRGVsdGE6XCIsIHJlc3BvbnNlLmJvZHkubGVuZ3RoIC0gc2l6ZSwgQnVmZmVyLmZyb20ocmVzcG9uc2UuYm9keSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgfSk7XG4gICAgfSk7XG59XG4vLyBUaGUgVVJMLnBhcnNlIHVzZXMgbnVsbCBpbnN0ZWFkIG9mIHRoZSBlbXB0eSBzdHJpbmdcbmZ1bmN0aW9uIG5vbm51bGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VXJsKGhyZWYsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cmwsIHJlcXVlc3QsIHJlcSwgcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgdXJsXzEucGFyc2UpKGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IG5vbm51bGwodXJsLnByb3RvY29sKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lOiBub25udWxsKHVybC5ob3N0bmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBub25udWxsKHVybC5wb3J0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IChub25udWxsKHVybC5wYXRobmFtZSkgKyBub25udWxsKHVybC5zZWFyY2gpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkob3B0aW9ucy5oZWFkZXJzIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImd6aXBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vbm51bGwodXJsLnByb3RvY29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHA6XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gaHR0cF8xLmRlZmF1bHQucmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEgPSBodHRwc18xLmRlZmF1bHQucmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHByb3RvY29sIFwiICsgdXJsLnByb3RvY29sLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogdXJsLnByb3RvY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLndyaXRlKEJ1ZmZlci5mcm9tKG9wdGlvbnMuYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0UmVzcG9uc2UocmVxKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFVybCA9IGdldFVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/geturl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.poll = exports.fetchJson = exports._fetchData = void 0;\nvar base64_1 = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/base64/lib/index.js\");\nvar bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/bytes/lib/index.js\");\nvar properties_1 = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/properties/lib/index.js\");\nvar strings_1 = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/strings/lib/index.js\");\nvar logger_1 = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/logger/lib/index.js\");\nvar _version_1 = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/_version.js\");\nvar logger = new logger_1.Logger(_version_1.version);\nvar geturl_1 = __webpack_require__(/*! ./geturl */ \"(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/geturl.js\");\nfunction staller(duration) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value) === \"string\") {\n        return value;\n    }\n    if ((0, bytes_1.isBytesLike)(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return (0, strings_1.toUtf8String)(value);\n            }\n            catch (error) { }\n            ;\n        }\n        return (0, bytes_1.hexlify)(value);\n    }\n    return value;\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    var attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    var throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n    var throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    var headers = {};\n    var url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    var options = {\n        method: \"GET\",\n    };\n    var allow304 = false;\n    var timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (var key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            var authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + (0, base64_1.encode)((0, strings_1.toUtf8Bytes)(authorization))\n            };\n        }\n    }\n    var reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    var dataMatch = ((url) ? url.match(reData) : null);\n    if (dataMatch) {\n        try {\n            var response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: (0, base64_1.decode)(dataMatch[2])\n            };\n            var result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            logger.throwError(\"processing response error\", logger_1.Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n    var flatHeaders = {};\n    Object.keys(headers).forEach(function (key) {\n        var header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    var runningTimeout = (function () {\n        var timer = null;\n        var promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(function () {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", logger_1.Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        var cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise: promise, cancel: cancel };\n    })();\n    var runningFetch = (function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var attempt, response, location_1, tryAgain, stall, retryAfter, error_1, body_1, result, error_2, tryAgain, timeout_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        attempt = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(attempt < attemptLimit)) return [3 /*break*/, 20];\n                        response = null;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 9, , 10]);\n                        return [4 /*yield*/, (0, geturl_1.getUrl)(url, options)];\n                    case 3:\n                        response = _a.sent();\n                        if (!(attempt < attemptLimit)) return [3 /*break*/, 8];\n                        if (!(response.statusCode === 301 || response.statusCode === 302)) return [3 /*break*/, 4];\n                        location_1 = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location_1.match(/^https:/)) {\n                            url = response.headers.location;\n                            return [3 /*break*/, 19];\n                        }\n                        return [3 /*break*/, 8];\n                    case 4:\n                        if (!(response.statusCode === 429)) return [3 /*break*/, 8];\n                        tryAgain = true;\n                        if (!throttleCallback) return [3 /*break*/, 6];\n                        return [4 /*yield*/, throttleCallback(attempt, url)];\n                    case 5:\n                        tryAgain = _a.sent();\n                        _a.label = 6;\n                    case 6:\n                        if (!tryAgain) return [3 /*break*/, 8];\n                        stall = 0;\n                        retryAfter = response.headers[\"retry-after\"];\n                        if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                            stall = parseInt(retryAfter) * 1000;\n                        }\n                        else {\n                            stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                        }\n                        //console.log(\"Stalling 429\");\n                        return [4 /*yield*/, staller(stall)];\n                    case 7:\n                        //console.log(\"Stalling 429\");\n                        _a.sent();\n                        return [3 /*break*/, 19];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        error_1 = _a.sent();\n                        response = error_1.response;\n                        if (response == null) {\n                            runningTimeout.cancel();\n                            logger.throwError(\"missing response\", logger_1.Logger.errors.SERVER_ERROR, {\n                                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                                requestMethod: options.method,\n                                serverError: error_1,\n                                url: url\n                            });\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        body_1 = response.body;\n                        if (allow304 && response.statusCode === 304) {\n                            body_1 = null;\n                        }\n                        else if (response.statusCode < 200 || response.statusCode >= 300) {\n                            runningTimeout.cancel();\n                            logger.throwError(\"bad response\", logger_1.Logger.errors.SERVER_ERROR, {\n                                status: response.statusCode,\n                                headers: response.headers,\n                                body: bodyify(body_1, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                                requestMethod: options.method,\n                                url: url\n                            });\n                        }\n                        if (!processFunc) return [3 /*break*/, 18];\n                        _a.label = 11;\n                    case 11:\n                        _a.trys.push([11, 13, , 18]);\n                        return [4 /*yield*/, processFunc(body_1, response)];\n                    case 12:\n                        result = _a.sent();\n                        runningTimeout.cancel();\n                        return [2 /*return*/, result];\n                    case 13:\n                        error_2 = _a.sent();\n                        if (!(error_2.throttleRetry && attempt < attemptLimit)) return [3 /*break*/, 17];\n                        tryAgain = true;\n                        if (!throttleCallback) return [3 /*break*/, 15];\n                        return [4 /*yield*/, throttleCallback(attempt, url)];\n                    case 14:\n                        tryAgain = _a.sent();\n                        _a.label = 15;\n                    case 15:\n                        if (!tryAgain) return [3 /*break*/, 17];\n                        timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                        //console.log(\"Stalling callback\");\n                        return [4 /*yield*/, staller(timeout_1)];\n                    case 16:\n                        //console.log(\"Stalling callback\");\n                        _a.sent();\n                        return [3 /*break*/, 19];\n                    case 17:\n                        runningTimeout.cancel();\n                        logger.throwError(\"processing response error\", logger_1.Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body_1, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                            error: error_2,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                        return [3 /*break*/, 18];\n                    case 18:\n                        runningTimeout.cancel();\n                        // If we had a processFunc, it either returned a T or threw above.\n                        // The \"body\" is now a Uint8Array.\n                        return [2 /*return*/, body_1];\n                    case 19:\n                        attempt++;\n                        return [3 /*break*/, 1];\n                    case 20: return [2 /*return*/, logger.throwError(\"failed response\", logger_1.Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        })];\n                }\n            });\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nexports._fetchData = _fetchData;\nfunction fetchJson(connection, json, processFunc) {\n    var processJsonFunc = function (value, response) {\n        var result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse((0, strings_1.toUtf8String)(value));\n            }\n            catch (error) {\n                logger.throwError(\"invalid JSON\", logger_1.Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    var body = null;\n    if (json != null) {\n        body = (0, strings_1.toUtf8Bytes)(json);\n        // Create a connection with the content-type set for JSON\n        var updated = (typeof (connection) === \"string\") ? ({ url: connection }) : (0, properties_1.shallowCopy)(connection);\n        if (updated.headers) {\n            var hasContentType = (Object.keys(updated.headers).filter(function (k) { return (k.toLowerCase() === \"content-type\"); }).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = (0, properties_1.shallowCopy)(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        }\n        else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nexports.fetchJson = fetchJson;\nfunction poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = (0, properties_1.shallowCopy)(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        var timer = null;\n        var done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        var cancel = function () {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(function () {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        var retryLimit = options.retryLimit;\n        var attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\nexports.poll = poll;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLHdHQUFzQjtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyxrSEFBMkI7QUFDdEQsZ0JBQWdCLG1CQUFPLENBQUMsNEdBQXdCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQywwR0FBdUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsK0ZBQVk7QUFDckM7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkZBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJLDBFQUEwRTtBQUMzTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0EscUZBQXFGLDhDQUE4QztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIvaW5kZXguanM/OWIzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvbGwgPSBleHBvcnRzLmZldGNoSnNvbiA9IGV4cG9ydHMuX2ZldGNoRGF0YSA9IHZvaWQgMDtcbnZhciBiYXNlNjRfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIik7XG52YXIgYnl0ZXNfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiKTtcbnZhciBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiKTtcbnZhciBzdHJpbmdzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIik7XG52YXIgX3ZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uXCIpO1xudmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoX3ZlcnNpb25fMS52ZXJzaW9uKTtcbnZhciBnZXR1cmxfMSA9IHJlcXVpcmUoXCIuL2dldHVybFwiKTtcbmZ1bmN0aW9uIHN0YWxsZXIoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBib2R5aWZ5KHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICgoMCwgYnl0ZXNfMS5pc0J5dGVzTGlrZSkodmFsdWUpKSB7XG4gICAgICAgIGlmICh0eXBlICYmICh0eXBlLnNwbGl0KFwiL1wiKVswXSA9PT0gXCJ0ZXh0XCIgfHwgdHlwZS5zcGxpdChcIjtcIilbMF0udHJpbSgpID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBzdHJpbmdzXzEudG9VdGY4U3RyaW5nKSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5oZXhsaWZ5KSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIFRoaXMgQVBJIGlzIHN0aWxsIGEgd29yayBpbiBwcm9ncmVzczsgdGhlIGZ1dHVyZSBjaGFuZ2VzIHdpbGwgbGlrZWx5IGJlOlxuLy8gLSBDb25uZWN0aW9uSW5mbyA9PiBGZXRjaERhdGFSZXF1ZXN0PFQgPSBhbnk+XG4vLyAtIEZldGNoRGF0YVJlcXVlc3QuYm9keT8gPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgeyBjb250ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5IH1cbi8vICAgLSBJZiBzdHJpbmcgPT4gdGV4dC9wbGFpbiwgVWludDhBcnJheSA9PiBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0gKGlmIGNvbnRlbnQtdHlwZSB1bnNwZWNpZmllZClcbi8vIC0gRmV0Y2hEYXRhUmVxdWVzdC5wcm9jZXNzRnVuYyA9IChib2R5OiBVaW50OEFycmF5LCByZXNwb25zZTogRmV0Y2hEYXRhUmVzcG9uc2UpID0+IFRcbi8vIEZvciB0aGlzIHJlYXNvbiwgaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW50ZXJuYWwgdW50aWwgdGhlIEFQSSBpcyBmaW5hbGl6ZWRcbmZ1bmN0aW9uIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAvLyBIb3cgbWFueSB0aW1lcyB0byByZXRyeSBpbiB0aGUgZXZlbnQgb2YgYSB0aHJvdHRsZVxuICAgIHZhciBhdHRlbXB0TGltaXQgPSAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgIT0gbnVsbCkgPyBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgOiAxMjtcbiAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKGF0dGVtcHRMaW1pdCA+IDAgJiYgKGF0dGVtcHRMaW1pdCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgbGltaXRcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlTGltaXRcIiwgYXR0ZW1wdExpbWl0KTtcbiAgICB2YXIgdGhyb3R0bGVDYWxsYmFjayA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikgPyBjb25uZWN0aW9uLnRocm90dGxlQ2FsbGJhY2sgOiBudWxsKTtcbiAgICB2YXIgdGhyb3R0bGVTbG90SW50ZXJ2YWwgPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIChjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsKSA9PT0gXCJudW1iZXJcIikgPyBjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsIDogMTAwKTtcbiAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHRocm90dGxlU2xvdEludGVydmFsID4gMCAmJiAodGhyb3R0bGVTbG90SW50ZXJ2YWwgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIHNsb3QgaW50ZXJ2YWxcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsXCIsIHRocm90dGxlU2xvdEludGVydmFsKTtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIHZhciB1cmwgPSBudWxsO1xuICAgIC8vIEBUT0RPOiBBbGxvdyBDb25uZWN0aW9uSW5mbyB0byBvdmVycmlkZSBzb21lIG9mIHRoZXNlIHZhbHVlc1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgfTtcbiAgICB2YXIgYWxsb3czMDQgPSBmYWxzZTtcbiAgICB2YXIgdGltZW91dCA9IDIgKiA2MCAqIDEwMDA7XG4gICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJsID0gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsIHx8IGNvbm5lY3Rpb24udXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIFVSTFwiLCBcImNvbm5lY3Rpb24udXJsXCIsIGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGNvbm5lY3Rpb24udXJsO1xuICAgICAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uLnRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIGNvbm5lY3Rpb24udGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBjb25uZWN0aW9uLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uaGVhZGVycykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbm5lY3Rpb24uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0geyBrZXk6IGtleSwgdmFsdWU6IFN0cmluZyhjb25uZWN0aW9uLmhlYWRlcnNba2V5XSkgfTtcbiAgICAgICAgICAgICAgICBpZiAoW1wiaWYtbm9uZS1tYXRjaFwiLCBcImlmLW1vZGlmaWVkLXNpbmNlXCJdLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3czMDQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmFsbG93R3ppcCA9ICEhY29ubmVjdGlvbi5hbGxvd0d6aXA7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnVzZXIgIT0gbnVsbCAmJiBjb25uZWN0aW9uLnBhc3N3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsIDYpICE9PSBcImh0dHBzOlwiICYmIGNvbm5lY3Rpb24uYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInVybFwiLCB1cmw6IHVybCwgdXNlcjogY29ubmVjdGlvbi51c2VyLCBwYXNzd29yZDogXCJbUkVEQUNURURdXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXV0aG9yaXphdGlvbiA9IGNvbm5lY3Rpb24udXNlciArIFwiOlwiICsgY29ubmVjdGlvbi5wYXNzd29yZDtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0ge1xuICAgICAgICAgICAgICAgIGtleTogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiQmFzaWMgXCIgKyAoMCwgYmFzZTY0XzEuZW5jb2RlKSgoMCwgc3RyaW5nc18xLnRvVXRmOEJ5dGVzKShhdXRob3JpemF0aW9uKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlRGF0YSA9IG5ldyBSZWdFeHAoXCJeZGF0YTooW2EtejAtOS1dKy9bYS16MC05LV0rKTtiYXNlNjQsKC4qKSRcIiwgXCJpXCIpO1xuICAgIHZhciBkYXRhTWF0Y2ggPSAoKHVybCkgPyB1cmwubWF0Y2gocmVEYXRhKSA6IG51bGwpO1xuICAgIGlmIChkYXRhTWF0Y2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogXCJPS1wiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogZGF0YU1hdGNoWzFdIH0sXG4gICAgICAgICAgICAgICAgYm9keTogKDAsIGJhc2U2NF8xLmRlY29kZSkoZGF0YU1hdGNoWzJdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShkYXRhTWF0Y2hbMV0sIGRhdGFNYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB7IGtleTogXCJDb250ZW50LVR5cGVcIiwgdmFsdWU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IHsga2V5OiBcIkNvbnRlbnQtTGVuZ3RoXCIsIHZhbHVlOiBTdHJpbmcoYm9keS5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZsYXRIZWFkZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBoZWFkZXJzW2tleV07XG4gICAgICAgIGZsYXRIZWFkZXJzW2hlYWRlci5rZXldID0gaGVhZGVyLnZhbHVlO1xuICAgIH0pO1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IGZsYXRIZWFkZXJzO1xuICAgIHZhciBydW5uaW5nVGltZW91dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0XCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuVElNRU9VVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBwcm9taXNlOiBwcm9taXNlLCBjYW5jZWw6IGNhbmNlbCB9O1xuICAgIH0pKCk7XG4gICAgdmFyIHJ1bm5pbmdGZXRjaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhdHRlbXB0LCByZXNwb25zZSwgbG9jYXRpb25fMSwgdHJ5QWdhaW4sIHN0YWxsLCByZXRyeUFmdGVyLCBlcnJvcl8xLCBib2R5XzEsIHJlc3VsdCwgZXJyb3JfMiwgdHJ5QWdhaW4sIHRpbWVvdXRfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhdHRlbXB0IDwgYXR0ZW1wdExpbWl0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDksICwgMTBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sICgwLCBnZXR1cmxfMS5nZXRVcmwpKHVybCwgb3B0aW9ucyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uXzEgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgJiYgbG9jYXRpb25fMS5tYXRjaCgvXmh0dHBzOi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRocm90dGxlQ2FsbGJhY2spIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJ5QWdhaW4pIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gcGFyc2VJbnQocmV0cnlBZnRlcikgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSB0aHJvdHRsZVNsb3RJbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyA0MjlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFsbGVyKHN0YWxsKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyA0MjlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBlcnJvcl8xLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmVzcG9uc2VcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3JfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlfMSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3czMDQgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keV8xID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXNwb25zZVwiLCBsb2dnZXJfMS5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlpZnkoYm9keV8xLCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzRnVuYykgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMTEsIDEzLCAsIDE4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwcm9jZXNzRnVuYyhib2R5XzEsIHJlc3BvbnNlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGVycm9yXzIudGhyb3R0bGVSZXRyeSAmJiBhdHRlbXB0IDwgYXR0ZW1wdExpbWl0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aHJvdHRsZUNhbGxiYWNrKSByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aHJvdHRsZUNhbGxiYWNrKGF0dGVtcHQsIHVybCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnlBZ2FpbikgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dF8xID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFsbGVyKHRpbWVvdXRfMSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIGNhbGxiYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb2Nlc3NpbmcgcmVzcG9uc2UgZXJyb3JcIiwgbG9nZ2VyXzEuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHlfMSwgKChyZXNwb25zZS5oZWFkZXJzKSA/IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXzIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMThdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYWQgYSBwcm9jZXNzRnVuYywgaXQgZWl0aGVyIHJldHVybmVkIGEgVCBvciB0aHJldyBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImJvZHlcIiBpcyBub3cgYSBVaW50OEFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJvZHlfMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHJlc3BvbnNlXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5uaW5nVGltZW91dC5wcm9taXNlLCBydW5uaW5nRmV0Y2hdKTtcbn1cbmV4cG9ydHMuX2ZldGNoRGF0YSA9IF9mZXRjaERhdGE7XG5mdW5jdGlvbiBmZXRjaEpzb24oY29ubmVjdGlvbiwganNvbiwgcHJvY2Vzc0Z1bmMpIHtcbiAgICB2YXIgcHJvY2Vzc0pzb25GdW5jID0gZnVuY3Rpb24gKHZhbHVlLCByZXNwb25zZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZSgoMCwgc3RyaW5nc18xLnRvVXRmOFN0cmluZykodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBKU09OXCIsIGxvZ2dlcl8xLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGdW5jKHJlc3VsdCwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBJZiB3ZSBoYXZlIGpzb24gdG8gc2VuZCwgd2UgbXVzdFxuICAgIC8vIC0gYWRkIGNvbnRlbnQtdHlwZSBvZiBhcHBsaWNhdGlvbi9qc29uICh1bmxlc3MgYWxyZWFkeSBvdmVycmlkZGVuKVxuICAgIC8vIC0gY29udmVydCB0aGUganNvbiB0byBieXRlc1xuICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICBpZiAoanNvbiAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSAoMCwgc3RyaW5nc18xLnRvVXRmOEJ5dGVzKShqc29uKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBjb250ZW50LXR5cGUgc2V0IGZvciBKU09OXG4gICAgICAgIHZhciB1cGRhdGVkID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwic3RyaW5nXCIpID8gKHsgdXJsOiBjb25uZWN0aW9uIH0pIDogKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkoY29ubmVjdGlvbik7XG4gICAgICAgIGlmICh1cGRhdGVkLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBoYXNDb250ZW50VHlwZSA9IChPYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gKGsudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIik7IH0pLmxlbmd0aCkgIT09IDA7XG4gICAgICAgICAgICBpZiAoIWhhc0NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0gKDAsIHByb3BlcnRpZXNfMS5zaGFsbG93Q29weSkodXBkYXRlZC5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uID0gdXBkYXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0pzb25GdW5jKTtcbn1cbmV4cG9ydHMuZmV0Y2hKc29uID0gZmV0Y2hKc29uO1xuZnVuY3Rpb24gcG9sbChmdW5jLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9ICgwLCBwcm9wZXJ0aWVzXzEuc2hhbGxvd0NvcHkpKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmZsb29yID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5mbG9vciA9IDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNlaWxpbmcgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmNlaWxpbmcgPSAxMDAwMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW50ZXJ2YWwgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmludGVydmFsID0gMjUwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgY2FuY2VsIHdhcyBzdWNjZXNzZnVsLiBVbnN1Y2Nlc3NmdWwgY2FuY2VsIG1lYW5zIHdlJ3JlIGFscmVhZHkgZG9uZS5cbiAgICAgICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXRyeUxpbWl0ID0gb3B0aW9ucy5yZXRyeUxpbWl0O1xuICAgICAgICB2YXIgYXR0ZW1wdCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVzdWx0LCBvciBhcmUgYWxsb3dlZCBudWxsIHRoZW4gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VQb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGV4cG9uZW50aWFsIGJhY2stb2ZmICh1cCB0byAxMHMpIG91ciBuZXh0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IHJldHJ5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXRyeSBsaW1pdCByZWFjaGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IG9wdGlvbnMuaW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgb3B0aW9ucy5mbG9vcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuZmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiBvcHRpb25zLmNlaWxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmNlaWxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucG9sbCA9IHBvbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/@ethersproject/web/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/node_modules/bn.js/lib/bn.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/node_modules/bn.js/lib/bn.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // 'A' - 'F'\n    if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    // '0' - '9'\n    } else {\n      return (c - 48) & 0xf;\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this.strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is BN v4 instance\n        r.strip();\n      } else {\n        // r is BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSxvREFBd0I7QUFDdkM7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQSxtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsK0NBQStDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsTUFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzPzM1YWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoYyAtIDQ4KSAmIDB4ZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/node_modules/bn.js/lib/bn.js\n");

/***/ })

};
;