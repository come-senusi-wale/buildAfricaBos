"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bnc-sdk";
exports.ids = ["vendor-chunks/bnc-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/bnc-sdk/dist/cjs/index.js":
/*!************************************************!*\
  !*** ./node_modules/bnc-sdk/dist/cjs/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar crypto = _interopDefault(__webpack_require__(/*! crypto */ \"crypto\"));\n\nconst networks = {\n  ethereum: {\n    '1': 'main',\n    '5': 'goerli',\n    '100': 'xdai',\n    '137': 'matic-main',\n    '80001': 'matic-mumbai'\n  }\n};\nconst DEPRECATED_NETWORK_IDS = [2, 3, 4, 42, 56, 250];\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    appVersion,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'appVersion', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'appVersion',\n    value: appVersion,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n\n  if (DEPRECATED_NETWORK_IDS.includes(networkId)) {\n    console.error(`Blocknative SDK: Network with ID: ${networkId} has been deprecated and you will no longer receive transaction events on this network.`);\n  }\n\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\n\n\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/** `Object#toString` result references. */\n\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n/** Used to detect unsigned integer values. */\n\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\n\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0:\n      return func.call(thisArg);\n\n    case 1:\n      return func.call(thisArg, args[0]);\n\n    case 2:\n      return func.call(thisArg, args[0], args[1]);\n\n    case 3:\n      return func.call(thisArg, args[0], args[1], args[2]);\n  }\n\n  return func.apply(thisArg, args);\n}\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\n\n\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n\n  return result;\n}\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/** Used to check objects for own properties. */\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/** Built-in value references. */\n\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max;\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\n\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n/**\n * Used by `_.defaults` to customize its `_.assignIn` use.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to assign.\n * @param {Object} object The parent object of `objValue`.\n * @returns {*} Returns the value to assign.\n */\n\n\nfunction assignInDefaults(objValue, srcValue, key, object) {\n  if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n    return srcValue;\n  }\n\n  return objValue;\n}\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\n\n\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n    object[key] = value;\n  }\n}\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\n\n\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\n\n\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n  return function () {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n\n    index = -1;\n    var otherArgs = Array(start + 1);\n\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\n\n\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n\n  return object;\n}\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\n\n\nfunction createAssigner(assigner) {\n  return baseRest(function (object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n\n    object = Object(object);\n\n    while (++index < length) {\n      var source = sources[index];\n\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n\n    return object;\n  });\n}\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\n\n\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n}\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\n\n\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n\n  var type = typeof index;\n\n  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n    return eq(object[index], value);\n  }\n\n  return false;\n}\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\n\n\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n  return value === proto;\n}\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\n\n\nfunction nativeKeysIn(object) {\n  var result = [];\n\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n\n  return result;\n}\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\n\n\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\n\n\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\n\n\nvar isArray = Array.isArray;\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\n\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\n\n\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\n\n\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\n\n\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n/**\n * This method is like `_.assignIn` except that it accepts `customizer`\n * which is invoked to produce the assigned values. If `customizer` returns\n * `undefined`, assignment is handled by the method instead. The `customizer`\n * is invoked with five arguments: (objValue, srcValue, key, object, source).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias extendWith\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @see _.assignWith\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   return _.isUndefined(objValue) ? srcValue : objValue;\n * }\n *\n * var defaults = _.partialRight(_.assignInWith, customizer);\n *\n * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\n\n\nvar assignInWith = createAssigner(function (object, source, srcIndex, customizer) {\n  copyObject(source, keysIn(source), object, customizer);\n});\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\n\nvar defaults = baseRest(function (args) {\n  args.push(undefined, assignInDefaults);\n  return apply(assignInWith, undefined, args);\n});\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\n\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nvar lodash_defaults = defaults;\nvar dist = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  var SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\n  var SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\n  var SturdyWebSocket =\n  /** @class */\n  function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n      this.url = url;\n      this.onclose = null;\n      this.onerror = null;\n      this.onmessage = null;\n      this.onopen = null;\n      this.ondown = null;\n      this.onreopen = null;\n      this.CONNECTING = SturdyWebSocket.CONNECTING;\n      this.OPEN = SturdyWebSocket.OPEN;\n      this.CLOSING = SturdyWebSocket.CLOSING;\n      this.CLOSED = SturdyWebSocket.CLOSED;\n      this.hasBeenOpened = false;\n      this.isClosed = false;\n      this.messageBuffer = [];\n      this.nextRetryTime = 0;\n      this.reconnectCount = 0;\n      this.lastKnownExtensions = \"\";\n      this.lastKnownProtocol = \"\";\n      this.listeners = {};\n\n      if (protocolsOrOptions == null || typeof protocolsOrOptions === \"string\" || Array.isArray(protocolsOrOptions)) {\n        this.protocols = protocolsOrOptions;\n      } else {\n        options = protocolsOrOptions;\n      }\n\n      this.options = lodash_defaults({}, options, SturdyWebSocket.DEFAULT_OPTIONS);\n\n      if (!this.options.wsConstructor) {\n        if (typeof WebSocket !== \"undefined\") {\n          this.options.wsConstructor = WebSocket;\n        } else {\n          throw new Error(\"WebSocket not present in global scope and no \" + \"wsConstructor option was provided.\");\n        }\n      }\n\n      this.openNewWebSocket();\n    }\n\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n      get: function () {\n        return this.binaryTypeInternal || \"blob\";\n      },\n      set: function (binaryType) {\n        this.binaryTypeInternal = binaryType;\n\n        if (this.ws) {\n          this.ws.binaryType = binaryType;\n        }\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n      get: function () {\n        var sum = this.ws ? this.ws.bufferedAmount : 0;\n        var hasUnknownAmount = false;\n        this.messageBuffer.forEach(function (data) {\n          var byteLength = getDataByteLength(data);\n\n          if (byteLength != null) {\n            sum += byteLength;\n          } else {\n            hasUnknownAmount = true;\n          }\n        });\n\n        if (hasUnknownAmount) {\n          this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" + \" return value may be below the correct amount.\");\n        }\n\n        return sum;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n      get: function () {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n      get: function () {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n      get: function () {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    SturdyWebSocket.prototype.close = function (code, reason) {\n      if (this.ws) {\n        this.ws.close(code, reason);\n      }\n\n      this.shutdown();\n      this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n\n    SturdyWebSocket.prototype.send = function (data) {\n      if (this.ws && this.ws.readyState === this.OPEN) {\n        this.ws.send(data);\n      } else {\n        this.messageBuffer.push(data);\n      }\n    };\n\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n      if (!this.listeners[type]) {\n        this.listeners[type] = [];\n      }\n\n      this.listeners[type].push(listener);\n    };\n\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n      return this.dispatchEventOfType(event.type, event);\n    };\n\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n      if (this.listeners[type]) {\n        this.listeners[type] = this.listeners[type].filter(function (l) {\n          return l !== listener;\n        });\n      }\n    };\n\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n      var _this = this;\n\n      if (this.isClosed) {\n        return;\n      }\n\n      var _a = this.options,\n          connectTimeout = _a.connectTimeout,\n          wsConstructor = _a.wsConstructor;\n      this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n      var ws = new wsConstructor(this.url, this.protocols);\n\n      ws.onclose = function (event) {\n        return _this.handleClose(event);\n      };\n\n      ws.onerror = function (event) {\n        return _this.handleError(event);\n      };\n\n      ws.onmessage = function (event) {\n        return _this.handleMessage(event);\n      };\n\n      ws.onopen = function (event) {\n        return _this.handleOpen(event);\n      };\n\n      this.connectTimeoutId = setTimeout(function () {\n        // If this is running, we still haven't opened the websocket.\n        // Kill it so we can try again.\n        _this.clearConnectTimeout();\n\n        ws.close();\n      }, connectTimeout);\n      this.ws = ws;\n    };\n\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n      var _this = this;\n\n      if (!this.ws || this.isClosed) {\n        return;\n      }\n\n      var allClearResetTime = this.options.allClearResetTime;\n      this.debugLog(\"WebSocket opened.\");\n\n      if (this.binaryTypeInternal != null) {\n        this.ws.binaryType = this.binaryTypeInternal;\n      } else {\n        this.binaryTypeInternal = this.ws.binaryType;\n      }\n\n      this.clearConnectTimeout();\n\n      if (this.hasBeenOpened) {\n        this.dispatchEventOfType(\"reopen\", event);\n      } else {\n        this.dispatchEventOfType(\"open\", event);\n        this.hasBeenOpened = true;\n      }\n\n      this.messageBuffer.forEach(function (message) {\n        return _this.send(message);\n      });\n      this.messageBuffer = [];\n      this.allClearTimeoutId = setTimeout(function () {\n        _this.clearAllClearTimeout();\n\n        _this.nextRetryTime = 0;\n        _this.reconnectCount = 0;\n        var openTime = allClearResetTime / 1000 | 0;\n\n        _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" + \" retry time and count.\");\n      }, allClearResetTime);\n    };\n\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n      if (this.isClosed) {\n        return;\n      }\n\n      this.dispatchEventOfType(\"message\", event);\n    };\n\n    SturdyWebSocket.prototype.handleClose = function (event) {\n      var _this = this;\n\n      if (this.isClosed) {\n        return;\n      }\n\n      var _a = this.options,\n          maxReconnectAttempts = _a.maxReconnectAttempts,\n          shouldReconnect = _a.shouldReconnect;\n      this.clearConnectTimeout();\n      this.clearAllClearTimeout();\n\n      if (this.ws) {\n        this.lastKnownExtensions = this.ws.extensions;\n        this.lastKnownProtocol = this.ws.protocol;\n        this.ws = undefined;\n      }\n\n      this.dispatchEventOfType(\"down\", event);\n\n      if (this.reconnectCount >= maxReconnectAttempts) {\n        this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n        return;\n      }\n\n      var willReconnect = shouldReconnect(event);\n\n      if (typeof willReconnect === \"boolean\") {\n        this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n      } else {\n        willReconnect.then(function (willReconnectResolved) {\n          if (_this.isClosed) {\n            return;\n          }\n\n          _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n        });\n      }\n    };\n\n    SturdyWebSocket.prototype.handleError = function (event) {\n      this.dispatchEventOfType(\"error\", event);\n      this.debugLog(\"WebSocket encountered an error.\");\n    };\n\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n      if (willReconnect) {\n        this.reconnect();\n      } else {\n        this.stopReconnecting(event, denialReason);\n      }\n    };\n\n    SturdyWebSocket.prototype.reconnect = function () {\n      var _this = this;\n\n      var _a = this.options,\n          minReconnectDelay = _a.minReconnectDelay,\n          maxReconnectDelay = _a.maxReconnectDelay,\n          reconnectBackoffFactor = _a.reconnectBackoffFactor;\n      this.reconnectCount++;\n      var retryTime = this.nextRetryTime;\n      this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n      setTimeout(function () {\n        return _this.openNewWebSocket();\n      }, retryTime);\n      var retryTimeSeconds = retryTime / 1000 | 0;\n      this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n      this.debugLog(debugReason);\n      this.shutdown();\n      this.dispatchEventOfType(\"close\", event);\n    };\n\n    SturdyWebSocket.prototype.shutdown = function () {\n      this.isClosed = true;\n      this.clearAllTimeouts();\n      this.messageBuffer = [];\n    };\n\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n      this.clearConnectTimeout();\n      this.clearAllClearTimeout();\n    };\n\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n      if (this.connectTimeoutId != null) {\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = undefined;\n      }\n    };\n\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n      if (this.allClearTimeoutId != null) {\n        clearTimeout(this.allClearTimeoutId);\n        this.allClearTimeoutId = undefined;\n      }\n    };\n\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n      var _this = this;\n\n      switch (type) {\n        case \"close\":\n          if (this.onclose) {\n            this.onclose(event);\n          }\n\n          break;\n\n        case \"error\":\n          if (this.onerror) {\n            this.onerror(event);\n          }\n\n          break;\n\n        case \"message\":\n          if (this.onmessage) {\n            this.onmessage(event);\n          }\n\n          break;\n\n        case \"open\":\n          if (this.onopen) {\n            this.onopen(event);\n          }\n\n          break;\n\n        case \"down\":\n          if (this.ondown) {\n            this.ondown(event);\n          }\n\n          break;\n\n        case \"reopen\":\n          if (this.onreopen) {\n            this.onreopen(event);\n          }\n\n          break;\n      }\n\n      if (type in this.listeners) {\n        this.listeners[type].slice().forEach(function (listener) {\n          return _this.callListener(listener, event);\n        });\n      }\n\n      return !event || !event.defaultPrevented;\n    };\n\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n      if (typeof listener === \"function\") {\n        listener.call(this, event);\n      } else {\n        listener.handleEvent.call(this, event);\n      }\n    };\n\n    SturdyWebSocket.prototype.debugLog = function (message) {\n      if (this.options.debug) {\n        // tslint:disable-next-line:no-console\n        console.log(message);\n      }\n    };\n\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n      var maxReconnectAttempts = this.options.maxReconnectAttempts;\n      return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n      allClearResetTime: 5000,\n      connectTimeout: 5000,\n      debug: false,\n      minReconnectDelay: 1000,\n      maxReconnectDelay: 30000,\n      maxReconnectAttempts: Number.POSITIVE_INFINITY,\n      reconnectBackoffFactor: 1.5,\n      shouldReconnect: function () {\n        return true;\n      },\n      wsConstructor: undefined\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n  }();\n\n  exports.default = SturdyWebSocket;\n\n  function getDataByteLength(data) {\n    if (typeof data === \"string\") {\n      // UTF-16 strings use two bytes per character.\n      return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n      return data.byteLength;\n    } else if (data instanceof Blob) {\n      return data.size;\n    } else {\n      return undefined;\n    }\n  }\n\n  function pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n  }\n});\nvar SturdyWebSocket = unwrapExports(dist);\n/* eslint-disable no-use-before-define */\n\n/**\n * Base class for inheritance.\n */\n\nclass Base {\n  /**\n   * Extends this object and runs the init method.\n   * Arguments to create() will be passed to init().\n   *\n   * @return {Object} The new object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var instance = MyType.create();\n   */\n  static create(...args) {\n    return new this(...args);\n  }\n  /**\n   * Copies properties into this object.\n   *\n   * @param {Object} properties The properties to mix in.\n   *\n   * @example\n   *\n   *     MyType.mixIn({\n   *         field: 'value'\n   *     });\n   */\n\n\n  mixIn(properties) {\n    return Object.assign(this, properties);\n  }\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = instance.clone();\n   */\n\n\n  clone() {\n    const clone = new this.constructor();\n    Object.assign(clone, this);\n    return clone;\n  }\n\n}\n/**\n * An array of 32-bit words.\n *\n * @property {Array} words The array of 32-bit words.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\n\n\nclass WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of 32-bit words.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.create();\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n   */\n  constructor(words = [], sigBytes = words.length * 4) {\n    super();\n    let typedArray = words; // Convert buffers to uint8\n\n    if (typedArray instanceof ArrayBuffer) {\n      typedArray = new Uint8Array(typedArray);\n    } // Convert other array views to uint8\n\n\n    if (typedArray instanceof Int8Array || typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {\n      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n    } // Handle Uint8Array\n\n\n    if (typedArray instanceof Uint8Array) {\n      // Shortcut\n      const typedArrayByteLength = typedArray.byteLength; // Extract bytes\n\n      const _words = [];\n\n      for (let i = 0; i < typedArrayByteLength; i += 1) {\n        _words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;\n      } // Initialize this word array\n\n\n      this.words = _words;\n      this.sigBytes = typedArrayByteLength;\n    } else {\n      // Else call normal init\n      this.words = words;\n      this.sigBytes = sigBytes;\n    }\n  }\n  /**\n   * Creates a word array filled with random bytes.\n   *\n   * @param {number} nBytes The number of random bytes to generate.\n   *\n   * @return {WordArray} The random word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.random(16);\n   */\n\n\n  static random(nBytes) {\n    const words = [];\n\n    const r = m_w => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n      return () => {\n        _m_z = 0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10) & mask;\n        _m_w = 0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10) & mask;\n        let result = (_m_z << 0x10) + _m_w & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n\n    for (let i = 0, rcache; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n\n      rcache = _r() * 0x3ade67b7;\n      words.push(_r() * 0x100000000 | 0);\n    }\n\n    return new WordArray(words, nBytes);\n  }\n  /**\n   * Converts this word array to a string.\n   *\n   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n   *\n   * @return {string} The stringified word array.\n   *\n   * @example\n   *\n   *     var string = wordArray + '';\n   *     var string = wordArray.toString();\n   *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n   */\n\n\n  toString(encoder = Hex) {\n    return encoder.stringify(this);\n  }\n  /**\n   * Concatenates a word array to this word array.\n   *\n   * @param {WordArray} wordArray The word array to append.\n   *\n   * @return {WordArray} This word array.\n   *\n   * @example\n   *\n   *     wordArray1.concat(wordArray2);\n   */\n\n\n  concat(wordArray) {\n    // Shortcuts\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes; // Clamp excess bits\n\n    this.clamp(); // Concat\n\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n        thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;\n      }\n    } else {\n      // Copy one word at a time\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];\n      }\n    }\n\n    this.sigBytes += thatSigBytes; // Chainable\n\n    return this;\n  }\n  /**\n   * Removes insignificant bits.\n   *\n   * @example\n   *\n   *     wordArray.clamp();\n   */\n\n\n  clamp() {\n    // Shortcuts\n    const {\n      words,\n      sigBytes\n    } = this; // Clamp\n\n    words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;\n    words.length = Math.ceil(sigBytes / 4);\n  }\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = wordArray.clone();\n   */\n\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone.words = this.words.slice(0);\n    return clone;\n  }\n\n}\n/**\n * Hex encoding strategy.\n */\n\n\nconst Hex = {\n  /**\n   * Converts a word array to a hex string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The hex string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const {\n      words,\n      sigBytes\n    } = wordArray; // Convert\n\n    const hexChars = [];\n\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   *\n   * @param {string} hexStr The hex string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n   */\n  parse(hexStr) {\n    // Shortcut\n    const hexStrLength = hexStr.length; // Convert\n\n    const words = [];\n\n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  }\n\n};\n/**\n * Latin1 encoding strategy.\n */\n\nconst Latin1 = {\n  /**\n   * Converts a word array to a Latin1 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Latin1 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const {\n      words,\n      sigBytes\n    } = wordArray; // Convert\n\n    const latin1Chars = [];\n\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   *\n   * @param {string} latin1Str The Latin1 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n   */\n  parse(latin1Str) {\n    // Shortcut\n    const latin1StrLength = latin1Str.length; // Convert\n\n    const words = [];\n\n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;\n    }\n\n    return new WordArray(words, latin1StrLength);\n  }\n\n};\n/**\n * UTF-8 encoding strategy.\n */\n\nconst Utf8 = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-8 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   *\n   * @param {string} utf8Str The UTF-8 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n   */\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n\n};\n/**\n * Abstract buffered block algorithm template.\n *\n * The property blockSize must be implemented in a concrete subtype.\n *\n * @property {number} _minBufferSize\n *\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\n */\n\nclass BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm.reset();\n   */\n\n\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  /**\n   * Adds new data to this block algorithm's buffer.\n   *\n   * @param {WordArray|string} data\n   *\n   *     The data to append. Strings are converted to a WordArray using UTF-8.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm._append('data');\n   *     bufferedBlockAlgorithm._append(wordArray);\n   */\n\n\n  _append(data) {\n    let m_data = data; // Convert string to WordArray, else assume WordArray already\n\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    } // Append\n\n\n    this._data.concat(m_data);\n\n    this._nDataBytes += m_data.sigBytes;\n  }\n  /**\n   * Processes available data blocks.\n   *\n   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n   *\n   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n   *\n   * @return {WordArray} The processed data.\n   *\n   * @example\n   *\n   *     var processedData = bufferedBlockAlgorithm._process();\n   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n   */\n\n\n  _process(doFlush) {\n    let processedWords; // Shortcuts\n\n    const {\n      _data: data,\n      blockSize\n    } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4; // Count blocks ready\n\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    } // Count words ready\n\n\n    const nWordsReady = nBlocksReady * blockSize; // Count bytes ready\n\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); // Process blocks\n\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      } // Remove processed words\n\n\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    } // Return processed words\n\n\n    return new WordArray(processedWords, nBytesReady);\n  }\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = bufferedBlockAlgorithm.clone();\n   */\n\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n    return clone;\n  }\n\n}\n/**\n * Abstract hasher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n */\n\n\nclass Hasher extends BufferedBlockAlgorithm {\n  constructor(cfg) {\n    super();\n    this.blockSize = 512 / 32;\n    /**\n     * Configuration options.\n     */\n\n    this.cfg = Object.assign(new Base(), cfg); // Set initial values\n\n    this.reset();\n  }\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to create a helper for.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n   */\n\n\n  static _createHelper(SubHasher) {\n    return (message, cfg) => new SubHasher(cfg).finalize(message);\n  }\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n   */\n\n\n  static _createHmacHelper(SubHasher) {\n    return (message, key) => new HMAC(SubHasher, key).finalize(message);\n  }\n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *\n   *     hasher.reset();\n   */\n\n\n  reset() {\n    // Reset data buffer\n    super.reset.call(this); // Perform concrete-hasher logic\n\n    this._doReset();\n  }\n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {Hasher} This hasher.\n   *\n   * @example\n   *\n   *     hasher.update('message');\n   *     hasher.update(wordArray);\n   */\n\n\n  update(messageUpdate) {\n    // Append\n    this._append(messageUpdate); // Update the hash\n\n\n    this._process(); // Chainable\n\n\n    return this;\n  }\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @example\n   *\n   *     var hash = hasher.finalize();\n   *     var hash = hasher.finalize('message');\n   *     var hash = hasher.finalize(wordArray);\n   */\n\n\n  finalize(messageUpdate) {\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    } // Perform concrete-hasher logic\n\n\n    const hash = this._doFinalize();\n\n    return hash;\n  }\n\n}\n/**\n * HMAC algorithm.\n */\n\n\nclass HMAC extends Base {\n  /**\n   * Initializes a newly created HMAC.\n   *\n   * @param {Hasher} SubHasher The hash algorithm to use.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @example\n   *\n   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n   */\n  constructor(SubHasher, key) {\n    super();\n    const hasher = new SubHasher();\n    this._hasher = hasher; // Convert string to WordArray, else assume WordArray already\n\n    let _key = key;\n\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    } // Shortcuts\n\n\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4; // Allow arbitrary length keys\n\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    } // Clamp excess bits\n\n\n    _key.clamp(); // Clone key for inner and outer pads\n\n\n    const oKey = _key.clone();\n\n    this._oKey = oKey;\n\n    const iKey = _key.clone();\n\n    this._iKey = iKey; // Shortcuts\n\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words; // XOR keys with pad constants\n\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes; // Set initial values\n\n    this.reset();\n  }\n  /**\n   * Resets this HMAC to its initial state.\n   *\n   * @example\n   *\n   *     hmacHasher.reset();\n   */\n\n\n  reset() {\n    // Shortcut\n    const hasher = this._hasher; // Reset\n\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n  /**\n   * Updates this HMAC with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {HMAC} This HMAC instance.\n   *\n   * @example\n   *\n   *     hmacHasher.update('message');\n   *     hmacHasher.update(wordArray);\n   */\n\n\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate); // Chainable\n\n\n    return this;\n  }\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @example\n   *\n   *     var hmac = hmacHasher.finalize();\n   *     var hmac = hmacHasher.finalize('message');\n   *     var hmac = hmacHasher.finalize(wordArray);\n   */\n\n\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher; // Compute HMAC\n\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n    return hmac;\n  }\n\n}\n\nconst X32WordArray = WordArray;\n/**\n * A 64-bit word.\n */\n\nclass X64Word extends Base {\n  /**\n   * Initializes a newly created 64-bit word.\n   *\n   * @param {number} high The high 32 bits.\n   * @param {number} low The low 32 bits.\n   *\n   * @example\n   *\n   *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n   */\n  constructor(high, low) {\n    super();\n    this.high = high;\n    this.low = low;\n  }\n\n}\n/**\n * An array of 64-bit words.\n *\n * @property {Array} words The array of CryptoJS.x64.Word objects.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\n\n\nclass X64WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create();\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create([\n   *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n   *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n   *     ]);\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create([\n   *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n   *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n   *     ], 10);\n   */\n  constructor(words = [], sigBytes = words.length * 8) {\n    super();\n    this.words = words;\n    this.sigBytes = sigBytes;\n  }\n  /**\n   * Converts this 64-bit word array to a 32-bit word array.\n   *\n   * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n   *\n   * @example\n   *\n   *     var x32WordArray = x64WordArray.toX32();\n   */\n\n\n  toX32() {\n    // Shortcuts\n    const x64Words = this.words;\n    const x64WordsLength = x64Words.length; // Convert\n\n    const x32Words = [];\n\n    for (let i = 0; i < x64WordsLength; i += 1) {\n      const x64Word = x64Words[i];\n      x32Words.push(x64Word.high);\n      x32Words.push(x64Word.low);\n    }\n\n    return X32WordArray.create(x32Words, this.sigBytes);\n  }\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {X64WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = x64WordArray.clone();\n   */\n\n\n  clone() {\n    const clone = super.clone.call(this); // Clone \"words\" array\n\n    clone.words = this.words.slice(0);\n    const {\n      words\n    } = clone; // Clone each X64Word object\n\n    const wordsLength = words.length;\n\n    for (let i = 0; i < wordsLength; i += 1) {\n      words[i] = words[i].clone();\n    }\n\n    return clone;\n  }\n\n}\n\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\n  const words = [];\n  let nBytes = 0;\n\n  for (let i = 0; i < base64StrLength; i += 1) {\n    if (i % 4) {\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;\n      const bitsCombined = bits1 | bits2;\n      words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;\n      nBytes += 1;\n    }\n  }\n\n  return WordArray.create(words, nBytes);\n};\n/**\n * Base64 encoding strategy.\n */\n\n\nconst Base64 = {\n  /**\n   * Converts a word array to a Base64 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Base64 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const {\n      words,\n      sigBytes\n    } = wordArray;\n    const map = this._map; // Clamp excess bits\n\n    wordArray.clamp(); // Convert\n\n    const base64Chars = [];\n\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n      const byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;\n      const byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n\n      for (let j = 0; j < 4 && i + j * 0.75 < sigBytes; j += 1) {\n        base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));\n      }\n    } // Add padding\n\n\n    const paddingChar = map.charAt(64);\n\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n\n    return base64Chars.join('');\n  },\n\n  /**\n   * Converts a Base64 string to a word array.\n   *\n   * @param {string} base64Str The Base64 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\n   */\n  parse(base64Str) {\n    // Shortcuts\n    let base64StrLength = base64Str.length;\n    const map = this._map;\n    let reverseMap = this._reverseMap;\n\n    if (!reverseMap) {\n      this._reverseMap = [];\n      reverseMap = this._reverseMap;\n\n      for (let j = 0; j < map.length; j += 1) {\n        reverseMap[map.charCodeAt(j)] = j;\n      }\n    } // Ignore padding\n\n\n    const paddingChar = map.charAt(64);\n\n    if (paddingChar) {\n      const paddingIndex = base64Str.indexOf(paddingChar);\n\n      if (paddingIndex !== -1) {\n        base64StrLength = paddingIndex;\n      }\n    } // Convert\n\n\n    return parseLoop(base64Str, base64StrLength, reverseMap);\n  },\n\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n}; // Constants table\n\nconst T = []; // Compute constants\n\nfor (let i = 0; i < 64; i += 1) {\n  T[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;\n}\n\nconst FF = (a, b, c, d, x, s, t) => {\n  const n = a + (b & c | ~b & d) + x + t;\n  return (n << s | n >>> 32 - s) + b;\n};\n\nconst GG = (a, b, c, d, x, s, t) => {\n  const n = a + (b & d | c & ~d) + x + t;\n  return (n << s | n >>> 32 - s) + b;\n};\n\nconst HH = (a, b, c, d, x, s, t) => {\n  const n = a + (b ^ c ^ d) + x + t;\n  return (n << s | n >>> 32 - s) + b;\n};\n\nconst II = (a, b, c, d, x, s, t) => {\n  const n = a + (c ^ (b | ~d)) + x + t;\n  return (n << s | n >>> 32 - s) + b;\n};\n/**\n * MD5 hash algorithm.\n */\n\n\nclass MD5Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M; // Swap endian\n\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = M[offset_i];\n      _M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;\n    } // Shortcuts\n\n\n    const H = this._hash.words;\n    const M_offset_0 = _M[offset + 0];\n    const M_offset_1 = _M[offset + 1];\n    const M_offset_2 = _M[offset + 2];\n    const M_offset_3 = _M[offset + 3];\n    const M_offset_4 = _M[offset + 4];\n    const M_offset_5 = _M[offset + 5];\n    const M_offset_6 = _M[offset + 6];\n    const M_offset_7 = _M[offset + 7];\n    const M_offset_8 = _M[offset + 8];\n    const M_offset_9 = _M[offset + 9];\n    const M_offset_10 = _M[offset + 10];\n    const M_offset_11 = _M[offset + 11];\n    const M_offset_12 = _M[offset + 12];\n    const M_offset_13 = _M[offset + 13];\n    const M_offset_14 = _M[offset + 14];\n    const M_offset_15 = _M[offset + 15]; // Working varialbes\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3]; // Computation\n\n    a = FF(a, b, c, d, M_offset_0, 7, T[0]);\n    d = FF(d, a, b, c, M_offset_1, 12, T[1]);\n    c = FF(c, d, a, b, M_offset_2, 17, T[2]);\n    b = FF(b, c, d, a, M_offset_3, 22, T[3]);\n    a = FF(a, b, c, d, M_offset_4, 7, T[4]);\n    d = FF(d, a, b, c, M_offset_5, 12, T[5]);\n    c = FF(c, d, a, b, M_offset_6, 17, T[6]);\n    b = FF(b, c, d, a, M_offset_7, 22, T[7]);\n    a = FF(a, b, c, d, M_offset_8, 7, T[8]);\n    d = FF(d, a, b, c, M_offset_9, 12, T[9]);\n    c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n    b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n    a = FF(a, b, c, d, M_offset_12, 7, T[12]);\n    d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n    c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n    b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n    a = GG(a, b, c, d, M_offset_1, 5, T[16]);\n    d = GG(d, a, b, c, M_offset_6, 9, T[17]);\n    c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n    b = GG(b, c, d, a, M_offset_0, 20, T[19]);\n    a = GG(a, b, c, d, M_offset_5, 5, T[20]);\n    d = GG(d, a, b, c, M_offset_10, 9, T[21]);\n    c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n    b = GG(b, c, d, a, M_offset_4, 20, T[23]);\n    a = GG(a, b, c, d, M_offset_9, 5, T[24]);\n    d = GG(d, a, b, c, M_offset_14, 9, T[25]);\n    c = GG(c, d, a, b, M_offset_3, 14, T[26]);\n    b = GG(b, c, d, a, M_offset_8, 20, T[27]);\n    a = GG(a, b, c, d, M_offset_13, 5, T[28]);\n    d = GG(d, a, b, c, M_offset_2, 9, T[29]);\n    c = GG(c, d, a, b, M_offset_7, 14, T[30]);\n    b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n    a = HH(a, b, c, d, M_offset_5, 4, T[32]);\n    d = HH(d, a, b, c, M_offset_8, 11, T[33]);\n    c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n    b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n    a = HH(a, b, c, d, M_offset_1, 4, T[36]);\n    d = HH(d, a, b, c, M_offset_4, 11, T[37]);\n    c = HH(c, d, a, b, M_offset_7, 16, T[38]);\n    b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n    a = HH(a, b, c, d, M_offset_13, 4, T[40]);\n    d = HH(d, a, b, c, M_offset_0, 11, T[41]);\n    c = HH(c, d, a, b, M_offset_3, 16, T[42]);\n    b = HH(b, c, d, a, M_offset_6, 23, T[43]);\n    a = HH(a, b, c, d, M_offset_9, 4, T[44]);\n    d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n    c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n    b = HH(b, c, d, a, M_offset_2, 23, T[47]);\n    a = II(a, b, c, d, M_offset_0, 6, T[48]);\n    d = II(d, a, b, c, M_offset_7, 10, T[49]);\n    c = II(c, d, a, b, M_offset_14, 15, T[50]);\n    b = II(b, c, d, a, M_offset_5, 21, T[51]);\n    a = II(a, b, c, d, M_offset_12, 6, T[52]);\n    d = II(d, a, b, c, M_offset_3, 10, T[53]);\n    c = II(c, d, a, b, M_offset_10, 15, T[54]);\n    b = II(b, c, d, a, M_offset_1, 21, T[55]);\n    a = II(a, b, c, d, M_offset_8, 6, T[56]);\n    d = II(d, a, b, c, M_offset_15, 10, T[57]);\n    c = II(c, d, a, b, M_offset_6, 15, T[58]);\n    b = II(b, c, d, a, M_offset_13, 21, T[59]);\n    a = II(a, b, c, d, M_offset_4, 6, T[60]);\n    d = II(d, a, b, c, M_offset_11, 10, T[61]);\n    c = II(c, d, a, b, M_offset_2, 15, T[62]);\n    b = II(b, c, d, a, M_offset_9, 21, T[63]); // Intermediate hash value\n\n    H[0] = H[0] + a | 0;\n    H[1] = H[1] + b | 0;\n    H[2] = H[2] + c | 0;\n    H[3] = H[3] + d | 0;\n  }\n  /* eslint-ensable no-param-reassign */\n\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8; // Add padding\n\n    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n    const nBitsTotalL = nBitsTotal;\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;\n    data.sigBytes = (dataWords.length + 1) * 4; // Hash final blocks\n\n    this._process(); // Shortcuts\n\n\n    const hash = this._hash;\n    const H = hash.words; // Swap endian\n\n    for (let i = 0; i < 4; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n      H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;\n    } // Return final computed hash\n\n\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n    return clone;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.MD5('message');\n *     var hash = CryptoJS.MD5(wordArray);\n */\n\n\nconst MD5 = Hasher._createHelper(MD5Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacMD5(message, key);\n */\n\n\nconst HmacMD5 = Hasher._createHmacHelper(MD5Algo);\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\n\n\nclass EvpKDFAlgo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n\n    this.cfg = Object.assign(new Base(), {\n      keySize: 128 / 32,\n      hasher: MD5Algo,\n      iterations: 1\n    }, cfg);\n  }\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n\n\n  compute(password, salt) {\n    let block; // Shortcut\n\n    const {\n      cfg\n    } = this; // Init hasher\n\n    const hasher = cfg.hasher.create(); // Initial values\n\n    const derivedKey = WordArray.create(); // Shortcuts\n\n    const derivedKeyWords = derivedKey.words;\n    const {\n      keySize,\n      iterations\n    } = cfg; // Generate key\n\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n\n      block = hasher.update(password).finalize(salt);\n      hasher.reset(); // Iterations\n\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n\n    derivedKey.sigBytes = keySize * 4;\n    return derivedKey;\n  }\n\n}\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\n\n\nconst EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n/* eslint-disable no-use-before-define */\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\n\n\nclass Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n    this.keySize = 128 / 32;\n    this.ivSize = 128 / 32;\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n\n    this.cfg = Object.assign(new Base(), cfg); // Store transform mode and key\n\n    this._xformMode = xformMode;\n    this._key = key; // Set initial values\n\n    this.reset();\n  }\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n\n\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n\n\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n\n\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = key => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      }\n\n    };\n  }\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n\n\n  reset() {\n    // Reset data buffer\n    super.reset.call(this); // Perform concrete-cipher logic\n\n    this._doReset();\n  }\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n\n\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate); // Process available blocks\n\n\n    return this._process();\n  }\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n\n\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    } // Perform concrete-cipher logic\n\n\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n\n}\n\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\n\nclass StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n\n}\n/**\n * Abstract base block cipher mode template.\n */\n\n\nclass BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n\n\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n\n\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block; // Shortcut\n\n  const iv = this._iv; // Choose mixing block\n\n  if (iv) {\n    block = iv; // Remove IV for subsequent blocks\n\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  } // XOR blocks\n\n\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\n\n\nclass CBC extends BlockCipherMode {}\n/**\n * CBC encryptor.\n */\n\n\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher; // XOR and encrypt\n\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset); // Remember this block to use with next block\n\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n\n};\n/**\n * CBC decryptor.\n */\n\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher; // Remember this block to use with next block\n\n    const thisBlock = words.slice(offset, offset + blockSize); // Decrypt and XOR\n\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize); // This block becomes the previous block\n\n    this._prevBlock = thisBlock;\n  }\n\n};\n/**\n * PKCS #5/7 padding strategy.\n */\n\nconst Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4; // Count padding bytes\n\n    const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Create padding word\n\n    const paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes; // Create padding\n\n    const paddingWords = [];\n\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n\n    const padding = WordArray.create(paddingWords, nPaddingBytes); // Add padding\n\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data; // Get number of padding bytes from last byte\n\n    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 0xff; // Remove padding\n\n    _data.sigBytes -= nPaddingBytes;\n  }\n\n};\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\n\nclass BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign({\n      mode: CBC,\n      padding: Pkcs7\n    }, cfg));\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator; // Reset cipher\n\n    super.reset.call(this); // Shortcuts\n\n    const {\n      cfg\n    } = this;\n    const {\n      iv,\n      mode\n    } = cfg; // Reset block mode\n\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else\n      /* if (this._xformMode == this._DEC_XFORM_MODE) */\n      {\n        modeCreator = mode.createDecryptor; // Keep at least one block in the buffer for unpadding\n\n        this._minBufferSize = 1;\n      }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks; // Shortcut\n\n    const {\n      padding\n    } = this.cfg; // Finalize\n\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize); // Process final blocks\n\n      finalProcessedBlocks = this._process(!!'flush');\n    } else\n      /* if (this._xformMode == this._DEC_XFORM_MODE) */\n      {\n        // Process final blocks\n        finalProcessedBlocks = this._process(!!'flush'); // Unpad data\n\n        padding.unpad(finalProcessedBlocks);\n      }\n\n    return finalProcessedBlocks;\n  }\n\n}\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\n\n\nclass CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n    this.mixIn(cipherParams);\n  }\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n\n\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n\n}\n/**\n * OpenSSL formatting strategy.\n */\n\n\nconst OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray; // Shortcuts\n\n    const {\n      ciphertext,\n      salt\n    } = cipherParams; // Format\n\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt; // Parse base64\n\n    const ciphertext = Base64.parse(openSSLStr); // Shortcut\n\n    const ciphertextWords = ciphertext.words; // Test for salt\n\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4)); // Remove salt from ciphertext\n\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({\n      ciphertext,\n      salt\n    });\n  }\n\n};\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\n\nclass SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Encrypt\n\n\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message); // Shortcut\n\n    const cipherCfg = encryptor.cfg; // Create and return serializable cipher params\n\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format\n    });\n  }\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n\n\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext; // Apply config defaults\n\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n    _ciphertext = this._parse(_ciphertext, _cfg.format); // Decrypt\n\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n    return plaintext;\n  }\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n\n\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n\n    return ciphertext;\n  }\n\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\n\n\nSerializableCipher.cfg = Object.assign(new Base(), {\n  format: OpenSSLFormatter\n});\n/**\n * OpenSSL key derivation function.\n */\n\nconst OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt; // Generate random salt\n\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    } // Derive key and IV\n\n\n    const key = EvpKDFAlgo.create({\n      keySize: keySize + ivSize\n    }).compute(password, _salt); // Separate key and IV\n\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4; // Return params\n\n    return CipherParams.create({\n      key,\n      iv,\n      salt: _salt\n    });\n  }\n\n};\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\n\nclass PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Derive key and other params\n\n\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); // Add IV to config\n\n\n    _cfg.iv = derivedParams.iv; // Encrypt\n\n    const ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, _cfg); // Mix in derived params\n\n    ciphertext.mixIn(derivedParams);\n    return ciphertext;\n  }\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n\n\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext; // Apply config defaults\n\n    const _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n    _ciphertext = this._parse(_ciphertext, _cfg.format); // Derive key and other params\n\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt); // Add IV to config\n\n\n    _cfg.iv = derivedParams.iv; // Decrypt\n\n    const plaintext = SerializableCipher.decrypt.call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n    return plaintext;\n  }\n\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\n\n\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, {\n  kdf: OpenSSLKdf\n});\n\nconst swapEndian = word => word << 8 & 0xff00ff00 | word >>> 8 & 0x00ff00ff;\n/**\n * UTF-16 BE encoding strategy.\n */\n\n\nconst Utf16BE = {\n  /**\n   * Converts a word array to a UTF-16 BE string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-16 BE string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const {\n      words,\n      sigBytes\n    } = wordArray; // Convert\n\n    const utf16Chars = [];\n\n    for (let i = 0; i < sigBytes; i += 2) {\n      const codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff;\n      utf16Chars.push(String.fromCharCode(codePoint));\n    }\n\n    return utf16Chars.join('');\n  },\n\n  /**\n   * Converts a UTF-16 BE string to a word array.\n   *\n   * @param {string} utf16Str The UTF-16 BE string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n   */\n  parse(utf16Str) {\n    // Shortcut\n    const utf16StrLength = utf16Str.length; // Convert\n\n    const words = [];\n\n    for (let i = 0; i < utf16StrLength; i += 1) {\n      words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;\n    }\n\n    return WordArray.create(words, utf16StrLength * 2);\n  }\n\n};\nconst Utf16 = Utf16BE;\n/**\n * UTF-16 LE encoding strategy.\n */\n\nconst Utf16LE = {\n  /**\n   * Converts a word array to a UTF-16 LE string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-16 LE string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const {\n      words,\n      sigBytes\n    } = wordArray; // Convert\n\n    const utf16Chars = [];\n\n    for (let i = 0; i < sigBytes; i += 2) {\n      const codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff);\n      utf16Chars.push(String.fromCharCode(codePoint));\n    }\n\n    return utf16Chars.join('');\n  },\n\n  /**\n   * Converts a UTF-16 LE string to a word array.\n   *\n   * @param {string} utf16Str The UTF-16 LE string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n   */\n  parse(utf16Str) {\n    // Shortcut\n    const utf16StrLength = utf16Str.length; // Convert\n\n    const words = [];\n\n    for (let i = 0; i < utf16StrLength; i += 1) {\n      words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);\n    }\n\n    return WordArray.create(words, utf16StrLength * 2);\n  }\n\n}; // Reusable object\n\nconst W = [];\n/**\n * SHA-1 hash algorithm.\n */\n\nclass SHA1Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const H = this._hash.words; // Working variables\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4]; // Computation\n\n    for (let i = 0; i < 80; i += 1) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n        W[i] = n << 1 | n >>> 31;\n      }\n\n      let t = (a << 5 | a >>> 27) + e + W[i];\n\n      if (i < 20) {\n        t += (b & c | ~b & d) + 0x5a827999;\n      } else if (i < 40) {\n        t += (b ^ c ^ d) + 0x6ed9eba1;\n      } else if (i < 60) {\n        t += (b & c | b & d | c & d) - 0x70e44324;\n      } else\n        /* if (i < 80) */\n        {\n          t += (b ^ c ^ d) - 0x359d3e2a;\n        }\n\n      e = d;\n      d = c;\n      c = b << 30 | b >>> 2;\n      b = a;\n      a = t;\n    } // Intermediate hash value\n\n\n    H[0] = H[0] + a | 0;\n    H[1] = H[1] + b | 0;\n    H[2] = H[2] + c | 0;\n    H[3] = H[3] + d | 0;\n    H[4] = H[4] + e | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8; // Add padding\n\n    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4; // Hash final blocks\n\n    this._process(); // Return final computed hash\n\n\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n    return clone;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA1('message');\n *     var hash = CryptoJS.SHA1(wordArray);\n */\n\n\nconst SHA1 = Hasher._createHelper(SHA1Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA1(message, key);\n */\n\n\nconst HmacSHA1 = Hasher._createHmacHelper(SHA1Algo); // Initialization and round constants tables\n\n\nconst H = [];\nconst K = []; // Compute constants\n\nconst isPrime = n => {\n  const sqrtN = Math.sqrt(n);\n\n  for (let factor = 2; factor <= sqrtN; factor += 1) {\n    if (!(n % factor)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst getFractionalBits = n => (n - (n | 0)) * 0x100000000 | 0;\n\nlet n = 2;\nlet nPrime = 0;\n\nwhile (nPrime < 64) {\n  if (isPrime(n)) {\n    if (nPrime < 8) {\n      H[nPrime] = getFractionalBits(n ** (1 / 2));\n    }\n\n    K[nPrime] = getFractionalBits(n ** (1 / 3));\n    nPrime += 1;\n  }\n\n  n += 1;\n} // Reusable object\n\n\nconst W$1 = [];\n/**\n * SHA-256 hash algorithm.\n */\n\nclass SHA256Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray(H.slice(0));\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const _H = this._hash.words; // Working variables\n\n    let a = _H[0];\n    let b = _H[1];\n    let c = _H[2];\n    let d = _H[3];\n    let e = _H[4];\n    let f = _H[5];\n    let g = _H[6];\n    let h = _H[7]; // Computation\n\n    for (let i = 0; i < 64; i += 1) {\n      if (i < 16) {\n        W$1[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W$1[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W$1[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W$1[i] = gamma0 + W$1[i - 7] + gamma1 + W$1[i - 16];\n      }\n\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W$1[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    } // Intermediate hash value\n\n\n    _H[0] = _H[0] + a | 0;\n    _H[1] = _H[1] + b | 0;\n    _H[2] = _H[2] + c | 0;\n    _H[3] = _H[3] + d | 0;\n    _H[4] = _H[4] + e | 0;\n    _H[5] = _H[5] + f | 0;\n    _H[6] = _H[6] + g | 0;\n    _H[7] = _H[7] + h | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8; // Add padding\n\n    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4; // Hash final blocks\n\n    this._process(); // Return final computed hash\n\n\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n    return clone;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA256('message');\n *     var hash = CryptoJS.SHA256(wordArray);\n */\n\n\nconst SHA256 = Hasher._createHelper(SHA256Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA256(message, key);\n */\n\n\nconst HmacSHA256 = Hasher._createHmacHelper(SHA256Algo);\n/**\n * SHA-224 hash algorithm.\n */\n\n\nclass SHA224Algo extends SHA256Algo {\n  _doReset() {\n    this._hash = new WordArray([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);\n  }\n\n  _doFinalize() {\n    const hash = super._doFinalize.call(this);\n\n    hash.sigBytes -= 4;\n    return hash;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA224('message');\n *     var hash = CryptoJS.SHA224(wordArray);\n */\n\n\nconst SHA224 = SHA256Algo._createHelper(SHA224Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA224(message, key);\n */\n\n\nconst HmacSHA224 = SHA256Algo._createHmacHelper(SHA224Algo); // Constants\n\n\nconst K$1 = [new X64Word(0x428a2f98, 0xd728ae22), new X64Word(0x71374491, 0x23ef65cd), new X64Word(0xb5c0fbcf, 0xec4d3b2f), new X64Word(0xe9b5dba5, 0x8189dbbc), new X64Word(0x3956c25b, 0xf348b538), new X64Word(0x59f111f1, 0xb605d019), new X64Word(0x923f82a4, 0xaf194f9b), new X64Word(0xab1c5ed5, 0xda6d8118), new X64Word(0xd807aa98, 0xa3030242), new X64Word(0x12835b01, 0x45706fbe), new X64Word(0x243185be, 0x4ee4b28c), new X64Word(0x550c7dc3, 0xd5ffb4e2), new X64Word(0x72be5d74, 0xf27b896f), new X64Word(0x80deb1fe, 0x3b1696b1), new X64Word(0x9bdc06a7, 0x25c71235), new X64Word(0xc19bf174, 0xcf692694), new X64Word(0xe49b69c1, 0x9ef14ad2), new X64Word(0xefbe4786, 0x384f25e3), new X64Word(0x0fc19dc6, 0x8b8cd5b5), new X64Word(0x240ca1cc, 0x77ac9c65), new X64Word(0x2de92c6f, 0x592b0275), new X64Word(0x4a7484aa, 0x6ea6e483), new X64Word(0x5cb0a9dc, 0xbd41fbd4), new X64Word(0x76f988da, 0x831153b5), new X64Word(0x983e5152, 0xee66dfab), new X64Word(0xa831c66d, 0x2db43210), new X64Word(0xb00327c8, 0x98fb213f), new X64Word(0xbf597fc7, 0xbeef0ee4), new X64Word(0xc6e00bf3, 0x3da88fc2), new X64Word(0xd5a79147, 0x930aa725), new X64Word(0x06ca6351, 0xe003826f), new X64Word(0x14292967, 0x0a0e6e70), new X64Word(0x27b70a85, 0x46d22ffc), new X64Word(0x2e1b2138, 0x5c26c926), new X64Word(0x4d2c6dfc, 0x5ac42aed), new X64Word(0x53380d13, 0x9d95b3df), new X64Word(0x650a7354, 0x8baf63de), new X64Word(0x766a0abb, 0x3c77b2a8), new X64Word(0x81c2c92e, 0x47edaee6), new X64Word(0x92722c85, 0x1482353b), new X64Word(0xa2bfe8a1, 0x4cf10364), new X64Word(0xa81a664b, 0xbc423001), new X64Word(0xc24b8b70, 0xd0f89791), new X64Word(0xc76c51a3, 0x0654be30), new X64Word(0xd192e819, 0xd6ef5218), new X64Word(0xd6990624, 0x5565a910), new X64Word(0xf40e3585, 0x5771202a), new X64Word(0x106aa070, 0x32bbd1b8), new X64Word(0x19a4c116, 0xb8d2d0c8), new X64Word(0x1e376c08, 0x5141ab53), new X64Word(0x2748774c, 0xdf8eeb99), new X64Word(0x34b0bcb5, 0xe19b48a8), new X64Word(0x391c0cb3, 0xc5c95a63), new X64Word(0x4ed8aa4a, 0xe3418acb), new X64Word(0x5b9cca4f, 0x7763e373), new X64Word(0x682e6ff3, 0xd6b2b8a3), new X64Word(0x748f82ee, 0x5defb2fc), new X64Word(0x78a5636f, 0x43172f60), new X64Word(0x84c87814, 0xa1f0ab72), new X64Word(0x8cc70208, 0x1a6439ec), new X64Word(0x90befffa, 0x23631e28), new X64Word(0xa4506ceb, 0xde82bde9), new X64Word(0xbef9a3f7, 0xb2c67915), new X64Word(0xc67178f2, 0xe372532b), new X64Word(0xca273ece, 0xea26619c), new X64Word(0xd186b8c7, 0x21c0c207), new X64Word(0xeada7dd6, 0xcde0eb1e), new X64Word(0xf57d4f7f, 0xee6ed178), new X64Word(0x06f067aa, 0x72176fba), new X64Word(0x0a637dc5, 0xa2c898a6), new X64Word(0x113f9804, 0xbef90dae), new X64Word(0x1b710b35, 0x131c471b), new X64Word(0x28db77f5, 0x23047d84), new X64Word(0x32caab7b, 0x40c72493), new X64Word(0x3c9ebe0a, 0x15c9bebc), new X64Word(0x431d67c4, 0x9c100d4c), new X64Word(0x4cc5d4be, 0xcb3e42b6), new X64Word(0x597f299c, 0xfc657e2a), new X64Word(0x5fcb6fab, 0x3ad6faec), new X64Word(0x6c44198c, 0x4a475817)]; // Reusable objects\n\nconst W$2 = [];\n\nfor (let i = 0; i < 80; i += 1) {\n  W$2[i] = new X64Word();\n}\n/**\n * SHA-512 hash algorithm.\n */\n\n\nclass SHA512Algo extends Hasher {\n  constructor() {\n    super();\n    this.blockSize = 1024 / 32;\n  }\n\n  _doReset() {\n    this._hash = new X64WordArray([new X64Word(0x6a09e667, 0xf3bcc908), new X64Word(0xbb67ae85, 0x84caa73b), new X64Word(0x3c6ef372, 0xfe94f82b), new X64Word(0xa54ff53a, 0x5f1d36f1), new X64Word(0x510e527f, 0xade682d1), new X64Word(0x9b05688c, 0x2b3e6c1f), new X64Word(0x1f83d9ab, 0xfb41bd6b), new X64Word(0x5be0cd19, 0x137e2179)]);\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const H = this._hash.words;\n    const H0 = H[0];\n    const H1 = H[1];\n    const H2 = H[2];\n    const H3 = H[3];\n    const H4 = H[4];\n    const H5 = H[5];\n    const H6 = H[6];\n    const H7 = H[7];\n    const H0h = H0.high;\n    let H0l = H0.low;\n    const H1h = H1.high;\n    let H1l = H1.low;\n    const H2h = H2.high;\n    let H2l = H2.low;\n    const H3h = H3.high;\n    let H3l = H3.low;\n    const H4h = H4.high;\n    let H4l = H4.low;\n    const H5h = H5.high;\n    let H5l = H5.low;\n    const H6h = H6.high;\n    let H6l = H6.low;\n    const H7h = H7.high;\n    let H7l = H7.low; // Working variables\n\n    let ah = H0h;\n    let al = H0l;\n    let bh = H1h;\n    let bl = H1l;\n    let ch = H2h;\n    let cl = H2l;\n    let dh = H3h;\n    let dl = H3l;\n    let eh = H4h;\n    let el = H4l;\n    let fh = H5h;\n    let fl = H5l;\n    let gh = H6h;\n    let gl = H6l;\n    let hh = H7h;\n    let hl = H7l; // Rounds\n\n    for (let i = 0; i < 80; i += 1) {\n      let Wil;\n      let Wih; // Shortcut\n\n      const Wi = W$2[i]; // Extend message\n\n      if (i < 16) {\n        Wi.high = M[offset + i * 2] | 0;\n        Wih = Wi.high;\n        Wi.low = M[offset + i * 2 + 1] | 0;\n        Wil = Wi.low;\n      } else {\n        // Gamma0\n        const gamma0x = W$2[i - 15];\n        const gamma0xh = gamma0x.high;\n        const gamma0xl = gamma0x.low;\n        const gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;\n        const gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25); // Gamma1\n\n        const gamma1x = W$2[i - 2];\n        const gamma1xh = gamma1x.high;\n        const gamma1xl = gamma1x.low;\n        const gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;\n        const gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n\n        const Wi7 = W$2[i - 7];\n        const Wi7h = Wi7.high;\n        const Wi7l = Wi7.low;\n        const Wi16 = W$2[i - 16];\n        const Wi16h = Wi16.high;\n        const Wi16l = Wi16.low;\n        Wil = gamma0l + Wi7l;\n        Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);\n        Wil += gamma1l;\n        Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);\n        Wil += Wi16l;\n        Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);\n        Wi.high = Wih;\n        Wi.low = Wil;\n      }\n\n      const chh = eh & fh ^ ~eh & gh;\n      const chl = el & fl ^ ~el & gl;\n      const majh = ah & bh ^ ah & ch ^ bh & ch;\n      const majl = al & bl ^ al & cl ^ bl & cl;\n      const sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);\n      const sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);\n      const sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);\n      const sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9); // t1 = h + sigma1 + ch + K[i] + W[i]\n\n      const Ki = K$1[i];\n      const Kih = Ki.high;\n      const Kil = Ki.low;\n      let t1l = hl + sigma1l;\n      let t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);\n      t1l += chl;\n      t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);\n      t1l += Kil;\n      t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);\n      t1l += Wil;\n      t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0); // t2 = sigma0 + maj\n\n      const t2l = sigma0l + majl;\n      const t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0); // Update working variables\n\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = dl + t1l | 0;\n      eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = t1l + t2l | 0;\n      ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;\n    } // Intermediate hash value\n\n\n    H0.low = H0l + al;\n    H0l = H0.low;\n    H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);\n    H1.low = H1l + bl;\n    H1l = H1.low;\n    H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);\n    H2.low = H2l + cl;\n    H2l = H2.low;\n    H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);\n    H3.low = H3l + dl;\n    H3l = H3.low;\n    H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);\n    H4.low = H4l + el;\n    H4l = H4.low;\n    H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);\n    H5.low = H5l + fl;\n    H5l = H5.low;\n    H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);\n    H6.low = H6l + gl;\n    H6l = H6.low;\n    H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);\n    H7.low = H7l + hl;\n    H7l = H7.low;\n    H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8; // Add padding\n\n    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n    dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4; // Hash final blocks\n\n    this._process(); // Convert hash to 32-bit word array before returning\n\n\n    const hash = this._hash.toX32(); // Return final computed hash\n\n\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n    return clone;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA512('message');\n *     var hash = CryptoJS.SHA512(wordArray);\n */\n\n\nconst SHA512 = Hasher._createHelper(SHA512Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA512(message, key);\n */\n\n\nconst HmacSHA512 = Hasher._createHmacHelper(SHA512Algo);\n/**\n * SHA-384 hash algorithm.\n */\n\n\nclass SHA384Algo extends SHA512Algo {\n  _doReset() {\n    this._hash = new X64WordArray([new X64Word(0xcbbb9d5d, 0xc1059ed8), new X64Word(0x629a292a, 0x367cd507), new X64Word(0x9159015a, 0x3070dd17), new X64Word(0x152fecd8, 0xf70e5939), new X64Word(0x67332667, 0xffc00b31), new X64Word(0x8eb44a87, 0x68581511), new X64Word(0xdb0c2e0d, 0x64f98fa7), new X64Word(0x47b5481d, 0xbefa4fa4)]);\n  }\n\n  _doFinalize() {\n    const hash = super._doFinalize.call(this);\n\n    hash.sigBytes -= 16;\n    return hash;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA384('message');\n *     var hash = CryptoJS.SHA384(wordArray);\n */\n\n\nconst SHA384 = SHA512Algo._createHelper(SHA384Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA384(message, key);\n */\n\n\nconst HmacSHA384 = SHA512Algo._createHmacHelper(SHA384Algo); // Constants tables\n\n\nconst RHO_OFFSETS = [];\nconst PI_INDEXES = [];\nconst ROUND_CONSTANTS = []; // Compute Constants\n// Compute rho offset constants\n\nlet _x = 1;\nlet _y = 0;\n\nfor (let t = 0; t < 24; t += 1) {\n  RHO_OFFSETS[_x + 5 * _y] = (t + 1) * (t + 2) / 2 % 64;\n  const newX = _y % 5;\n  const newY = (2 * _x + 3 * _y) % 5;\n  _x = newX;\n  _y = newY;\n} // Compute pi index constants\n\n\nfor (let x = 0; x < 5; x += 1) {\n  for (let y = 0; y < 5; y += 1) {\n    PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;\n  }\n} // Compute round constants\n\n\nlet LFSR = 0x01;\n\nfor (let i = 0; i < 24; i += 1) {\n  let roundConstantMsw = 0;\n  let roundConstantLsw = 0;\n\n  for (let j = 0; j < 7; j += 1) {\n    if (LFSR & 0x01) {\n      const bitPosition = (1 << j) - 1;\n\n      if (bitPosition < 32) {\n        roundConstantLsw ^= 1 << bitPosition;\n      } else\n        /* if (bitPosition >= 32) */\n        {\n          roundConstantMsw ^= 1 << bitPosition - 32;\n        }\n    } // Compute next LFSR\n\n\n    if (LFSR & 0x80) {\n      // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n      LFSR = LFSR << 1 ^ 0x71;\n    } else {\n      LFSR <<= 1;\n    }\n  }\n\n  ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n} // Reusable objects for temporary values\n\n\nconst T$1 = [];\n\nfor (let i = 0; i < 25; i += 1) {\n  T$1[i] = X64Word.create();\n}\n/**\n * SHA-3 hash algorithm.\n */\n\n\nclass SHA3Algo extends Hasher {\n  constructor(cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {number} outputLength\n     *   The desired number of bits in the output hash.\n     *   Only values permitted are: 224, 256, 384, 512.\n     *   Default: 512\n     */\n    super(Object.assign({\n      outputLength: 512\n    }, cfg));\n  }\n\n  _doReset() {\n    this._state = [];\n    const state = this._state;\n\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = new X64Word();\n    }\n\n    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const state = this._state;\n    const nBlockSizeLanes = this.blockSize / 2; // Absorb\n\n    for (let i = 0; i < nBlockSizeLanes; i += 1) {\n      // Shortcuts\n      let M2i = M[offset + 2 * i];\n      let M2i1 = M[offset + 2 * i + 1]; // Swap endian\n\n      M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;\n      M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00; // Absorb message into state\n\n      const lane = state[i];\n      lane.high ^= M2i1;\n      lane.low ^= M2i;\n    } // Rounds\n\n\n    for (let round = 0; round < 24; round += 1) {\n      // Theta\n      for (let x = 0; x < 5; x += 1) {\n        // Mix column lanes\n        let tMsw = 0;\n        let tLsw = 0;\n\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          tMsw ^= lane.high;\n          tLsw ^= lane.low;\n        } // Temporary values\n\n\n        const Tx = T$1[x];\n        Tx.high = tMsw;\n        Tx.low = tLsw;\n      }\n\n      for (let x = 0; x < 5; x += 1) {\n        // Shortcuts\n        const Tx4 = T$1[(x + 4) % 5];\n        const Tx1 = T$1[(x + 1) % 5];\n        const Tx1Msw = Tx1.high;\n        const Tx1Lsw = Tx1.low; // Mix surrounding columns\n\n        const tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);\n        const tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);\n\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          lane.high ^= tMsw;\n          lane.low ^= tLsw;\n        }\n      } // Rho Pi\n\n\n      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n        let tMsw;\n        let tLsw; // Shortcuts\n\n        const lane = state[laneIndex];\n        const laneMsw = lane.high;\n        const laneLsw = lane.low;\n        const rhoOffset = RHO_OFFSETS[laneIndex]; // Rotate lanes\n\n        if (rhoOffset < 32) {\n          tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;\n          tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;\n        } else\n          /* if (rhoOffset >= 32) */\n          {\n            tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;\n            tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;\n          } // Transpose lanes\n\n\n        const TPiLane = T$1[PI_INDEXES[laneIndex]];\n        TPiLane.high = tMsw;\n        TPiLane.low = tLsw;\n      } // Rho pi at x = y = 0\n\n\n      const T0 = T$1[0];\n      const state0 = state[0];\n      T0.high = state0.high;\n      T0.low = state0.low; // Chi\n\n      for (let x = 0; x < 5; x += 1) {\n        for (let y = 0; y < 5; y += 1) {\n          // Shortcuts\n          const laneIndex = x + 5 * y;\n          const lane = state[laneIndex];\n          const TLane = T$1[laneIndex];\n          const Tx1Lane = T$1[(x + 1) % 5 + 5 * y];\n          const Tx2Lane = T$1[(x + 2) % 5 + 5 * y]; // Mix rows\n\n          lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;\n          lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;\n        }\n      } // Iota\n\n\n      const lane = state[0];\n      const roundConstant = ROUND_CONSTANTS[round];\n      lane.high ^= roundConstant.high;\n      lane.low ^= roundConstant.low;\n    }\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsLeft = data.sigBytes * 8;\n    const blockSizeBits = this.blockSize * 32; // Add padding\n\n    dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;\n    dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;\n    data.sigBytes = dataWords.length * 4; // Hash final blocks\n\n    this._process(); // Shortcuts\n\n\n    const state = this._state;\n    const outputLengthBytes = this.cfg.outputLength / 8;\n    const outputLengthLanes = outputLengthBytes / 8; // Squeeze\n\n    const hashWords = [];\n\n    for (let i = 0; i < outputLengthLanes; i += 1) {\n      // Shortcuts\n      const lane = state[i];\n      let laneMsw = lane.high;\n      let laneLsw = lane.low; // Swap endian\n\n      laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;\n      laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00; // Squeeze state to retrieve hash\n\n      hashWords.push(laneLsw);\n      hashWords.push(laneMsw);\n    } // Return final computed hash\n\n\n    return new WordArray(hashWords, outputLengthBytes);\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._state = this._state.slice(0);\n    const state = clone._state;\n\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = state[i].clone();\n    }\n\n    return clone;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA3('message');\n *     var hash = CryptoJS.SHA3(wordArray);\n */\n\n\nconst SHA3 = Hasher._createHelper(SHA3Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA3(message, key);\n */\n\n\nconst HmacSHA3 = Hasher._createHmacHelper(SHA3Algo);\n/** @preserve\n(c) 2012 by Cédric Mesnil. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n    - Redistributions of source code must retain the above copyright notice, this list of\n    conditions and the following disclaimer.\n    - Redistributions in binary form must reproduce the above copyright notice, this list\n    of conditions and the following disclaimer in the documentation and/or other materials\n    provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\nWAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n// Constants table\n\n\nconst _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);\n\nconst _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);\n\nconst _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);\n\nconst _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);\n\nconst _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n\nconst _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\nconst f1 = (x, y, z) => x ^ y ^ z;\n\nconst f2 = (x, y, z) => x & y | ~x & z;\n\nconst f3 = (x, y, z) => (x | ~y) ^ z;\n\nconst f4 = (x, y, z) => x & z | y & ~z;\n\nconst f5 = (x, y, z) => x ^ (y | ~z);\n\nconst rotl = (x, n) => x << n | x >>> 32 - n;\n/**\n * RIPEMD160 hash algorithm.\n */\n\n\nclass RIPEMD160Algo extends Hasher {\n  _doReset() {\n    this._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M; // Swap endian\n\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = _M[offset_i]; // Swap\n\n      _M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;\n    } // Shortcut\n\n\n    const H = this._hash.words;\n    const hl = _hl.words;\n    const hr = _hr.words;\n    const zl = _zl.words;\n    const zr = _zr.words;\n    const sl = _sl.words;\n    const sr = _sr.words; // Working variables\n\n    let al = H[0];\n    let bl = H[1];\n    let cl = H[2];\n    let dl = H[3];\n    let el = H[4];\n    let ar = H[0];\n    let br = H[1];\n    let cr = H[2];\n    let dr = H[3];\n    let er = H[4]; // Computation\n\n    let t;\n\n    for (let i = 0; i < 80; i += 1) {\n      t = al + _M[offset + zl[i]] | 0;\n\n      if (i < 16) {\n        t += f1(bl, cl, dl) + hl[0];\n      } else if (i < 32) {\n        t += f2(bl, cl, dl) + hl[1];\n      } else if (i < 48) {\n        t += f3(bl, cl, dl) + hl[2];\n      } else if (i < 64) {\n        t += f4(bl, cl, dl) + hl[3];\n      } else {\n        // if (i<80) {\n        t += f5(bl, cl, dl) + hl[4];\n      }\n\n      t |= 0;\n      t = rotl(t, sl[i]);\n      t = t + el | 0;\n      al = el;\n      el = dl;\n      dl = rotl(cl, 10);\n      cl = bl;\n      bl = t;\n      t = ar + _M[offset + zr[i]] | 0;\n\n      if (i < 16) {\n        t += f5(br, cr, dr) + hr[0];\n      } else if (i < 32) {\n        t += f4(br, cr, dr) + hr[1];\n      } else if (i < 48) {\n        t += f3(br, cr, dr) + hr[2];\n      } else if (i < 64) {\n        t += f2(br, cr, dr) + hr[3];\n      } else {\n        // if (i<80) {\n        t += f1(br, cr, dr) + hr[4];\n      }\n\n      t |= 0;\n      t = rotl(t, sr[i]);\n      t = t + er | 0;\n      ar = er;\n      er = dr;\n      dr = rotl(cr, 10);\n      cr = br;\n      br = t;\n    } // Intermediate hash value\n\n\n    t = H[1] + cl + dr | 0;\n    H[1] = H[2] + dl + er | 0;\n    H[2] = H[3] + el + ar | 0;\n    H[3] = H[4] + al + br | 0;\n    H[4] = H[0] + bl + cr | 0;\n    H[0] = t;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8; // Add padding\n\n    dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;\n    data.sigBytes = (dataWords.length + 1) * 4; // Hash final blocks\n\n    this._process(); // Shortcuts\n\n\n    const hash = this._hash;\n    const H = hash.words; // Swap endian\n\n    for (let i = 0; i < 5; i += 1) {\n      // Shortcut\n      const H_i = H[i]; // Swap\n\n      H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;\n    } // Return final computed hash\n\n\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n    return clone;\n  }\n\n}\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.RIPEMD160('message');\n *     var hash = CryptoJS.RIPEMD160(wordArray);\n */\n\n\nconst RIPEMD160 = Hasher._createHelper(RIPEMD160Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n */\n\n\nconst HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160Algo);\n/**\n * Password-Based Key Derivation Function 2 algorithm.\n */\n\n\nclass PBKDF2Algo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.PBKDF2.create();\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hasher to use. Default: SHA1\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n\n    this.cfg = Object.assign(new Base(), {\n      keySize: 128 / 32,\n      hasher: SHA1Algo,\n      iterations: 1\n    }, cfg);\n  }\n  /**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n\n\n  compute(password, salt) {\n    // Shortcut\n    const {\n      cfg\n    } = this; // Init HMAC\n\n    const hmac = HMAC.create(cfg.hasher, password); // Initial values\n\n    const derivedKey = WordArray.create();\n    const blockIndex = WordArray.create([0x00000001]); // Shortcuts\n\n    const derivedKeyWords = derivedKey.words;\n    const blockIndexWords = blockIndex.words;\n    const {\n      keySize,\n      iterations\n    } = cfg; // Generate key\n\n    while (derivedKeyWords.length < keySize) {\n      const block = hmac.update(salt).finalize(blockIndex);\n      hmac.reset(); // Shortcuts\n\n      const blockWords = block.words;\n      const blockWordsLength = blockWords.length; // Iterations\n\n      let intermediate = block;\n\n      for (let i = 1; i < iterations; i += 1) {\n        intermediate = hmac.finalize(intermediate);\n        hmac.reset(); // Shortcut\n\n        const intermediateWords = intermediate.words; // XOR intermediate with block\n\n        for (let j = 0; j < blockWordsLength; j += 1) {\n          blockWords[j] ^= intermediateWords[j];\n        }\n      }\n\n      derivedKey.concat(block);\n      blockIndexWords[0] += 1;\n    }\n\n    derivedKey.sigBytes = keySize * 4;\n    return derivedKey;\n  }\n\n}\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.PBKDF2(password, salt);\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n */\n\n\nconst PBKDF2 = (password, salt, cfg) => PBKDF2Algo.create(cfg).compute(password, salt); // Lookup tables\n\n\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = []; // Compute lookup tables\n// Compute double table\n\nconst d = [];\n\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = i << 1 ^ 0x11b;\n  }\n} // Walk GF(2^8)\n\n\nlet x = 0;\nlet xi = 0;\n\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n  sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x; // Compute multiplication\n\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4]; // Compute sub bytes, mix columns tables\n\n  let t = d[sx] * 0x101 ^ sx * 0x1010100;\n  _SUB_MIX_0[x] = t << 24 | t >>> 8;\n  _SUB_MIX_1[x] = t << 16 | t >>> 16;\n  _SUB_MIX_2[x] = t << 8 | t >>> 24;\n  _SUB_MIX_3[x] = t; // Compute inv sub bytes, inv mix columns tables\n\n  t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n  INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;\n  INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;\n  INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;\n  INV_SUB_MIX_3[sx] = t; // Compute next counter\n\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n} // Precomputed Rcon lookup\n\n\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n/**\n * AES block cipher algorithm.\n */\n\nclass AESAlgo extends BlockCipher {\n  constructor(...args) {\n    super(...args);\n    this.keySize = 256 / 32;\n  }\n\n  _doReset() {\n    let t; // Skip reset of nRounds has been set before and key did not change\n\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    } // Shortcuts\n\n\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4; // Compute number of rounds\n\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds; // Compute number of key schedule rows\n\n    const ksRows = (nRounds + 1) * 4; // Compute key schedule\n\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = t << 8 | t >>> 24; // Sub word\n\n          t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 0xff] << 16 | _SBOX[t >>> 8 & 0xff] << 8 | _SBOX[t & 0xff]; // Mix Rcon\n\n          t ^= RCON[ksRow / keySize | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 0xff] << 16 | _SBOX[t >>> 8 & 0xff] << 8 | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    } // Compute inv key schedule\n\n\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]] ^ INV_SUB_MIX_1[_SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[_SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX);\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M; // Swap 2nd and 4th rows\n\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(_M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); // Inv swap 2nd and 4th rows\n\n\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M; // Shortcut\n\n    const nRounds = this._nRounds; // Get input, add round key\n\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3]; // Key schedule row counter\n\n    let ksRow = 4; // Rounds\n\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow];\n      ksRow += 1; // Update state\n\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    } // Shift rows, sub bytes, add round key\n\n\n    const t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow];\n    ksRow += 1; // Set output\n\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n\n}\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\n\n\nconst AES = BlockCipher._createHelper(AESAlgo); // Permuted Choice 1 constants\n\n\nconst PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]; // Permuted Choice 2 constants\n\nconst PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]; // Cumulative bit shift constants\n\nconst BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]; // SBOXes and round permutation constants\n\nconst SBOX_P = [{\n  0x0: 0x808200,\n  0x10000000: 0x8000,\n  0x20000000: 0x808002,\n  0x30000000: 0x2,\n  0x40000000: 0x200,\n  0x50000000: 0x808202,\n  0x60000000: 0x800202,\n  0x70000000: 0x800000,\n  0x80000000: 0x202,\n  0x90000000: 0x800200,\n  0xa0000000: 0x8200,\n  0xb0000000: 0x808000,\n  0xc0000000: 0x8002,\n  0xd0000000: 0x800002,\n  0xe0000000: 0x0,\n  0xf0000000: 0x8202,\n  0x8000000: 0x0,\n  0x18000000: 0x808202,\n  0x28000000: 0x8202,\n  0x38000000: 0x8000,\n  0x48000000: 0x808200,\n  0x58000000: 0x200,\n  0x68000000: 0x808002,\n  0x78000000: 0x2,\n  0x88000000: 0x800200,\n  0x98000000: 0x8200,\n  0xa8000000: 0x808000,\n  0xb8000000: 0x800202,\n  0xc8000000: 0x800002,\n  0xd8000000: 0x8002,\n  0xe8000000: 0x202,\n  0xf8000000: 0x800000,\n  0x1: 0x8000,\n  0x10000001: 0x2,\n  0x20000001: 0x808200,\n  0x30000001: 0x800000,\n  0x40000001: 0x808002,\n  0x50000001: 0x8200,\n  0x60000001: 0x200,\n  0x70000001: 0x800202,\n  0x80000001: 0x808202,\n  0x90000001: 0x808000,\n  0xa0000001: 0x800002,\n  0xb0000001: 0x8202,\n  0xc0000001: 0x202,\n  0xd0000001: 0x800200,\n  0xe0000001: 0x8002,\n  0xf0000001: 0x0,\n  0x8000001: 0x808202,\n  0x18000001: 0x808000,\n  0x28000001: 0x800000,\n  0x38000001: 0x200,\n  0x48000001: 0x8000,\n  0x58000001: 0x800002,\n  0x68000001: 0x2,\n  0x78000001: 0x8202,\n  0x88000001: 0x8002,\n  0x98000001: 0x800202,\n  0xa8000001: 0x202,\n  0xb8000001: 0x808200,\n  0xc8000001: 0x800200,\n  0xd8000001: 0x0,\n  0xe8000001: 0x8200,\n  0xf8000001: 0x808002\n}, {\n  0x0: 0x40084010,\n  0x1000000: 0x4000,\n  0x2000000: 0x80000,\n  0x3000000: 0x40080010,\n  0x4000000: 0x40000010,\n  0x5000000: 0x40084000,\n  0x6000000: 0x40004000,\n  0x7000000: 0x10,\n  0x8000000: 0x84000,\n  0x9000000: 0x40004010,\n  0xa000000: 0x40000000,\n  0xb000000: 0x84010,\n  0xc000000: 0x80010,\n  0xd000000: 0x0,\n  0xe000000: 0x4010,\n  0xf000000: 0x40080000,\n  0x800000: 0x40004000,\n  0x1800000: 0x84010,\n  0x2800000: 0x10,\n  0x3800000: 0x40004010,\n  0x4800000: 0x40084010,\n  0x5800000: 0x40000000,\n  0x6800000: 0x80000,\n  0x7800000: 0x40080010,\n  0x8800000: 0x80010,\n  0x9800000: 0x0,\n  0xa800000: 0x4000,\n  0xb800000: 0x40080000,\n  0xc800000: 0x40000010,\n  0xd800000: 0x84000,\n  0xe800000: 0x40084000,\n  0xf800000: 0x4010,\n  0x10000000: 0x0,\n  0x11000000: 0x40080010,\n  0x12000000: 0x40004010,\n  0x13000000: 0x40084000,\n  0x14000000: 0x40080000,\n  0x15000000: 0x10,\n  0x16000000: 0x84010,\n  0x17000000: 0x4000,\n  0x18000000: 0x4010,\n  0x19000000: 0x80000,\n  0x1a000000: 0x80010,\n  0x1b000000: 0x40000010,\n  0x1c000000: 0x84000,\n  0x1d000000: 0x40004000,\n  0x1e000000: 0x40000000,\n  0x1f000000: 0x40084010,\n  0x10800000: 0x84010,\n  0x11800000: 0x80000,\n  0x12800000: 0x40080000,\n  0x13800000: 0x4000,\n  0x14800000: 0x40004000,\n  0x15800000: 0x40084010,\n  0x16800000: 0x10,\n  0x17800000: 0x40000000,\n  0x18800000: 0x40084000,\n  0x19800000: 0x40000010,\n  0x1a800000: 0x40004010,\n  0x1b800000: 0x80010,\n  0x1c800000: 0x0,\n  0x1d800000: 0x4010,\n  0x1e800000: 0x40080010,\n  0x1f800000: 0x84000\n}, {\n  0x0: 0x104,\n  0x100000: 0x0,\n  0x200000: 0x4000100,\n  0x300000: 0x10104,\n  0x400000: 0x10004,\n  0x500000: 0x4000004,\n  0x600000: 0x4010104,\n  0x700000: 0x4010000,\n  0x800000: 0x4000000,\n  0x900000: 0x4010100,\n  0xa00000: 0x10100,\n  0xb00000: 0x4010004,\n  0xc00000: 0x4000104,\n  0xd00000: 0x10000,\n  0xe00000: 0x4,\n  0xf00000: 0x100,\n  0x80000: 0x4010100,\n  0x180000: 0x4010004,\n  0x280000: 0x0,\n  0x380000: 0x4000100,\n  0x480000: 0x4000004,\n  0x580000: 0x10000,\n  0x680000: 0x10004,\n  0x780000: 0x104,\n  0x880000: 0x4,\n  0x980000: 0x100,\n  0xa80000: 0x4010000,\n  0xb80000: 0x10104,\n  0xc80000: 0x10100,\n  0xd80000: 0x4000104,\n  0xe80000: 0x4010104,\n  0xf80000: 0x4000000,\n  0x1000000: 0x4010100,\n  0x1100000: 0x10004,\n  0x1200000: 0x10000,\n  0x1300000: 0x4000100,\n  0x1400000: 0x100,\n  0x1500000: 0x4010104,\n  0x1600000: 0x4000004,\n  0x1700000: 0x0,\n  0x1800000: 0x4000104,\n  0x1900000: 0x4000000,\n  0x1a00000: 0x4,\n  0x1b00000: 0x10100,\n  0x1c00000: 0x4010000,\n  0x1d00000: 0x104,\n  0x1e00000: 0x10104,\n  0x1f00000: 0x4010004,\n  0x1080000: 0x4000000,\n  0x1180000: 0x104,\n  0x1280000: 0x4010100,\n  0x1380000: 0x0,\n  0x1480000: 0x10004,\n  0x1580000: 0x4000100,\n  0x1680000: 0x100,\n  0x1780000: 0x4010004,\n  0x1880000: 0x10000,\n  0x1980000: 0x4010104,\n  0x1a80000: 0x10104,\n  0x1b80000: 0x4000004,\n  0x1c80000: 0x4000104,\n  0x1d80000: 0x4010000,\n  0x1e80000: 0x4,\n  0x1f80000: 0x10100\n}, {\n  0x0: 0x80401000,\n  0x10000: 0x80001040,\n  0x20000: 0x401040,\n  0x30000: 0x80400000,\n  0x40000: 0x0,\n  0x50000: 0x401000,\n  0x60000: 0x80000040,\n  0x70000: 0x400040,\n  0x80000: 0x80000000,\n  0x90000: 0x400000,\n  0xa0000: 0x40,\n  0xb0000: 0x80001000,\n  0xc0000: 0x80400040,\n  0xd0000: 0x1040,\n  0xe0000: 0x1000,\n  0xf0000: 0x80401040,\n  0x8000: 0x80001040,\n  0x18000: 0x40,\n  0x28000: 0x80400040,\n  0x38000: 0x80001000,\n  0x48000: 0x401000,\n  0x58000: 0x80401040,\n  0x68000: 0x0,\n  0x78000: 0x80400000,\n  0x88000: 0x1000,\n  0x98000: 0x80401000,\n  0xa8000: 0x400000,\n  0xb8000: 0x1040,\n  0xc8000: 0x80000000,\n  0xd8000: 0x400040,\n  0xe8000: 0x401040,\n  0xf8000: 0x80000040,\n  0x100000: 0x400040,\n  0x110000: 0x401000,\n  0x120000: 0x80000040,\n  0x130000: 0x0,\n  0x140000: 0x1040,\n  0x150000: 0x80400040,\n  0x160000: 0x80401000,\n  0x170000: 0x80001040,\n  0x180000: 0x80401040,\n  0x190000: 0x80000000,\n  0x1a0000: 0x80400000,\n  0x1b0000: 0x401040,\n  0x1c0000: 0x80001000,\n  0x1d0000: 0x400000,\n  0x1e0000: 0x40,\n  0x1f0000: 0x1000,\n  0x108000: 0x80400000,\n  0x118000: 0x80401040,\n  0x128000: 0x0,\n  0x138000: 0x401000,\n  0x148000: 0x400040,\n  0x158000: 0x80000000,\n  0x168000: 0x80001040,\n  0x178000: 0x40,\n  0x188000: 0x80000040,\n  0x198000: 0x1000,\n  0x1a8000: 0x80001000,\n  0x1b8000: 0x80400040,\n  0x1c8000: 0x1040,\n  0x1d8000: 0x80401000,\n  0x1e8000: 0x400000,\n  0x1f8000: 0x401040\n}, {\n  0x0: 0x80,\n  0x1000: 0x1040000,\n  0x2000: 0x40000,\n  0x3000: 0x20000000,\n  0x4000: 0x20040080,\n  0x5000: 0x1000080,\n  0x6000: 0x21000080,\n  0x7000: 0x40080,\n  0x8000: 0x1000000,\n  0x9000: 0x20040000,\n  0xa000: 0x20000080,\n  0xb000: 0x21040080,\n  0xc000: 0x21040000,\n  0xd000: 0x0,\n  0xe000: 0x1040080,\n  0xf000: 0x21000000,\n  0x800: 0x1040080,\n  0x1800: 0x21000080,\n  0x2800: 0x80,\n  0x3800: 0x1040000,\n  0x4800: 0x40000,\n  0x5800: 0x20040080,\n  0x6800: 0x21040000,\n  0x7800: 0x20000000,\n  0x8800: 0x20040000,\n  0x9800: 0x0,\n  0xa800: 0x21040080,\n  0xb800: 0x1000080,\n  0xc800: 0x20000080,\n  0xd800: 0x21000000,\n  0xe800: 0x1000000,\n  0xf800: 0x40080,\n  0x10000: 0x40000,\n  0x11000: 0x80,\n  0x12000: 0x20000000,\n  0x13000: 0x21000080,\n  0x14000: 0x1000080,\n  0x15000: 0x21040000,\n  0x16000: 0x20040080,\n  0x17000: 0x1000000,\n  0x18000: 0x21040080,\n  0x19000: 0x21000000,\n  0x1a000: 0x1040000,\n  0x1b000: 0x20040000,\n  0x1c000: 0x40080,\n  0x1d000: 0x20000080,\n  0x1e000: 0x0,\n  0x1f000: 0x1040080,\n  0x10800: 0x21000080,\n  0x11800: 0x1000000,\n  0x12800: 0x1040000,\n  0x13800: 0x20040080,\n  0x14800: 0x20000000,\n  0x15800: 0x1040080,\n  0x16800: 0x80,\n  0x17800: 0x21040000,\n  0x18800: 0x40080,\n  0x19800: 0x21040080,\n  0x1a800: 0x0,\n  0x1b800: 0x21000000,\n  0x1c800: 0x1000080,\n  0x1d800: 0x40000,\n  0x1e800: 0x20040000,\n  0x1f800: 0x20000080\n}, {\n  0x0: 0x10000008,\n  0x100: 0x2000,\n  0x200: 0x10200000,\n  0x300: 0x10202008,\n  0x400: 0x10002000,\n  0x500: 0x200000,\n  0x600: 0x200008,\n  0x700: 0x10000000,\n  0x800: 0x0,\n  0x900: 0x10002008,\n  0xa00: 0x202000,\n  0xb00: 0x8,\n  0xc00: 0x10200008,\n  0xd00: 0x202008,\n  0xe00: 0x2008,\n  0xf00: 0x10202000,\n  0x80: 0x10200000,\n  0x180: 0x10202008,\n  0x280: 0x8,\n  0x380: 0x200000,\n  0x480: 0x202008,\n  0x580: 0x10000008,\n  0x680: 0x10002000,\n  0x780: 0x2008,\n  0x880: 0x200008,\n  0x980: 0x2000,\n  0xa80: 0x10002008,\n  0xb80: 0x10200008,\n  0xc80: 0x0,\n  0xd80: 0x10202000,\n  0xe80: 0x202000,\n  0xf80: 0x10000000,\n  0x1000: 0x10002000,\n  0x1100: 0x10200008,\n  0x1200: 0x10202008,\n  0x1300: 0x2008,\n  0x1400: 0x200000,\n  0x1500: 0x10000000,\n  0x1600: 0x10000008,\n  0x1700: 0x202000,\n  0x1800: 0x202008,\n  0x1900: 0x0,\n  0x1a00: 0x8,\n  0x1b00: 0x10200000,\n  0x1c00: 0x2000,\n  0x1d00: 0x10002008,\n  0x1e00: 0x10202000,\n  0x1f00: 0x200008,\n  0x1080: 0x8,\n  0x1180: 0x202000,\n  0x1280: 0x200000,\n  0x1380: 0x10000008,\n  0x1480: 0x10002000,\n  0x1580: 0x2008,\n  0x1680: 0x10202008,\n  0x1780: 0x10200000,\n  0x1880: 0x10202000,\n  0x1980: 0x10200008,\n  0x1a80: 0x2000,\n  0x1b80: 0x202008,\n  0x1c80: 0x200008,\n  0x1d80: 0x0,\n  0x1e80: 0x10000000,\n  0x1f80: 0x10002008\n}, {\n  0x0: 0x100000,\n  0x10: 0x2000401,\n  0x20: 0x400,\n  0x30: 0x100401,\n  0x40: 0x2100401,\n  0x50: 0x0,\n  0x60: 0x1,\n  0x70: 0x2100001,\n  0x80: 0x2000400,\n  0x90: 0x100001,\n  0xa0: 0x2000001,\n  0xb0: 0x2100400,\n  0xc0: 0x2100000,\n  0xd0: 0x401,\n  0xe0: 0x100400,\n  0xf0: 0x2000000,\n  0x8: 0x2100001,\n  0x18: 0x0,\n  0x28: 0x2000401,\n  0x38: 0x2100400,\n  0x48: 0x100000,\n  0x58: 0x2000001,\n  0x68: 0x2000000,\n  0x78: 0x401,\n  0x88: 0x100401,\n  0x98: 0x2000400,\n  0xa8: 0x2100000,\n  0xb8: 0x100001,\n  0xc8: 0x400,\n  0xd8: 0x2100401,\n  0xe8: 0x1,\n  0xf8: 0x100400,\n  0x100: 0x2000000,\n  0x110: 0x100000,\n  0x120: 0x2000401,\n  0x130: 0x2100001,\n  0x140: 0x100001,\n  0x150: 0x2000400,\n  0x160: 0x2100400,\n  0x170: 0x100401,\n  0x180: 0x401,\n  0x190: 0x2100401,\n  0x1a0: 0x100400,\n  0x1b0: 0x1,\n  0x1c0: 0x0,\n  0x1d0: 0x2100000,\n  0x1e0: 0x2000001,\n  0x1f0: 0x400,\n  0x108: 0x100400,\n  0x118: 0x2000401,\n  0x128: 0x2100001,\n  0x138: 0x1,\n  0x148: 0x2000000,\n  0x158: 0x100000,\n  0x168: 0x401,\n  0x178: 0x2100400,\n  0x188: 0x2000001,\n  0x198: 0x2100000,\n  0x1a8: 0x0,\n  0x1b8: 0x2100401,\n  0x1c8: 0x100401,\n  0x1d8: 0x400,\n  0x1e8: 0x2000400,\n  0x1f8: 0x100001\n}, {\n  0x0: 0x8000820,\n  0x1: 0x20000,\n  0x2: 0x8000000,\n  0x3: 0x20,\n  0x4: 0x20020,\n  0x5: 0x8020820,\n  0x6: 0x8020800,\n  0x7: 0x800,\n  0x8: 0x8020000,\n  0x9: 0x8000800,\n  0xa: 0x20800,\n  0xb: 0x8020020,\n  0xc: 0x820,\n  0xd: 0x0,\n  0xe: 0x8000020,\n  0xf: 0x20820,\n  0x80000000: 0x800,\n  0x80000001: 0x8020820,\n  0x80000002: 0x8000820,\n  0x80000003: 0x8000000,\n  0x80000004: 0x8020000,\n  0x80000005: 0x20800,\n  0x80000006: 0x20820,\n  0x80000007: 0x20,\n  0x80000008: 0x8000020,\n  0x80000009: 0x820,\n  0x8000000a: 0x20020,\n  0x8000000b: 0x8020800,\n  0x8000000c: 0x0,\n  0x8000000d: 0x8020020,\n  0x8000000e: 0x8000800,\n  0x8000000f: 0x20000,\n  0x10: 0x20820,\n  0x11: 0x8020800,\n  0x12: 0x20,\n  0x13: 0x800,\n  0x14: 0x8000800,\n  0x15: 0x8000020,\n  0x16: 0x8020020,\n  0x17: 0x20000,\n  0x18: 0x0,\n  0x19: 0x20020,\n  0x1a: 0x8020000,\n  0x1b: 0x8000820,\n  0x1c: 0x8020820,\n  0x1d: 0x20800,\n  0x1e: 0x820,\n  0x1f: 0x8000000,\n  0x80000010: 0x20000,\n  0x80000011: 0x800,\n  0x80000012: 0x8020020,\n  0x80000013: 0x20820,\n  0x80000014: 0x20,\n  0x80000015: 0x8020000,\n  0x80000016: 0x8000000,\n  0x80000017: 0x8000820,\n  0x80000018: 0x8020820,\n  0x80000019: 0x8000020,\n  0x8000001a: 0x8000800,\n  0x8000001b: 0x0,\n  0x8000001c: 0x20800,\n  0x8000001d: 0x820,\n  0x8000001e: 0x20020,\n  0x8000001f: 0x8020800\n}]; // Masks that select the SBOX input\n\nconst SBOX_MASK = [0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000, 0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f]; // Swap bits across the left and right words\n\nfunction exchangeLR(offset, mask) {\n  const t = (this._lBlock >>> offset ^ this._rBlock) & mask;\n  this._rBlock ^= t;\n  this._lBlock ^= t << offset;\n}\n\nfunction exchangeRL(offset, mask) {\n  const t = (this._rBlock >>> offset ^ this._lBlock) & mask;\n  this._lBlock ^= t;\n  this._rBlock ^= t << offset;\n}\n/**\n * DES block cipher algorithm.\n */\n\n\nclass DESAlgo extends BlockCipher {\n  constructor(...args) {\n    super(...args);\n    this.keySize = 64 / 32;\n    this.ivSize = 64 / 32;\n    this.blockSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words; // Select 56 bits according to PC1\n\n    const keyBits = [];\n\n    for (let i = 0; i < 56; i += 1) {\n      const keyBitPos = PC1[i] - 1;\n      keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;\n    } // Assemble 16 subkeys\n\n\n    this._subKeys = [];\n    const subKeys = this._subKeys;\n\n    for (let nSubKey = 0; nSubKey < 16; nSubKey += 1) {\n      // Create subkey\n      subKeys[nSubKey] = [];\n      const subKey = subKeys[nSubKey]; // Shortcut\n\n      const bitShift = BIT_SHIFTS[nSubKey]; // Select 48 bits according to PC2\n\n      for (let i = 0; i < 24; i += 1) {\n        // Select from the left 28 key bits\n        subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6; // Select from the right 28 key bits\n\n        subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;\n      } // Since each subkey is applied to an expanded 32-bit input,\n      // the subkey can be broken into 8 values scaled to 32-bits,\n      // which allows the key to be used without expansion\n\n\n      subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;\n\n      for (let i = 1; i < 7; i += 1) {\n        subKey[i] >>>= (i - 1) * 4 + 3;\n      }\n\n      subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;\n    } // Compute inverse subkeys\n\n\n    this._invSubKeys = [];\n    const invSubKeys = this._invSubKeys;\n\n    for (let i = 0; i < 16; i += 1) {\n      invSubKeys[i] = subKeys[15 - i];\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(M, offset, this._subKeys);\n  }\n\n  decryptBlock(M, offset) {\n    this._doCryptBlock(M, offset, this._invSubKeys);\n  }\n\n  _doCryptBlock(M, offset, subKeys) {\n    const _M = M; // Get input\n\n    this._lBlock = M[offset];\n    this._rBlock = M[offset + 1]; // Initial permutation\n\n    exchangeLR.call(this, 4, 0x0f0f0f0f);\n    exchangeLR.call(this, 16, 0x0000ffff);\n    exchangeRL.call(this, 2, 0x33333333);\n    exchangeRL.call(this, 8, 0x00ff00ff);\n    exchangeLR.call(this, 1, 0x55555555); // Rounds\n\n    for (let round = 0; round < 16; round += 1) {\n      // Shortcuts\n      const subKey = subKeys[round];\n      const lBlock = this._lBlock;\n      const rBlock = this._rBlock; // Feistel function\n\n      let f = 0;\n\n      for (let i = 0; i < 8; i += 1) {\n        f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n      }\n\n      this._lBlock = rBlock;\n      this._rBlock = lBlock ^ f;\n    } // Undo swap from last round\n\n\n    const t = this._lBlock;\n    this._lBlock = this._rBlock;\n    this._rBlock = t; // Final permutation\n\n    exchangeLR.call(this, 1, 0x55555555);\n    exchangeRL.call(this, 8, 0x00ff00ff);\n    exchangeRL.call(this, 2, 0x33333333);\n    exchangeLR.call(this, 16, 0x0000ffff);\n    exchangeLR.call(this, 4, 0x0f0f0f0f); // Set output\n\n    _M[offset] = this._lBlock;\n    _M[offset + 1] = this._rBlock;\n  }\n\n}\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n */\n\n\nconst DES = BlockCipher._createHelper(DESAlgo);\n/**\n * Triple-DES block cipher algorithm.\n */\n\n\nclass TripleDESAlgo extends BlockCipher {\n  constructor(...args) {\n    super(...args);\n    this.keySize = 192 / 32;\n    this.ivSize = 64 / 32;\n    this.blockSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words; // Create DES instances\n\n    this._des1 = DESAlgo.createEncryptor(WordArray.create(keyWords.slice(0, 2)));\n    this._des2 = DESAlgo.createEncryptor(WordArray.create(keyWords.slice(2, 4)));\n    this._des3 = DESAlgo.createEncryptor(WordArray.create(keyWords.slice(4, 6)));\n  }\n\n  encryptBlock(M, offset) {\n    this._des1.encryptBlock(M, offset);\n\n    this._des2.decryptBlock(M, offset);\n\n    this._des3.encryptBlock(M, offset);\n  }\n\n  decryptBlock(M, offset) {\n    this._des3.decryptBlock(M, offset);\n\n    this._des2.encryptBlock(M, offset);\n\n    this._des1.decryptBlock(M, offset);\n  }\n\n}\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n */\n\n\nconst TripleDES = BlockCipher._createHelper(TripleDESAlgo); // Reusable objects\n\n\nconst S = [];\nconst C_ = [];\nconst G = [];\n\nfunction nextState() {\n  // Shortcuts\n  const X = this._X;\n  const C = this._C; // Save old counter values\n\n  for (let i = 0; i < 8; i += 1) {\n    C_[i] = C[i];\n  } // Calculate new counter values\n\n\n  C[0] = C[0] + 0x4d34d34d + this._b | 0;\n  C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;\n  C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;\n  C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;\n  C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;\n  C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;\n  C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;\n  C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;\n  this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0; // Calculate the g-values\n\n  for (let i = 0; i < 8; i += 1) {\n    const gx = X[i] + C[i]; // Construct high and low argument for squaring\n\n    const ga = gx & 0xffff;\n    const gb = gx >>> 16; // Calculate high and low result of squaring\n\n    const gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;\n    const gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0); // High XOR low\n\n    G[i] = gh ^ gl;\n  } // Calculate new state values\n\n\n  X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;\n  X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;\n  X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;\n  X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;\n  X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;\n  X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;\n  X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;\n  X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;\n}\n/**\n * Rabbit stream cipher algorithm\n */\n\n\nclass RabbitAlgo extends StreamCipher {\n  constructor(...args) {\n    super(...args);\n    this.blockSize = 128 / 32;\n    this.ivSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const K = this._key.words;\n    const {\n      iv\n    } = this.cfg; // Swap endian\n\n    for (let i = 0; i < 4; i += 1) {\n      K[i] = (K[i] << 8 | K[i] >>> 24) & 0x00ff00ff | (K[i] << 24 | K[i] >>> 8) & 0xff00ff00;\n    } // Generate initial state values\n\n\n    this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];\n    const X = this._X; // Generate initial counter values\n\n    this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff];\n    const C = this._C; // Carry bit\n\n    this._b = 0; // Iterate the system four times\n\n    for (let i = 0; i < 4; i += 1) {\n      nextState.call(this);\n    } // Modify the counters\n\n\n    for (let i = 0; i < 8; i += 1) {\n      C[i] ^= X[i + 4 & 7];\n    } // IV setup\n\n\n    if (iv) {\n      // Shortcuts\n      const IV = iv.words;\n      const IV_0 = IV[0];\n      const IV_1 = IV[1]; // Generate four subvectors\n\n      const i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;\n      const i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;\n      const i1 = i0 >>> 16 | i2 & 0xffff0000;\n      const i3 = i2 << 16 | i0 & 0x0000ffff; // Modify counter values\n\n      C[0] ^= i0;\n      C[1] ^= i1;\n      C[2] ^= i2;\n      C[3] ^= i3;\n      C[4] ^= i0;\n      C[5] ^= i1;\n      C[6] ^= i2;\n      C[7] ^= i3; // Iterate the system four times\n\n      for (let i = 0; i < 4; i += 1) {\n        nextState.call(this);\n      }\n    }\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M; // Shortcut\n\n    const X = this._X; // Iterate the system\n\n    nextState.call(this); // Generate four keystream words\n\n    S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;\n    S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;\n    S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;\n    S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;\n\n    for (let i = 0; i < 4; i += 1) {\n      // Swap endian\n      S[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00; // Encrypt\n\n      _M[offset + i] ^= S[i];\n    }\n  }\n\n}\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n */\n\n\nconst Rabbit = StreamCipher._createHelper(RabbitAlgo); // Reusable objects\n\n\nconst S$1 = [];\nconst C_$1 = [];\nconst G$1 = [];\n\nfunction nextState$1() {\n  // Shortcuts\n  const X = this._X;\n  const C = this._C; // Save old counter values\n\n  for (let i = 0; i < 8; i += 1) {\n    C_$1[i] = C[i];\n  } // Calculate new counter values\n\n\n  C[0] = C[0] + 0x4d34d34d + this._b | 0;\n  C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_$1[0] >>> 0 ? 1 : 0) | 0;\n  C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_$1[1] >>> 0 ? 1 : 0) | 0;\n  C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_$1[2] >>> 0 ? 1 : 0) | 0;\n  C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_$1[3] >>> 0 ? 1 : 0) | 0;\n  C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_$1[4] >>> 0 ? 1 : 0) | 0;\n  C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_$1[5] >>> 0 ? 1 : 0) | 0;\n  C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_$1[6] >>> 0 ? 1 : 0) | 0;\n  this._b = C[7] >>> 0 < C_$1[7] >>> 0 ? 1 : 0; // Calculate the g-values\n\n  for (let i = 0; i < 8; i += 1) {\n    const gx = X[i] + C[i]; // Construct high and low argument for squaring\n\n    const ga = gx & 0xffff;\n    const gb = gx >>> 16; // Calculate high and low result of squaring\n\n    const gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;\n    const gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0); // High XOR low\n\n    G$1[i] = gh ^ gl;\n  } // Calculate new state values\n\n\n  X[0] = G$1[0] + (G$1[7] << 16 | G$1[7] >>> 16) + (G$1[6] << 16 | G$1[6] >>> 16) | 0;\n  X[1] = G$1[1] + (G$1[0] << 8 | G$1[0] >>> 24) + G$1[7] | 0;\n  X[2] = G$1[2] + (G$1[1] << 16 | G$1[1] >>> 16) + (G$1[0] << 16 | G$1[0] >>> 16) | 0;\n  X[3] = G$1[3] + (G$1[2] << 8 | G$1[2] >>> 24) + G$1[1] | 0;\n  X[4] = G$1[4] + (G$1[3] << 16 | G$1[3] >>> 16) + (G$1[2] << 16 | G$1[2] >>> 16) | 0;\n  X[5] = G$1[5] + (G$1[4] << 8 | G$1[4] >>> 24) + G$1[3] | 0;\n  X[6] = G$1[6] + (G$1[5] << 16 | G$1[5] >>> 16) + (G$1[4] << 16 | G$1[4] >>> 16) | 0;\n  X[7] = G$1[7] + (G$1[6] << 8 | G$1[6] >>> 24) + G$1[5] | 0;\n}\n/**\n * Rabbit stream cipher algorithm.\n *\n * This is a legacy version that neglected to convert the key to little-endian.\n * This error doesn't affect the cipher's security,\n * but it does affect its compatibility with other implementations.\n */\n\n\nclass RabbitLegacyAlgo extends StreamCipher {\n  constructor(...args) {\n    super(...args);\n    this.blockSize = 128 / 32;\n    this.ivSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const K = this._key.words;\n    const {\n      iv\n    } = this.cfg; // Generate initial state values\n\n    this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];\n    const X = this._X; // Generate initial counter values\n\n    this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff];\n    const C = this._C; // Carry bit\n\n    this._b = 0; // Iterate the system four times\n\n    for (let i = 0; i < 4; i += 1) {\n      nextState$1.call(this);\n    } // Modify the counters\n\n\n    for (let i = 0; i < 8; i += 1) {\n      C[i] ^= X[i + 4 & 7];\n    } // IV setup\n\n\n    if (iv) {\n      // Shortcuts\n      const IV = iv.words;\n      const IV_0 = IV[0];\n      const IV_1 = IV[1]; // Generate four subvectors\n\n      const i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;\n      const i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;\n      const i1 = i0 >>> 16 | i2 & 0xffff0000;\n      const i3 = i2 << 16 | i0 & 0x0000ffff; // Modify counter values\n\n      C[0] ^= i0;\n      C[1] ^= i1;\n      C[2] ^= i2;\n      C[3] ^= i3;\n      C[4] ^= i0;\n      C[5] ^= i1;\n      C[6] ^= i2;\n      C[7] ^= i3; // Iterate the system four times\n\n      for (let i = 0; i < 4; i += 1) {\n        nextState$1.call(this);\n      }\n    }\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M; // Shortcut\n\n    const X = this._X; // Iterate the system\n\n    nextState$1.call(this); // Generate four keystream words\n\n    S$1[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;\n    S$1[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;\n    S$1[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;\n    S$1[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;\n\n    for (let i = 0; i < 4; i += 1) {\n      // Swap endian\n      S$1[i] = (S$1[i] << 8 | S$1[i] >>> 24) & 0x00ff00ff | (S$1[i] << 24 | S$1[i] >>> 8) & 0xff00ff00; // Encrypt\n\n      _M[offset + i] ^= S$1[i];\n    }\n  }\n\n}\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n */\n\n\nconst RabbitLegacy = StreamCipher._createHelper(RabbitLegacyAlgo);\n\nfunction generateKeystreamWord() {\n  // Shortcuts\n  const S = this._S;\n  let i = this._i;\n  let j = this._j; // Generate keystream word\n\n  let keystreamWord = 0;\n\n  for (let n = 0; n < 4; n += 1) {\n    i = (i + 1) % 256;\n    j = (j + S[i]) % 256; // Swap\n\n    const t = S[i];\n    S[i] = S[j];\n    S[j] = t;\n    keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;\n  } // Update counters\n\n\n  this._i = i;\n  this._j = j;\n  return keystreamWord;\n}\n/**\n * RC4 stream cipher algorithm.\n */\n\n\nclass RC4Algo extends StreamCipher {\n  constructor(...args) {\n    super(...args);\n    this.keySize = 256 / 32;\n    this.ivSize = 0;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words;\n    const keySigBytes = key.sigBytes; // Init sbox\n\n    this._S = [];\n    const S = this._S;\n\n    for (let i = 0; i < 256; i += 1) {\n      S[i] = i;\n    } // Key setup\n\n\n    for (let i = 0, j = 0; i < 256; i += 1) {\n      const keyByteIndex = i % keySigBytes;\n      const keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 0xff;\n      j = (j + S[i] + keyByte) % 256; // Swap\n\n      const t = S[i];\n      S[i] = S[j];\n      S[j] = t;\n    } // Counters\n\n\n    this._j = 0;\n    this._i = this._j;\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n    _M[offset] ^= generateKeystreamWord.call(this);\n  }\n\n}\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n */\n\n\nconst RC4 = StreamCipher._createHelper(RC4Algo);\n/**\n * Modified RC4 stream cipher algorithm.\n */\n\n\nclass RC4DropAlgo extends RC4Algo {\n  constructor(...args) {\n    super(...args);\n    /**\n     * Configuration options.\n     *\n     * @property {number} drop The number of keystream words to drop. Default 192\n     */\n\n    Object.assign(this.cfg, {\n      drop: 192\n    });\n  }\n\n  _doReset() {\n    super._doReset.call(this); // Drop\n\n\n    for (let i = this.cfg.drop; i > 0; i -= 1) {\n      generateKeystreamWord.call(this);\n    }\n  }\n\n}\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n */\n\n\nconst RC4Drop = StreamCipher._createHelper(RC4DropAlgo);\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  const _words = words;\n  let keystream; // Shortcut\n\n  const iv = this._iv; // Generate keystream\n\n  if (iv) {\n    keystream = iv.slice(0); // Remove IV for subsequent blocks\n\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n\n  cipher.encryptBlock(keystream, 0); // Encrypt\n\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n/**\n * Cipher Feedback block mode.\n */\n\n\nclass CFB extends BlockCipherMode {}\n\nCFB.Encryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher;\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // Remember this block to use with next block\n\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n\n};\nCFB.Decryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher; // Remember this block to use with next block\n\n    const thisBlock = words.slice(offset, offset + blockSize);\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // This block becomes the previous block\n\n    this._prevBlock = thisBlock;\n  }\n\n};\n/**\n * Counter block mode.\n */\n\nclass CTR extends BlockCipherMode {}\n\nCTR.Encryptor = class extends CTR {\n  processBlock(words, offset) {\n    const _words = words; // Shortcuts\n\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher;\n    const iv = this._iv;\n    let counter = this._counter; // Generate keystream\n\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter; // Remove IV for subsequent blocks\n\n      this._iv = undefined;\n    }\n\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0); // Increment counter\n\n    counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0; // Encrypt\n\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n\n};\nCTR.Decryptor = CTR.Encryptor;\n\nconst incWord = word => {\n  let _word = word;\n\n  if ((word >> 24 & 0xff) === 0xff) {\n    // overflow\n    let b1 = word >> 16 & 0xff;\n    let b2 = word >> 8 & 0xff;\n    let b3 = word & 0xff;\n\n    if (b1 === 0xff) {\n      // overflow b1\n      b1 = 0;\n\n      if (b2 === 0xff) {\n        b2 = 0;\n\n        if (b3 === 0xff) {\n          b3 = 0;\n        } else {\n          b3 += 1;\n        }\n      } else {\n        b2 += 1;\n      }\n    } else {\n      b1 += 1;\n    }\n\n    _word = 0;\n    _word += b1 << 16;\n    _word += b2 << 8;\n    _word += b3;\n  } else {\n    _word += 0x01 << 24;\n  }\n\n  return _word;\n};\n\nconst incCounter = counter => {\n  const _counter = counter;\n  _counter[0] = incWord(_counter[0]);\n\n  if (_counter[0] === 0) {\n    // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n    _counter[1] = incWord(_counter[1]);\n  }\n\n  return _counter;\n};\n/** @preserve\n * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n * derived from CryptoJS.mode.CTR\n * Jan Hruby jhruby.web@gmail.com\n */\n\n\nclass CTRGladman extends BlockCipherMode {}\n\nCTRGladman.Encryptor = class extends CTRGladman {\n  processBlock(words, offset) {\n    const _words = words; // Shortcuts\n\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher;\n    const iv = this._iv;\n    let counter = this._counter; // Generate keystream\n\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter; // Remove IV for subsequent blocks\n\n      this._iv = undefined;\n    }\n\n    incCounter(counter);\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0); // Encrypt\n\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n\n};\nCTRGladman.Decryptor = CTRGladman.Encryptor;\n/**\n * Electronic Codebook block mode.\n */\n\nclass ECB extends BlockCipherMode {}\n\nECB.Encryptor = class extends ECB {\n  processBlock(words, offset) {\n    this._cipher.encryptBlock(words, offset);\n  }\n\n};\nECB.Decryptor = class extends ECB {\n  processBlock(words, offset) {\n    this._cipher.decryptBlock(words, offset);\n  }\n\n};\n/**\n * Output Feedback block mode.\n */\n\nclass OFB extends BlockCipherMode {}\n\nOFB.Encryptor = class extends OFB {\n  processBlock(words, offset) {\n    const _words = words; // Shortcuts\n\n    const cipher = this._cipher;\n    const {\n      blockSize\n    } = cipher;\n    const iv = this._iv;\n    let keystream = this._keystream; // Generate keystream\n\n    if (iv) {\n      this._keystream = iv.slice(0);\n      keystream = this._keystream; // Remove IV for subsequent blocks\n\n      this._iv = undefined;\n    }\n\n    cipher.encryptBlock(keystream, 0); // Encrypt\n\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n\n};\nOFB.Decryptor = OFB.Encryptor;\n/**\n * ANSI X.923 padding strategy.\n */\n\nconst AnsiX923 = {\n  pad(data, blockSize) {\n    const _data = data; // Shortcuts\n\n    const dataSigBytes = _data.sigBytes;\n    const blockSizeBytes = blockSize * 4; // Count padding bytes\n\n    const nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes; // Compute last byte position\n\n    const lastBytePos = dataSigBytes + nPaddingBytes - 1; // Pad\n\n    _data.clamp();\n\n    _data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;\n    _data.sigBytes += nPaddingBytes;\n  },\n\n  unpad(data) {\n    const _data = data; // Get number of padding bytes from last byte\n\n    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 0xff; // Remove padding\n\n    _data.sigBytes -= nPaddingBytes;\n  }\n\n};\n/**\n * ISO 10126 padding strategy.\n */\n\nconst Iso10126 = {\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4; // Count padding bytes\n\n    const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Pad\n\n    data.concat(WordArray.random(nPaddingBytes - 1)).concat(WordArray.create([nPaddingBytes << 24], 1));\n  },\n\n  unpad(data) {\n    const _data = data; // Get number of padding bytes from last byte\n\n    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 0xff; // Remove padding\n\n    _data.sigBytes -= nPaddingBytes;\n  }\n\n};\n/**\n * Zero padding strategy.\n */\n\nconst ZeroPadding = {\n  pad(data, blockSize) {\n    const _data = data; // Shortcut\n\n    const blockSizeBytes = blockSize * 4; // Pad\n\n    _data.clamp();\n\n    _data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);\n  },\n\n  unpad(data) {\n    const _data = data; // Shortcut\n\n    const dataWords = _data.words; // Unpad\n\n    for (let i = _data.sigBytes - 1; i >= 0; i -= 1) {\n      if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff) {\n        _data.sigBytes = i + 1;\n        break;\n      }\n    }\n  }\n\n};\n/**\n * ISO/IEC 9797-1 Padding Method 2.\n */\n\nconst Iso97971 = {\n  pad(data, blockSize) {\n    // Add 0x80 byte\n    data.concat(WordArray.create([0x80000000], 1)); // Zero pad the rest\n\n    ZeroPadding.pad(data, blockSize);\n  },\n\n  unpad(data) {\n    const _data = data; // Remove zero padding\n\n    ZeroPadding.unpad(_data); // Remove one more byte -- the 0x80 byte\n\n    _data.sigBytes -= 1;\n  }\n\n};\n/**\n * A noop padding strategy.\n */\n\nconst NoPadding = {\n  pad() {},\n\n  unpad() {}\n\n};\nconst HexFormatter = {\n  /**\n   * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The hexadecimally encoded string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    return cipherParams.ciphertext.toString(Hex);\n  },\n\n  /**\n   * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n   *\n   * @param {string} input The hexadecimally encoded string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n   */\n  parse(input) {\n    const ciphertext = Hex.parse(input);\n    return CipherParams.create({\n      ciphertext\n    });\n  }\n\n};\nvar CryptoEs = {\n  lib: {\n    Base,\n    WordArray,\n    BufferedBlockAlgorithm,\n    Hasher,\n    Cipher,\n    StreamCipher,\n    BlockCipherMode,\n    BlockCipher,\n    CipherParams,\n    SerializableCipher,\n    PasswordBasedCipher\n  },\n  x64: {\n    Word: X64Word,\n    WordArray: X64WordArray\n  },\n  enc: {\n    Hex,\n    Latin1,\n    Utf8,\n    Utf16,\n    Utf16BE,\n    Utf16LE,\n    Base64\n  },\n  algo: {\n    HMAC,\n    MD5: MD5Algo,\n    SHA1: SHA1Algo,\n    SHA224: SHA224Algo,\n    SHA256: SHA256Algo,\n    SHA384: SHA384Algo,\n    SHA512: SHA512Algo,\n    SHA3: SHA3Algo,\n    RIPEMD160: RIPEMD160Algo,\n    PBKDF2: PBKDF2Algo,\n    EvpKDF: EvpKDFAlgo,\n    AES: AESAlgo,\n    DES: DESAlgo,\n    TripleDES: TripleDESAlgo,\n    Rabbit: RabbitAlgo,\n    RabbitLegacy: RabbitLegacyAlgo,\n    RC4: RC4Algo,\n    RC4Drop: RC4DropAlgo\n  },\n  mode: {\n    CBC,\n    CFB,\n    CTR,\n    CTRGladman,\n    ECB,\n    OFB\n  },\n  pad: {\n    Pkcs7,\n    AnsiX923,\n    Iso10126,\n    Iso97971,\n    NoPadding,\n    ZeroPadding\n  },\n  format: {\n    OpenSSL: OpenSSLFormatter,\n    Hex: HexFormatter\n  },\n  kdf: {\n    OpenSSL: OpenSSLKdf\n  },\n  MD5,\n  HmacMD5,\n  SHA1,\n  HmacSHA1,\n  SHA224,\n  HmacSHA224,\n  SHA256,\n  HmacSHA256,\n  SHA384,\n  HmacSHA384,\n  SHA512,\n  HmacSHA512,\n  SHA3,\n  HmacSHA3,\n  RIPEMD160,\n  HmacRIPEMD160,\n  PBKDF2,\n  EvpKDF,\n  AES,\n  DES,\n  TripleDES,\n  Rabbit,\n  RabbitLegacy,\n  RC4,\n  RC4Drop\n};\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'txDropped':\n        case 'txRequest':\n        case 'nsfFail':\n        case 'txRepeat':\n        case 'txAwaitingApproval':\n        case 'txConfirmReminder':\n        case 'txSendFail':\n        case 'txError':\n        case 'txUnderPriced':\n        case 'txPoolSimulation':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://docs.blocknative.com/notify-sdk#event-codes`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    off: function (eventCode) {\n      delete this.listeners[eventCode];\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nconst jsonPreserveUndefined = (k, v) => v === undefined ? 'undefined' : v;\n/**\r\n * Tests if LocalStorage may be used. Accounts for environments where\r\n * LocalStorage is not supported, as well as those where it is blocked.\r\n *\r\n * @returns `true` if LocalStorage is supported and accessible, `false` otherwise.\r\n */\n\n\nfunction isLocalStorageAvailable() {\n  const isSupported = typeof window !== 'undefined' && 'localStorage' in window;\n\n  if (isSupported) {\n    const testKey = '__testLocalStorage';\n\n    try {\n      window.localStorage.setItem(testKey, '1');\n      window.localStorage.removeItem(testKey);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this.watchedTransactions.push({\n    hash,\n    emitter\n  });\n  const transactionId = this._system === 'ethereum' ? {\n    hash\n  } : {\n    txid: hash\n  };\n  const transaction = { ...transactionId,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: newState,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n  const existingAddressWatcher = this.watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this.watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isFunction$1(x) {\n  return typeof x === 'function';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nvar config = {\n  Promise: undefined,\n\n  set useDeprecatedSynchronousErrorHandling(value) {\n    if (value) {\n      var error = /*@__PURE__*/new Error();\n      /*@__PURE__*/\n\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    }\n\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  }\n\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction hostReportError(err) {\n  setTimeout(function () {\n    throw err;\n  }, 0);\n}\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar empty = {\n  closed: true,\n  next: function (value) {},\n  error: function (err) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete: function () {}\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nvar isArray$1 = /*@__PURE__*/function () {\n  return Array.isArray || function (x) {\n    return x && typeof x.length === 'number';\n  };\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isObject$1(x) {\n  return x !== null && typeof x === 'object';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar UnsubscriptionErrorImpl = /*@__PURE__*/function () {\n  function UnsubscriptionErrorImpl(errors) {\n    Error.call(this);\n    this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) {\n      return i + 1 + \") \" + err.toString();\n    }).join('\\n  ') : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n    return this;\n  }\n\n  UnsubscriptionErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return UnsubscriptionErrorImpl;\n}();\n\nvar UnsubscriptionError = UnsubscriptionErrorImpl;\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */\n\nvar Subscription = /*@__PURE__*/function () {\n  function Subscription(unsubscribe) {\n    this.closed = false;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (unsubscribe) {\n      this._ctorUnsubscribe = true;\n      this._unsubscribe = unsubscribe;\n    }\n  }\n\n  Subscription.prototype.unsubscribe = function () {\n    var errors;\n\n    if (this.closed) {\n      return;\n    }\n\n    var _a = this,\n        _parentOrParents = _a._parentOrParents,\n        _ctorUnsubscribe = _a._ctorUnsubscribe,\n        _unsubscribe = _a._unsubscribe,\n        _subscriptions = _a._subscriptions;\n\n    this.closed = true;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (_parentOrParents instanceof Subscription) {\n      _parentOrParents.remove(this);\n    } else if (_parentOrParents !== null) {\n      for (var index = 0; index < _parentOrParents.length; ++index) {\n        var parent_1 = _parentOrParents[index];\n        parent_1.remove(this);\n      }\n    }\n\n    if (isFunction$1(_unsubscribe)) {\n      if (_ctorUnsubscribe) {\n        this._unsubscribe = undefined;\n      }\n\n      try {\n        _unsubscribe.call(this);\n      } catch (e) {\n        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n      }\n    }\n\n    if (isArray$1(_subscriptions)) {\n      var index = -1;\n      var len = _subscriptions.length;\n\n      while (++index < len) {\n        var sub = _subscriptions[index];\n\n        if (isObject$1(sub)) {\n          try {\n            sub.unsubscribe();\n          } catch (e) {\n            errors = errors || [];\n\n            if (e instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n            } else {\n              errors.push(e);\n            }\n          }\n        }\n      }\n    }\n\n    if (errors) {\n      throw new UnsubscriptionError(errors);\n    }\n  };\n\n  Subscription.prototype.add = function (teardown) {\n    var subscription = teardown;\n\n    if (!teardown) {\n      return Subscription.EMPTY;\n    }\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(teardown);\n\n      case 'object':\n        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (!(subscription instanceof Subscription)) {\n          var tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n\n        break;\n\n      default:\n        {\n          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n    }\n\n    var _parentOrParents = subscription._parentOrParents;\n\n    if (_parentOrParents === null) {\n      subscription._parentOrParents = this;\n    } else if (_parentOrParents instanceof Subscription) {\n      if (_parentOrParents === this) {\n        return subscription;\n      }\n\n      subscription._parentOrParents = [_parentOrParents, this];\n    } else if (_parentOrParents.indexOf(this) === -1) {\n      _parentOrParents.push(this);\n    } else {\n      return subscription;\n    }\n\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions === null) {\n      this._subscriptions = [subscription];\n    } else {\n      subscriptions.push(subscription);\n    }\n\n    return subscription;\n  };\n\n  Subscription.prototype.remove = function (subscription) {\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions) {\n      var subscriptionIndex = subscriptions.indexOf(subscription);\n\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  };\n\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n\n  return Subscription;\n}();\n\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);\n  }, []);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar rxSubscriber = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' ? /*@__PURE__*/Symbol('rxSubscriber') : '@@rxSubscriber_' + /*@__PURE__*/Math.random();\n}();\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar Subscriber = /*@__PURE__*/function (_super) {\n  __extends(Subscriber, _super);\n\n  function Subscriber(destinationOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this.syncErrorValue = null;\n    _this.syncErrorThrown = false;\n    _this.syncErrorThrowable = false;\n    _this.isStopped = false;\n\n    switch (arguments.length) {\n      case 0:\n        _this.destination = empty;\n        break;\n\n      case 1:\n        if (!destinationOrNext) {\n          _this.destination = empty;\n          break;\n        }\n\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            _this.destination = destinationOrNext;\n            destinationOrNext.add(_this);\n          } else {\n            _this.syncErrorThrowable = true;\n            _this.destination = new SafeSubscriber(_this, destinationOrNext);\n          }\n\n          break;\n        }\n\n      default:\n        _this.syncErrorThrowable = true;\n        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n        break;\n    }\n\n    return _this;\n  }\n\n  Subscriber.prototype[rxSubscriber] = function () {\n    return this;\n  };\n\n  Subscriber.create = function (next, error, complete) {\n    var subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  };\n\n  Subscriber.prototype.next = function (value) {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  };\n\n  Subscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n\n  Subscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.isStopped = true;\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._complete = function () {\n    this.destination.complete();\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._unsubscribeAndRecycle = function () {\n    var _parentOrParents = this._parentOrParents;\n    this._parentOrParents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parentOrParents = _parentOrParents;\n    return this;\n  };\n\n  return Subscriber;\n}(Subscription);\n\nvar SafeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this._parentSubscriber = _parentSubscriber;\n    var next;\n    var context = _this;\n\n    if (isFunction$1(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next;\n      error = observerOrNext.error;\n      complete = observerOrNext.complete;\n\n      if (observerOrNext !== empty) {\n        context = Object.create(observerOrNext);\n\n        if (isFunction$1(context.unsubscribe)) {\n          _this.add(context.unsubscribe.bind(context));\n        }\n\n        context.unsubscribe = _this.unsubscribe.bind(_this);\n      }\n    }\n\n    _this._context = context;\n    _this._next = next;\n    _this._error = error;\n    _this._complete = complete;\n    return _this;\n  }\n\n  SafeSubscriber.prototype.next = function (value) {\n    if (!this.isStopped && this._next) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.complete = function () {\n    var _this = this;\n\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._complete) {\n        var wrappedComplete = function () {\n          return _this._complete.call(_this._context);\n        };\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  SafeSubscriber.prototype._unsubscribe = function () {\n    var _parentSubscriber = this._parentSubscriber;\n    this._context = null;\n    this._parentSubscriber = null;\n\n    _parentSubscriber.unsubscribe();\n  };\n\n  return SafeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\n\n\nfunction canReportError(observer) {\n  while (observer) {\n    var _a = observer,\n        closed_1 = _a.closed,\n        destination = _a.destination,\n        isStopped = _a.isStopped;\n\n    if (closed_1 || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n\n  return true;\n}\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\n\n\nfunction toSubscriber(nextOrObserver, error, complete) {\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return nextOrObserver;\n    }\n\n    if (nextOrObserver[rxSubscriber]) {\n      return nextOrObserver[rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(empty);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar observable = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction identity(x) {\n  return x;\n}\n/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */\n\n\nfunction pipeFromArray(fns) {\n  if (fns.length === 0) {\n    return identity;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input) {\n    return fns.reduce(function (prev, fn) {\n      return fn(prev);\n    }, input);\n  };\n}\n/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\n\n\nvar Observable = /*@__PURE__*/function () {\n  function Observable(subscribe) {\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  Observable.prototype.lift = function (operator) {\n    var observable = new Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  };\n\n  Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n    var operator = this.operator;\n    var sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      sink.add(operator.call(sink, this.source));\n    } else {\n      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  };\n\n  Observable.prototype._trySubscribe = function (sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  };\n\n  Observable.prototype.forEach = function (next, promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var subscription;\n      subscription = _this.subscribe(function (value) {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    });\n  };\n\n  Observable.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n    return source && source.subscribe(subscriber);\n  };\n\n  Observable.prototype[observable] = function () {\n    return this;\n  };\n\n  Observable.prototype.pipe = function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipeFromArray(operations)(this);\n  };\n\n  Observable.prototype.toPromise = function (promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var value;\n\n      _this.subscribe(function (x) {\n        return value = x;\n      }, function (err) {\n        return reject(err);\n      }, function () {\n        return resolve(value);\n      });\n    });\n  };\n\n  Observable.create = function (subscribe) {\n    return new Observable(subscribe);\n  };\n\n  return Observable;\n}();\n\nfunction getPromiseCtor(promiseCtor) {\n  if (!promiseCtor) {\n    promiseCtor = Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar subscribeToArray = function (array) {\n  return function (subscriber) {\n    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n\n    subscriber.complete();\n  };\n};\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\n\n\nvar subscribeToPromise = function (promise) {\n  return function (subscriber) {\n    promise.then(function (value) {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    }, function (err) {\n      return subscriber.error(err);\n    }).then(null, hostReportError);\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction getSymbolIterator() {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator';\n  }\n\n  return Symbol.iterator;\n}\n\nvar iterator = /*@__PURE__*/getSymbolIterator();\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\nvar subscribeToIterable = function (iterable) {\n  return function (subscriber) {\n    var iterator$1 = iterable[iterator]();\n\n    do {\n      var item = void 0;\n\n      try {\n        item = iterator$1.next();\n      } catch (err) {\n        subscriber.error(err);\n        return subscriber;\n      }\n\n      if (item.done) {\n        subscriber.complete();\n        break;\n      }\n\n      subscriber.next(item.value);\n\n      if (subscriber.closed) {\n        break;\n      }\n    } while (true);\n\n    if (typeof iterator$1.return === 'function') {\n      subscriber.add(function () {\n        if (iterator$1.return) {\n          iterator$1.return();\n        }\n      });\n    }\n\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeToObservable = function (obj) {\n  return function (subscriber) {\n    var obs = obj[observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    } else {\n      return obs.subscribe(subscriber);\n    }\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar isArrayLike$1 = function (x) {\n  return x && typeof x.length === 'number' && typeof x !== 'function';\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isPromise(value) {\n  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeTo = function (result) {\n  if (!!result && typeof result[observable] === 'function') {\n    return subscribeToObservable(result);\n  } else if (isArrayLike$1(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result);\n  } else if (!!result && typeof result[iterator] === 'function') {\n    return subscribeToIterable(result);\n  } else {\n    var value = isObject$1(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */\n\n\nvar SimpleInnerSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleInnerSubscriber, _super);\n\n  function SimpleInnerSubscriber(parent) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    return _this;\n  }\n\n  SimpleInnerSubscriber.prototype._next = function (value) {\n    this.parent.notifyNext(value);\n  };\n\n  SimpleInnerSubscriber.prototype._error = function (error) {\n    this.parent.notifyError(error);\n    this.unsubscribe();\n  };\n\n  SimpleInnerSubscriber.prototype._complete = function () {\n    this.parent.notifyComplete();\n    this.unsubscribe();\n  };\n\n  return SimpleInnerSubscriber;\n}(Subscriber);\n\nvar SimpleOuterSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleOuterSubscriber, _super);\n\n  function SimpleOuterSubscriber() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {\n    this.destination.next(innerValue);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyComplete = function () {\n    this.destination.complete();\n  };\n\n  return SimpleOuterSubscriber;\n}(Subscriber);\n\nfunction innerSubscribe(result, innerSubscriber) {\n  if (innerSubscriber.closed) {\n    return undefined;\n  }\n\n  if (result instanceof Observable) {\n    return result.subscribe(innerSubscriber);\n  }\n\n  return subscribeTo(result)(innerSubscriber);\n}\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar Action = /*@__PURE__*/function (_super) {\n  __extends(Action, _super);\n\n  function Action(scheduler, work) {\n    return _super.call(this) || this;\n  }\n\n  Action.prototype.schedule = function (state, delay) {\n    return this;\n  };\n\n  return Action;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\n\n\nvar AsyncAction = /*@__PURE__*/function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    clearInterval(id);\n    return undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action);\n\nvar Scheduler = /*@__PURE__*/function () {\n  function Scheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    this.SchedulerAction = SchedulerAction;\n    this.now = now;\n  }\n\n  Scheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return new this.SchedulerAction(this, work).schedule(state, delay);\n  };\n\n  Scheduler.now = function () {\n    return Date.now();\n  };\n\n  return Scheduler;\n}();\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\n\n\nvar AsyncScheduler = /*@__PURE__*/function (_super) {\n  __extends(AsyncScheduler, _super);\n\n  function AsyncScheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    var _this = _super.call(this, SchedulerAction, function () {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    }) || this;\n\n    _this.actions = [];\n    _this.active = false;\n    _this.scheduled = undefined;\n    return _this;\n  }\n\n  AsyncScheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return _super.prototype.schedule.call(this, work, delay, state);\n    }\n  };\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler);\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar asyncScheduler = /*@__PURE__*/new AsyncScheduler(AsyncAction);\nvar async = asyncScheduler;\n/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\n\nfunction isNumeric(val) {\n  return !isArray$1(val) && val - parseFloat(val) + 1 >= 0;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isScheduler(value) {\n  return value && typeof value.schedule === 'function';\n}\n/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\n\n\nfunction timer(dueTime, periodOrScheduler, scheduler) {\n  if (dueTime === void 0) {\n    dueTime = 0;\n  }\n\n  var period = -1;\n\n  if (isNumeric(periodOrScheduler)) {\n    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n  } else if (isScheduler(periodOrScheduler)) {\n    scheduler = periodOrScheduler;\n  }\n\n  if (!isScheduler(scheduler)) {\n    scheduler = async;\n  }\n\n  return new Observable(function (subscriber) {\n    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();\n    return scheduler.schedule(dispatch, due, {\n      index: 0,\n      period: period,\n      subscriber: subscriber\n    });\n  });\n}\n\nfunction dispatch(state) {\n  var index = state.index,\n      period = state.period,\n      subscriber = state.subscriber;\n  subscriber.next(index);\n\n  if (subscriber.closed) {\n    return;\n  } else if (period === -1) {\n    return subscriber.complete();\n  }\n\n  state.index = index + 1;\n  this.schedule(state, period);\n}\n/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\n\n\nfunction scheduleArray(input, scheduler) {\n  return new Observable(function (subscriber) {\n    var sub = new Subscription();\n    var i = 0;\n    sub.add(scheduler.schedule(function () {\n      if (i === input.length) {\n        subscriber.complete();\n        return;\n      }\n\n      subscriber.next(input[i++]);\n\n      if (!subscriber.closed) {\n        sub.add(this.schedule());\n      }\n    }));\n    return sub;\n  });\n}\n/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */\n\n\nfunction fromArray(input, scheduler) {\n  if (!scheduler) {\n    return new Observable(subscribeToArray(input));\n  } else {\n    return scheduleArray(input, scheduler);\n  }\n}\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */\n\n\nfunction scheduleObservable(input, scheduler) {\n  return new Observable(function (subscriber) {\n    var sub = new Subscription();\n    sub.add(scheduler.schedule(function () {\n      var observable$1 = input[observable]();\n      sub.add(observable$1.subscribe({\n        next: function (value) {\n          sub.add(scheduler.schedule(function () {\n            return subscriber.next(value);\n          }));\n        },\n        error: function (err) {\n          sub.add(scheduler.schedule(function () {\n            return subscriber.error(err);\n          }));\n        },\n        complete: function () {\n          sub.add(scheduler.schedule(function () {\n            return subscriber.complete();\n          }));\n        }\n      }));\n    }));\n    return sub;\n  });\n}\n/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\n\n\nfunction schedulePromise(input, scheduler) {\n  return new Observable(function (subscriber) {\n    var sub = new Subscription();\n    sub.add(scheduler.schedule(function () {\n      return input.then(function (value) {\n        sub.add(scheduler.schedule(function () {\n          subscriber.next(value);\n          sub.add(scheduler.schedule(function () {\n            return subscriber.complete();\n          }));\n        }));\n      }, function (err) {\n        sub.add(scheduler.schedule(function () {\n          return subscriber.error(err);\n        }));\n      });\n    }));\n    return sub;\n  });\n}\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */\n\n\nfunction scheduleIterable(input, scheduler) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n\n  return new Observable(function (subscriber) {\n    var sub = new Subscription();\n    var iterator$1;\n    sub.add(function () {\n      if (iterator$1 && typeof iterator$1.return === 'function') {\n        iterator$1.return();\n      }\n    });\n    sub.add(scheduler.schedule(function () {\n      iterator$1 = input[iterator]();\n      sub.add(scheduler.schedule(function () {\n        if (subscriber.closed) {\n          return;\n        }\n\n        var value;\n        var done;\n\n        try {\n          var result = iterator$1.next();\n          value = result.value;\n          done = result.done;\n        } catch (err) {\n          subscriber.error(err);\n          return;\n        }\n\n        if (done) {\n          subscriber.complete();\n        } else {\n          subscriber.next(value);\n          this.schedule();\n        }\n      }));\n    }));\n    return sub;\n  });\n}\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\n\nfunction isInteropObservable(input) {\n  return input && typeof input[observable] === 'function';\n}\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\n\nfunction isIterable(input) {\n  return input && typeof input[iterator] === 'function';\n}\n/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */\n\n\nfunction scheduled(input, scheduler) {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    } else if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    } else if (isArrayLike$1(input)) {\n      return scheduleArray(input, scheduler);\n    } else if (isIterable(input) || typeof input === 'string') {\n      return scheduleIterable(input, scheduler);\n    }\n  }\n\n  throw new TypeError((input !== null && typeof input || input) + ' is not observable');\n}\n/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */\n\n\nfunction from(input, scheduler) {\n  if (!scheduler) {\n    if (input instanceof Observable) {\n      return input;\n    }\n\n    return new Observable(subscribeTo(input));\n  } else {\n    return scheduled(input, scheduler);\n  }\n}\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nfunction map(project, thisArg) {\n  return function mapOperation(source) {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nvar MapOperator = /*@__PURE__*/function () {\n  function MapOperator(project, thisArg) {\n    this.project = project;\n    this.thisArg = thisArg;\n  }\n\n  MapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  };\n\n  return MapOperator;\n}();\n\nvar MapSubscriber = /*@__PURE__*/function (_super) {\n  __extends(MapSubscriber, _super);\n\n  function MapSubscriber(destination, project, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.project = project;\n    _this.count = 0;\n    _this.thisArg = thisArg || _this;\n    return _this;\n  }\n\n  MapSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return MapSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */\n\n\nfunction mergeMap(project, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  if (typeof resultSelector === 'function') {\n    return function (source) {\n      return source.pipe(mergeMap(function (a, i) {\n        return from(project(a, i)).pipe(map(function (b, ii) {\n          return resultSelector(a, b, i, ii);\n        }));\n      }, concurrent));\n    };\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return function (source) {\n    return source.lift(new MergeMapOperator(project, concurrent));\n  };\n}\n\nvar MergeMapOperator = /*@__PURE__*/function () {\n  function MergeMapOperator(project, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n\n    this.project = project;\n    this.concurrent = concurrent;\n  }\n\n  MergeMapOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));\n  };\n\n  return MergeMapOperator;\n}();\n\nvar MergeMapSubscriber = /*@__PURE__*/function (_super) {\n  __extends(MergeMapSubscriber, _super);\n\n  function MergeMapSubscriber(destination, project, concurrent) {\n    if (concurrent === void 0) {\n      concurrent = Number.POSITIVE_INFINITY;\n    }\n\n    var _this = _super.call(this, destination) || this;\n\n    _this.project = project;\n    _this.concurrent = concurrent;\n    _this.hasCompleted = false;\n    _this.buffer = [];\n    _this.active = 0;\n    _this.index = 0;\n    return _this;\n  }\n\n  MergeMapSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  MergeMapSubscriber.prototype._tryNext = function (value) {\n    var result;\n    var index = this.index++;\n\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.active++;\n\n    this._innerSub(result);\n  };\n\n  MergeMapSubscriber.prototype._innerSub = function (ish) {\n    var innerSubscriber = new SimpleInnerSubscriber(this);\n    var destination = this.destination;\n    destination.add(innerSubscriber);\n    var innerSubscription = innerSubscribe(ish, innerSubscriber);\n\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  };\n\n  MergeMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n\n    this.unsubscribe();\n  };\n\n  MergeMapSubscriber.prototype.notifyNext = function (innerValue) {\n    this.destination.next(innerValue);\n  };\n\n  MergeMapSubscriber.prototype.notifyComplete = function () {\n    var buffer = this.buffer;\n    this.active--;\n\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return MergeMapSubscriber;\n}(SimpleOuterSubscriber);\n/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */\n\n\nfunction mergeAll(concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return mergeMap(identity, concurrent);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isDate(value) {\n  return value instanceof Date && !isNaN(+value);\n}\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nvar EMPTY = /*@__PURE__*/new Observable(function (subscriber) {\n  return subscriber.complete();\n});\n\nfunction empty$1(scheduler) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler) {\n  return new Observable(function (subscriber) {\n    return scheduler.schedule(function () {\n      return subscriber.complete();\n    });\n  });\n}\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nfunction throwError(error, scheduler) {\n  if (!scheduler) {\n    return new Observable(function (subscriber) {\n      return subscriber.error(error);\n    });\n  } else {\n    return new Observable(function (subscriber) {\n      return scheduler.schedule(dispatch$1, 0, {\n        error: error,\n        subscriber: subscriber\n      });\n    });\n  }\n}\n\nfunction dispatch$1(_a) {\n  var error = _a.error,\n      subscriber = _a.subscriber;\n  subscriber.error(error);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar ArgumentOutOfRangeErrorImpl = /*@__PURE__*/function () {\n  function ArgumentOutOfRangeErrorImpl() {\n    Error.call(this);\n    this.message = 'argument out of range';\n    this.name = 'ArgumentOutOfRangeError';\n    return this;\n  }\n\n  ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return ArgumentOutOfRangeErrorImpl;\n}();\n\nvar ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\nfunction filter(predicate, thisArg) {\n  return function filterOperatorFunction(source) {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nvar FilterOperator = /*@__PURE__*/function () {\n  function FilterOperator(predicate, thisArg) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n  }\n\n  FilterOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  };\n\n  return FilterOperator;\n}();\n\nvar FilterSubscriber = /*@__PURE__*/function (_super) {\n  __extends(FilterSubscriber, _super);\n\n  function FilterSubscriber(destination, predicate, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.thisArg = thisArg;\n    _this.count = 0;\n    return _this;\n  }\n\n  FilterSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.destination.next(value);\n    }\n  };\n\n  return FilterSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\n\n\nfunction take(count) {\n  return function (source) {\n    if (count === 0) {\n      return empty$1();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nvar TakeOperator = /*@__PURE__*/function () {\n  function TakeOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n\n  return TakeOperator;\n}();\n\nvar TakeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TakeSubscriber, _super);\n\n  function TakeSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n\n    if (count <= total) {\n      this.destination.next(value);\n\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n\n  return TakeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */\n\n\nfunction finalize(callback) {\n  return function (source) {\n    return source.lift(new FinallyOperator(callback));\n  };\n}\n\nvar FinallyOperator = /*@__PURE__*/function () {\n  function FinallyOperator(callback) {\n    this.callback = callback;\n  }\n\n  FinallyOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  };\n\n  return FinallyOperator;\n}();\n\nvar FinallySubscriber = /*@__PURE__*/function (_super) {\n  __extends(FinallySubscriber, _super);\n\n  function FinallySubscriber(destination, callback) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.add(new Subscription(callback));\n\n    return _this;\n  }\n\n  return FinallySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar ObjectUnsubscribedErrorImpl = /*@__PURE__*/function () {\n  function ObjectUnsubscribedErrorImpl() {\n    Error.call(this);\n    this.message = 'object unsubscribed';\n    this.name = 'ObjectUnsubscribedError';\n    return this;\n  }\n\n  ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return ObjectUnsubscribedErrorImpl;\n}();\n\nvar ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\nvar SubjectSubscription = /*@__PURE__*/function (_super) {\n  __extends(SubjectSubscription, _super);\n\n  function SubjectSubscription(subject, subscriber) {\n    var _this = _super.call(this) || this;\n\n    _this.subject = subject;\n    _this.subscriber = subscriber;\n    _this.closed = false;\n    return _this;\n  }\n\n  SubjectSubscription.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    var subject = this.subject;\n    var observers = subject.observers;\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    var subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  };\n\n  return SubjectSubscription;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\n\n\nvar SubjectSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SubjectSubscriber, _super);\n\n  function SubjectSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    return _this;\n  }\n\n  return SubjectSubscriber;\n}(Subscriber);\n\nvar Subject = /*@__PURE__*/function (_super) {\n  __extends(Subject, _super);\n\n  function Subject() {\n    var _this = _super.call(this) || this;\n\n    _this.observers = [];\n    _this.closed = false;\n    _this.isStopped = false;\n    _this.hasError = false;\n    _this.thrownError = null;\n    return _this;\n  }\n\n  Subject.prototype[rxSubscriber] = function () {\n    return new SubjectSubscriber(this);\n  };\n\n  Subject.prototype.lift = function (operator) {\n    var subject = new AnonymousSubject(this, this);\n    subject.operator = operator;\n    return subject;\n  };\n\n  Subject.prototype.next = function (value) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    if (!this.isStopped) {\n      var observers = this.observers;\n      var len = observers.length;\n      var copy = observers.slice();\n\n      for (var i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  };\n\n  Subject.prototype.error = function (err) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.complete = function () {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.unsubscribe = function () {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  };\n\n  Subject.prototype._trySubscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return _super.prototype._trySubscribe.call(this, subscriber);\n    }\n  };\n\n  Subject.prototype._subscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  };\n\n  Subject.prototype.asObservable = function () {\n    var observable = new Observable();\n    observable.source = this;\n    return observable;\n  };\n\n  Subject.create = function (destination, source) {\n    return new AnonymousSubject(destination, source);\n  };\n\n  return Subject;\n}(Observable);\n\nvar AnonymousSubject = /*@__PURE__*/function (_super) {\n  __extends(AnonymousSubject, _super);\n\n  function AnonymousSubject(destination, source) {\n    var _this = _super.call(this) || this;\n\n    _this.destination = destination;\n    _this.source = source;\n    return _this;\n  }\n\n  AnonymousSubject.prototype.next = function (value) {\n    var destination = this.destination;\n\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  };\n\n  AnonymousSubject.prototype.error = function (err) {\n    var destination = this.destination;\n\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  };\n\n  AnonymousSubject.prototype.complete = function () {\n    var destination = this.destination;\n\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  };\n\n  AnonymousSubject.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  };\n\n  return AnonymousSubject;\n}(Subject);\n/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */\n\n\nfunction merge() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i] = arguments[_i];\n  }\n\n  var concurrent = Number.POSITIVE_INFINITY;\n  var scheduler = null;\n  var last = observables[observables.length - 1];\n\n  if (isScheduler(last)) {\n    scheduler = observables.pop();\n\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return observables[0];\n  }\n\n  return mergeAll(concurrent)(fromArray(observables, scheduler));\n}\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nfunction takeWhile(predicate, inclusive) {\n  if (inclusive === void 0) {\n    inclusive = false;\n  }\n\n  return function (source) {\n    return source.lift(new TakeWhileOperator(predicate, inclusive));\n  };\n}\n\nvar TakeWhileOperator = /*@__PURE__*/function () {\n  function TakeWhileOperator(predicate, inclusive) {\n    this.predicate = predicate;\n    this.inclusive = inclusive;\n  }\n\n  TakeWhileOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n  };\n\n  return TakeWhileOperator;\n}();\n\nvar TakeWhileSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TakeWhileSubscriber, _super);\n\n  function TakeWhileSubscriber(destination, predicate, inclusive) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.inclusive = inclusive;\n    _this.index = 0;\n    return _this;\n  }\n\n  TakeWhileSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n    var result;\n\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this.nextOrComplete(value, result);\n  };\n\n  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n    var destination = this.destination;\n\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      if (this.inclusive) {\n        destination.next(value);\n      }\n\n      destination.complete();\n    }\n  };\n\n  return TakeWhileSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar TimeoutErrorImpl = /*@__PURE__*/function () {\n  function TimeoutErrorImpl() {\n    Error.call(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    return this;\n  }\n\n  TimeoutErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return TimeoutErrorImpl;\n}();\n\nvar TimeoutError = TimeoutErrorImpl;\n/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */\n\nfunction timeoutWith(due, withObservable, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    var absoluteTimeout = isDate(due);\n    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nvar TimeoutWithOperator = /*@__PURE__*/function () {\n  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n\n  TimeoutWithOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  };\n\n  return TimeoutWithOperator;\n}();\n\nvar TimeoutWithSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TimeoutWithSubscriber, _super);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.absoluteTimeout = absoluteTimeout;\n    _this.waitFor = waitFor;\n    _this.withObservable = withObservable;\n    _this.scheduler = scheduler;\n\n    _this.scheduleTimeout();\n\n    return _this;\n  }\n\n  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n    var withObservable = subscriber.withObservable;\n\n    subscriber._unsubscribeAndRecycle();\n\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  };\n\n  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutWithSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n\n  TimeoutWithSubscriber.prototype._unsubscribe = function () {\n    this.action = undefined;\n    this.scheduler = null;\n    this.withObservable = null;\n  };\n\n  return TimeoutWithSubscriber;\n}(SimpleOuterSubscriber);\n/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */\n\n\nfunction timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n\nlet urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';\nconst POOL_SIZE_MULTIPLIER = 128;\nlet pool, poolOffset;\n\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);\n    crypto.randomFillSync(pool);\n    poolOffset = 0;\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool);\n    poolOffset = 0;\n  }\n\n  poolOffset += bytes;\n};\n\nlet nanoid = (size = 21) => {\n  fillPool(size -= 0);\n  let id = '';\n\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += urlAlphabet[pool[i] & 63];\n  }\n\n  return id;\n};\n/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\n\n\nfunction fromEvent(target, eventName, options, resultSelector) {\n  if (isFunction$1(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n\n  if (resultSelector) {\n    return fromEvent(target, eventName, options).pipe(map(function (args) {\n      return isArray$1(args) ? resultSelector.apply(void 0, args) : resultSelector(args);\n    }));\n  }\n\n  return new Observable(function (subscriber) {\n    function handler(e) {\n      if (arguments.length > 1) {\n        subscriber.next(Array.prototype.slice.call(arguments));\n      } else {\n        subscriber.next(e);\n      }\n    }\n\n    setupSubscription(target, eventName, handler, subscriber, options);\n  });\n}\n\nfunction setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n  var unsubscribe;\n\n  if (isEventTarget(sourceObj)) {\n    var source_1 = sourceObj;\n    sourceObj.addEventListener(eventName, handler, options);\n\n    unsubscribe = function () {\n      return source_1.removeEventListener(eventName, handler, options);\n    };\n  } else if (isJQueryStyleEventEmitter(sourceObj)) {\n    var source_2 = sourceObj;\n    sourceObj.on(eventName, handler);\n\n    unsubscribe = function () {\n      return source_2.off(eventName, handler);\n    };\n  } else if (isNodeStyleEventEmitter(sourceObj)) {\n    var source_3 = sourceObj;\n    sourceObj.addListener(eventName, handler);\n\n    unsubscribe = function () {\n      return source_3.removeListener(eventName, handler);\n    };\n  } else if (sourceObj && sourceObj.length) {\n    for (var i = 0, len = sourceObj.length; i < len; i++) {\n      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n    }\n  } else {\n    throw new TypeError('Invalid event target');\n  }\n\n  subscriber.add(unsubscribe);\n}\n\nfunction isNodeStyleEventEmitter(sourceObj) {\n  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nfunction isJQueryStyleEventEmitter(sourceObj) {\n  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isEventTarget(sourceObj) {\n  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n\nconst simulations$ = new Subject();\n\nfunction simulate(system, network, transaction) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const id = nanoid(); // send payload to server\n\n  this._sendMessage({\n    categoryCode: 'simulate',\n    eventCode: 'txSimulation',\n    eventId: id,\n    transaction: transaction\n  });\n\n  return new Promise((resolve, reject) => {\n    simulations$.pipe(filter(({\n      eventId\n    }) => {\n      return eventId === id;\n    }), take(1)).subscribe({\n      next: ({\n        transaction\n      }) => resolve(transaction),\n      error: ({\n        error\n      }) => reject(error.message)\n    });\n  });\n}\n\nfunction multiSim(transactions) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const id = nanoid(); // send payload to server\n\n  this._sendMessage({\n    categoryCode: 'simulate',\n    eventCode: 'txSimulation',\n    eventId: id,\n    transaction: transactions\n  });\n\n  return new Promise((resolve, reject) => {\n    simulations$.pipe(filter(({\n      eventId\n    }) => {\n      return eventId === id;\n    }), take(1)).subscribe({\n      next: ({\n        transaction\n      }) => resolve(transaction),\n      error: ({\n        error\n      }) => reject(error.message)\n    });\n  });\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this.watchedAccounts = this.watchedAccounts.filter(ac => ac.address !== normalizedAddress); // remove configuration from memory\n\n    this.configurations.delete(normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this.watchedTransactions = this.watchedTransactions.filter(tx => tx.hash !== addressOrHash);\n    const transactionId = this._system === 'ethereum' ? {\n      hash: addressOrHash\n    } : {\n      txid: addressOrHash\n    };\n    const transaction = { ...transactionId,\n      id: addressOrHash,\n      status: 'unsubscribed'\n    }; // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nfunction configuration(config) {\n  if (this._destroyed) {\n    throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  }\n\n  const casedScope = this._system === 'ethereum' ? config.scope.toLowerCase() : config.scope; // resolve previous configuration if exists\n\n  const previousConfiguration = this.configurations.get(casedScope);\n  previousConfiguration && previousConfiguration.subscription && previousConfiguration.subscription.next();\n  const subscription = new Subject(); // create emitter for transaction\n\n  const emitter = config.watchAddress ? {\n    emitter: createEmitter()\n  } : {};\n  this.configurations.set(casedScope, { ...config,\n    ...emitter,\n    subscription\n  });\n\n  this._sendMessage({\n    categoryCode: 'configs',\n    eventCode: 'put',\n    config\n  });\n\n  return new Promise((resolve, reject) => {\n    subscription.pipe(take(1), timeout(5000)).subscribe({\n      next: () => resolve({ ...emitter,\n        details: {\n          config\n        }\n      }),\n      error: error => {\n        const message = error.message === 'Timeout has occurred' ? `Configuration with scope: ${config.scope} has been sent to the Blocknative server, but has not received a reply within 5 seconds.` : error.message;\n\n        if (this._onerror) {\n          this._onerror({\n            message\n          });\n\n          resolve(`Error: ${message}`);\n        } else {\n          reject(message);\n        }\n      }\n    });\n  });\n}\n\nfunction subscribe(subscription) {\n  const {\n    id,\n    chainId,\n    type\n  } = subscription;\n\n  if (!networkName('ethereum', parseInt(chainId, 16))) {\n    throw new Error(`chainId: ${chainId} is an unsupported network`);\n  }\n\n  if (!this.connections[chainId]) {\n    this.connections[chainId] = new this.Blocknative({\n      system: 'ethereum',\n      networkId: parseInt(chainId, 16),\n      dappId: this.apiKey,\n      ws: this.ws,\n      apiUrl: this.apiUrl,\n      transactionHandlers: [({\n        transaction\n      }) => {\n        this.onTransaction$.next(transaction);\n      }],\n      onerror: error => this.errors$.next(error)\n    });\n  }\n\n  const sdk = this.connections[chainId];\n\n  if (type === 'account') {\n    const {\n      filters = [],\n      abi\n    } = subscription;\n    sdk.configuration({\n      scope: id,\n      filters,\n      ...(abi ? {\n        abi\n      } : {}),\n      watchAddress: true\n    });\n    return this.transactions$.pipe(filter(({\n      watchedAddress\n    }) => watchedAddress === id), finalize(() => {\n      this.unsubscribe({\n        id,\n        chainId\n      });\n    }));\n  } else {\n    const {\n      emitter\n    } = sdk.transaction(id);\n    return fromEvent( // eslint-disable-next-line\n    // @ts-ignore - string does not match specific eventcode string\n    emitter, 'all').pipe( // automatically complete stream on a finalized status\n    takeWhile(({\n      status\n    }) => status !== 'confirmed' && status !== 'failed' && status !== 'dropped', true), // cleanup subscription and SDK on completion\n    finalize(() => {\n      this.unsubscribe({\n        id,\n        chainId\n      });\n    }));\n  }\n}\n\nfunction unsubscribe$1(options) {\n  const {\n    id,\n    chainId,\n    timeout = 0\n  } = options;\n  const time$ = timer(timeout);\n  const transactionEvent$ = this.transactions$.pipe(filter(({\n    hash,\n    watchedAddress\n  }) => hash === id || watchedAddress === id));\n  merge(transactionEvent$, time$).pipe(take(1)) // take just first event\n  .subscribe(res => {\n    // if number, then timeout with no transaction events, so go ahead and unsub\n    if (typeof res === 'number') {\n      const sdkConnections = Object.entries(this.connections).filter(([chainId, sdk]) => sdk !== null);\n      sdkConnections.forEach(([connectionChainId, sdk]) => {\n        // if chainId is passed and it doesn't match, then no unsub (return early)\n        if (chainId && connectionChainId !== chainId) return;\n        sdk.unsubscribe(id); // if no remaining subscriptions, destroy connection and set to null\n\n        if (!sdk.watchedAccounts.length && !sdk.watchedTransactions.length && !sdk.configurations.size) {\n          sdk.destroy();\n          this.connections[connectionChainId] = null;\n        }\n      });\n    } else {\n      // otherwise a transaction event received, so call unsub again for another timeout\n      this.unsubscribe(options);\n    }\n  });\n} //**Experimental API that is not yet finalized and is in BETA*/\n\n\nclass MultiChain {\n  constructor(options, Blocknative) {\n    const {\n      ws\n    } = options;\n    const {\n      apiKey\n    } = options;\n    const {\n      apiUrl\n    } = options;\n    this.apiKey = apiKey;\n    this.apiUrl = apiUrl;\n    this.ws = ws;\n    this.connections = {};\n    this.onTransaction$ = new Subject();\n    this.transactions$ = this.onTransaction$.asObservable();\n    this.errors$ = new Subject();\n    this.Blocknative = Blocknative;\n    this.subscribe = subscribe.bind(this);\n    this.unsubscribe = unsubscribe$1.bind(this);\n  }\n\n}\n\nvar version = \"4.6.7\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    serverVersion,\n    retryMs,\n    limitRules,\n    blockedMsg,\n    dispatchTimestamp\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (isLocalStorageAvailable()) {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit') && !reason.match(/IP (PendingSimulation|Notification) ratelimit reached/)) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('upgrade your plan')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (event && event.categoryCode === 'simulate') {\n      simulations$.error({\n        eventId: event.eventId,\n        error: {\n          message: reason\n        }\n      });\n      return;\n    } // handle config error\n\n\n    if (event && event.config) {\n      const configuration = this.configurations.get(event.config.scope);\n\n      if (configuration && configuration.subscription) {\n        configuration.subscription.error({\n          message: reason\n        });\n      }\n\n      return;\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.config) {\n    const casedScope = this._system === 'ethereum' ? event.config.scope.toLowerCase() : event.config.scope;\n    const configuration = this.configurations.get(casedScope);\n\n    if (configuration && configuration.subscription) {\n      configuration.subscription.next();\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      eventId,\n      transaction,\n      eventCode,\n      contractCall,\n      timeStamp,\n      blockchain: {\n        system,\n        network\n      }\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      dispatchTimestamp,\n      system,\n      network,\n      contractCall\n    } : { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      dispatchTimestamp,\n      system,\n      network\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // replace originalHash to match webhook API\n\n\n    if (newState.originalHash) {\n      newState.replaceHash = newState.hash;\n      newState.hash = newState.originalHash;\n      delete newState.originalHash;\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txSpeedUp' && newState.status !== 'speedup') {\n      newState.status = 'speedup';\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txCancel' && newState.status !== 'cancel') {\n      newState.status = 'cancel';\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this.watchedTransactions = this.watchedTransactions.map(tx => {\n        if (tx.hash === newState.replaceHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    if (event && event.categoryCode === 'simulate') {\n      newState.contractCall = event.transaction.contractCall;\n      delete newState.dispatchTimestamp;\n      simulations$.next({\n        eventId,\n        transaction: newState\n      });\n      return;\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this.watchedAccounts.find(ac => ac.address === watchedAddress);\n      const accountEmitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n      const configuration = this.configurations.get(watchedAddress);\n      const emitterResult = configuration && configuration.emitter ? configuration.emitter.emit(newState) || accountEmitterResult : accountEmitterResult;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this.watchedTransactions.find(tx => tx.hash === newState.hash || newState.txid);\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      })); // replace the emitter hash to the replace hash on replacement txs\n\n\n      if (newState.status === 'speedup' || newState.status === 'cancel') {\n        this.watchedTransactions = this.watchedTransactions.map(tx => {\n          if (tx.hash === newState.hash || newState.txid) {\n            return { ...tx,\n              hash: newState.replaceHash\n            };\n          }\n\n          return tx;\n        });\n      }\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date().toISOString(),\n    dappId: this._dappId,\n    version,\n    appName: this._appName,\n    appVersion: this._appVersion,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  }, msg.categoryCode === 'configs' ? jsonPreserveUndefined : undefined);\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nconst DEFAULT_APP_NAME = 'unknown';\nconst DEFAULT_APP_VERSION = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass SDK {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_APP_NAME,\n      appVersion = DEFAULT_APP_VERSION,\n      networkId,\n      transactionHandlers = [],\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const {\n      apiUrl\n    } = options;\n    const {\n      dappId\n    } = options; // override default timeout to allow for slow connections\n\n    const timeout = {\n      connectTimeout: 10000\n    };\n    const socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws,\n      ...timeout\n    } : { ...timeout\n    });\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = CryptoEs.SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = isLocalStorageAvailable() && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._appName = name;\n    this._appVersion = appVersion;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.watchedTransactions = [];\n    this.watchedAccounts = [];\n    this.configurations = new Map();\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.simulate = simulate.bind(this);\n    this.multiSim = multiSim.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n    this.configuration = configuration.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n  static multichain(options) {\n    return new MultiChain(options, this);\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nasync function onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all configurations on re-connection\n\n\n  const configurations = Array.from(this.configurations.values()); // register global config first and wait for it to complete\n\n  const globalConfiguration = this.configurations.get('global');\n\n  if (globalConfiguration) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {\n        emitter,\n        subscription,\n        ...config\n      } = globalConfiguration;\n      await this.configuration(config);\n    } catch (error) {\n      console.warn('Error re-sending global configuration upon reconnection:', error);\n    }\n  }\n\n  const addressConfigurations = configurations.filter(({\n    scope\n  }) => scope !== 'global');\n  addressConfigurations.forEach(enhancedConfig => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      emitter,\n      subscription,\n      ...config\n    } = enhancedConfig;\n\n    this._sendMessage({\n      categoryCode: 'configs',\n      eventCode: 'put',\n      config\n    });\n  }); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n  this.watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws && this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nmodule.exports = SDK;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm5jLXNkay9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSx3QkFBd0IsS0FBSztBQUM3Qjs7QUFFQTtBQUNBLHdCQUF3QixLQUFLLHFCQUFxQixLQUFLLG1CQUFtQixjQUFjLGNBQWMsTUFBTTtBQUM1Rzs7QUFFQTtBQUNBLHdCQUF3QixNQUFNLG9CQUFvQixLQUFLO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRO0FBQzlDLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRO0FBQ2hELFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsV0FBVztBQUN4QyxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlJQUFpSTs7QUFFakksZ0NBQWdDOztBQUVoQyxtQ0FBbUM7O0FBRW5DLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlJQUFpSTs7QUFFakksMkVBQTJFOztBQUUzRSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0EseUdBQXlHOztBQUV6RyxnR0FBZ0c7O0FBRWhHLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixtREFBbUQsY0FBYztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhGQUE4Rjs7QUFFOUY7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLElBQUk7QUFDSix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0dBQWdHLGNBQWM7O0FBRTlHO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVgsNEJBQTRCLFFBQVE7QUFDcEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSx3QkFBd0Isd0JBQXdCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0Esd0JBQXdCLHdCQUF3Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLHdCQUF3Qix1QkFBdUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTOztBQUVmLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sV0FBVzs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVEsSUFBSSxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEOzs7QUFHckQsbUVBQW1FOztBQUVuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsR0FBRztBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvYm5jLXNkay9kaXN0L2Nqcy9pbmRleC5qcz9mNjI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0KGV4KSB7XG4gIHJldHVybiBleCAmJiB0eXBlb2YgZXggPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBleCA/IGV4WydkZWZhdWx0J10gOiBleDtcbn1cblxudmFyIGNyeXB0byA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdjcnlwdG8nKSk7XG5cbmNvbnN0IG5ldHdvcmtzID0ge1xuICBldGhlcmV1bToge1xuICAgICcxJzogJ21haW4nLFxuICAgICc1JzogJ2dvZXJsaScsXG4gICAgJzEwMCc6ICd4ZGFpJyxcbiAgICAnMTM3JzogJ21hdGljLW1haW4nLFxuICAgICc4MDAwMSc6ICdtYXRpYy1tdW1iYWknXG4gIH1cbn07XG5jb25zdCBERVBSRUNBVEVEX05FVFdPUktfSURTID0gWzIsIDMsIDQsIDQyLCA1NiwgMjUwXTtcbmNvbnN0IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUyA9IHtcbiAgcG9pbnRzOiAxNTAsXG4gIGR1cmF0aW9uOiAxXG59O1xuY29uc3QgUVVFVUVfTElNSVQgPSAxMDAwMDtcblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICBvcHRpb25hbCxcbiAgICBjdXN0b21WYWxpZGF0aW9uXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghb3B0aW9uYWwgJiYgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgaXMgcmVxdWlyZWRgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmICh0eXBlID09PSAnYXJyYXknID8gQXJyYXkuaXNBcnJheSh0eXBlKSA6IHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgb2YgdHlwZTogJHt0eXBlfSwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgdmFsdWV9IGZyb20gdmFsdWU6ICR7dmFsdWV9YCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiBjdXN0b21WYWxpZGF0aW9uICYmICFjdXN0b21WYWxpZGF0aW9uKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHZhbGlkIFwiJHtuYW1lfVwiYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnc2RrIG9wdGlvbnMnLFxuICAgIHZhbHVlOiBvcHRpb25zLFxuICAgIHR5cGU6ICdvYmplY3QnXG4gIH0pO1xuICBjb25zdCB7XG4gICAgZGFwcElkLFxuICAgIHN5c3RlbSxcbiAgICBuYW1lLFxuICAgIGFwcFZlcnNpb24sXG4gICAgbmV0d29ya0lkLFxuICAgIHRyYW5zYWN0aW9uSGFuZGxlcnMsXG4gICAgYXBpVXJsLFxuICAgIHdzLFxuICAgIG9ub3BlbixcbiAgICBvbmRvd24sXG4gICAgb25yZW9wZW4sXG4gICAgb25lcnJvcixcbiAgICBvbmNsb3NlLFxuICAgIC4uLm90aGVyUGFyYW1zXG4gIH0gPSBvcHRpb25zO1xuICBpbnZhbGlkUGFyYW1zKG90aGVyUGFyYW1zLCBbJ2RhcHBJZCcsICdzeXN0ZW0nLCAnbmFtZScsICdhcHBWZXJzaW9uJywgJ25ldHdvcmtJZCcsICd0cmFuc2FjdGlvbkhhbmRsZXJzJywgJ2FwaVVybCcsICd3cycsICdvbm9wZW4nLCAnb25kb3duJywgJ29ucmVvcGVuJywgJ29uZXJyb3InLCAnb25jbG9zZSddLCAnSW5pdGlhbGl6YXRpb24gT3B0aW9ucycpO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdkYXBwSWQnLFxuICAgIHZhbHVlOiBkYXBwSWQsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3N5c3RlbScsXG4gICAgdmFsdWU6IHN5c3RlbSxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjdXN0b21WYWxpZGF0aW9uOiB2YWxpZFN5c3RlbVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmFtZScsXG4gICAgdmFsdWU6IG5hbWUsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2FwcFZlcnNpb24nLFxuICAgIHZhbHVlOiBhcHBWZXJzaW9uLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduZXR3b3JrSWQnLFxuICAgIHZhbHVlOiBuZXR3b3JrSWQsXG4gICAgdHlwZTogJ251bWJlcidcbiAgfSk7XG5cbiAgaWYgKERFUFJFQ0FURURfTkVUV09SS19JRFMuaW5jbHVkZXMobmV0d29ya0lkKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYEJsb2NrbmF0aXZlIFNESzogTmV0d29yayB3aXRoIElEOiAke25ldHdvcmtJZH0gaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgeW91IHdpbGwgbm8gbG9uZ2VyIHJlY2VpdmUgdHJhbnNhY3Rpb24gZXZlbnRzIG9uIHRoaXMgbmV0d29yay5gKTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3RyYW5zYWN0aW9uSGFuZGxlcicsXG4gICAgdmFsdWU6IHRyYW5zYWN0aW9uSGFuZGxlcnMsXG4gICAgdHlwZTogJ2FycmF5JyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAodHJhbnNhY3Rpb25IYW5kbGVycykge1xuICAgIHRyYW5zYWN0aW9uSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAndHJhbnNhY3Rpb25IYW5kbGVyJyxcbiAgICAgIHZhbHVlOiBoYW5kbGVyLFxuICAgICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2FwaVVybCcsXG4gICAgdmFsdWU6IGFwaVVybCxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd3MnLFxuICAgIHZhbHVlOiB3cyxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdvbm9wZW4nLFxuICAgIHZhbHVlOiBvbm9wZW4sXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25kb3duJyxcbiAgICB2YWx1ZTogb25kb3duLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29ucmVvcGVuJyxcbiAgICB2YWx1ZTogb25yZW9wZW4sXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25lcnJvcicsXG4gICAgdmFsdWU6IG9uZXJyb3IsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25jbG9zZScsXG4gICAgdmFsdWU6IG9uY2xvc2UsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRTeXN0ZW0oc3lzdGVtKSB7XG4gIHJldHVybiAhIW5ldHdvcmtzW3N5c3RlbV07XG59XG5cbmZ1bmN0aW9uIGludmFsaWRQYXJhbXMocGFyYW1zLCB2YWxpZFBhcmFtcywgZnVuY3Rpb25OYW1lKSB7XG4gIGNvbnN0IGludmFsaWQgPSBPYmplY3Qua2V5cyhwYXJhbXMpO1xuXG4gIGlmIChpbnZhbGlkLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7aW52YWxpZFswXX0gaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyIGZvciAke2Z1bmN0aW9uTmFtZX0sIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsaWQgcGFyYW1ldGVyczogJHt2YWxpZFBhcmFtcy5qb2luKCcsICcpfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMoeCkge1xuICByZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gIHJldHVybiBtb2R1bGUgPSB7XG4gICAgZXhwb3J0czoge31cbiAgfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXG5cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblxudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG5cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblxudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG5cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgdmFyIHJlc3VsdCA9IGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXTtcbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cblxuXG5mdW5jdGlvbiBhc3NpZ25JbkRlZmF1bHRzKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHwgZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5cblxuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8IHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cblxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gZnVuYy5sZW5ndGggLSAxIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cblxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuXG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IGFycmF5O1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZDtcbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVtrZXldIDogbmV3VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbiAob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG4gICAgY3VzdG9taXplciA9IGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IChsZW5ndGgtLSwgY3VzdG9taXplcikgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cblxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblxuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5cblxuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGg7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5cblxuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG5cbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgPyBpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlIHx8IG9iamVjdFByb3RvO1xuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuXG5cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cblxuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cblxuXG52YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24gKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xuXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbiAoYXJncykge1xuICBhcmdzLnB1c2godW5kZWZpbmVkLCBhc3NpZ25JbkRlZmF1bHRzKTtcbiAgcmV0dXJuIGFwcGx5KGFzc2lnbkluV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cblxuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxudmFyIGxvZGFzaF9kZWZhdWx0cyA9IGRlZmF1bHRzO1xudmFyIGRpc3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICB2YXIgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXR1cm5lZCBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbiAgdmFyIFNIT1VMRF9SRUNPTk5FQ1RfUFJPTUlTRV9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXNvbHZlZCB0byBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcblxuICB2YXIgU3R1cmR5V2ViU29ja2V0ID1cbiAgLyoqIEBjbGFzcyAqL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R1cmR5V2ViU29ja2V0KHVybCwgcHJvdG9jb2xzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIHRoaXMub25jbG9zZSA9IG51bGw7XG4gICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5vbm9wZW4gPSBudWxsO1xuICAgICAgdGhpcy5vbmRvd24gPSBudWxsO1xuICAgICAgdGhpcy5vbnJlb3BlbiA9IG51bGw7XG4gICAgICB0aGlzLkNPTk5FQ1RJTkcgPSBTdHVyZHlXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICAgIHRoaXMuT1BFTiA9IFN0dXJkeVdlYlNvY2tldC5PUEVOO1xuICAgICAgdGhpcy5DTE9TSU5HID0gU3R1cmR5V2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLkNMT1NFRCA9IFN0dXJkeVdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5uZXh0UmV0cnlUaW1lID0gMDtcbiAgICAgIHRoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgdGhpcy5sYXN0S25vd25FeHRlbnNpb25zID0gXCJcIjtcbiAgICAgIHRoaXMubGFzdEtub3duUHJvdG9jb2wgPSBcIlwiO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICAgICAgaWYgKHByb3RvY29sc09yT3B0aW9ucyA9PSBudWxsIHx8IHR5cGVvZiBwcm90b2NvbHNPck9wdGlvbnMgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShwcm90b2NvbHNPck9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zID0gbG9kYXNoX2RlZmF1bHRzKHt9LCBvcHRpb25zLCBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TKTtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMud3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yID0gV2ViU29ja2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldCBub3QgcHJlc2VudCBpbiBnbG9iYWwgc2NvcGUgYW5kIG5vIFwiICsgXCJ3c0NvbnN0cnVjdG9yIG9wdGlvbiB3YXMgcHJvdmlkZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3Blbk5ld1dlYlNvY2tldCgpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJpbmFyeVR5cGVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCB8fCBcImJsb2JcIjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChiaW5hcnlUeXBlKSB7XG4gICAgICAgIHRoaXMuYmluYXJ5VHlwZUludGVybmFsID0gYmluYXJ5VHlwZTtcblxuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiYnVmZmVyZWRBbW91bnRcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdW0gPSB0aGlzLndzID8gdGhpcy53cy5idWZmZXJlZEFtb3VudCA6IDA7XG4gICAgICAgIHZhciBoYXNVbmtub3duQW1vdW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgICAgIGlmIChieXRlTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN1bSArPSBieXRlTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYXNVbmtub3duQW1vdW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNVbmtub3duQW1vdW50KSB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIlNvbWUgYnVmZmVyZWQgZGF0YSBoYWQgdW5rbm93biBsZW5ndGguIGJ1ZmZlcmVkQW1vdW50KClcIiArIFwiIHJldHVybiB2YWx1ZSBtYXkgYmUgYmVsb3cgdGhlIGNvcnJlY3QgYW1vdW50LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImV4dGVuc2lvbnNcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndzID8gdGhpcy53cy5leHRlbnNpb25zIDogdGhpcy5sYXN0S25vd25FeHRlbnNpb25zO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJwcm90b2NvbFwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3MgPyB0aGlzLndzLnByb3RvY29sIDogdGhpcy5sYXN0S25vd25Qcm90b2NvbDtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwicmVhZHlTdGF0ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDbG9zZWQgPyBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEIDogU3R1cmR5V2ViU29ja2V0Lk9QRU47XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zaHV0ZG93bigpO1xuICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBwZXJtYW5lbnRseSBjbG9zZWQgYnkgY2xpZW50LlwiKTtcbiAgICB9O1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5PUEVOKSB7XG4gICAgICAgIHRoaXMud3Muc2VuZChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShldmVudC50eXBlLCBldmVudCk7XG4gICAgfTtcblxuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5vcGVuTmV3V2ViU29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgY29ubmVjdFRpbWVvdXQgPSBfYS5jb25uZWN0VGltZW91dCxcbiAgICAgICAgICB3c0NvbnN0cnVjdG9yID0gX2Eud3NDb25zdHJ1Y3RvcjtcbiAgICAgIHRoaXMuZGVidWdMb2coXCJPcGVuaW5nIG5ldyBXZWJTb2NrZXQgdG8gXCIgKyB0aGlzLnVybCArIFwiLlwiKTtcbiAgICAgIHZhciB3cyA9IG5ldyB3c0NvbnN0cnVjdG9yKHRoaXMudXJsLCB0aGlzLnByb3RvY29scyk7XG5cbiAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUNsb3NlKGV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHdzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUVycm9yKGV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTWVzc2FnZShldmVudCk7XG4gICAgICB9O1xuXG4gICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgcnVubmluZywgd2Ugc3RpbGwgaGF2ZW4ndCBvcGVuZWQgdGhlIHdlYnNvY2tldC5cbiAgICAgICAgLy8gS2lsbCBpdCBzbyB3ZSBjYW4gdHJ5IGFnYWluLlxuICAgICAgICBfdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG5cbiAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgIH0sIGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMud3MgPSB3cztcbiAgICB9O1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVPcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGxDbGVhclJlc2V0VGltZSA9IHRoaXMub3B0aW9ucy5hbGxDbGVhclJlc2V0VGltZTtcbiAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgb3BlbmVkLlwiKTtcblxuICAgICAgaWYgKHRoaXMuYmluYXJ5VHlwZUludGVybmFsICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IHRoaXMud3MuYmluYXJ5VHlwZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG5cbiAgICAgIGlmICh0aGlzLmhhc0JlZW5PcGVuZWQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwicmVvcGVuXCIsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcIm9wZW5cIiwgZXZlbnQpO1xuICAgICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2VuZChtZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG5cbiAgICAgICAgX3RoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgIF90aGlzLnJlY29ubmVjdENvdW50ID0gMDtcbiAgICAgICAgdmFyIG9wZW5UaW1lID0gYWxsQ2xlYXJSZXNldFRpbWUgLyAxMDAwIHwgMDtcblxuICAgICAgICBfdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCByZW1haW5lZCBvcGVuIGZvciBcIiArIG9wZW5UaW1lICsgXCIgc2Vjb25kcy4gUmVzZXR0aW5nXCIgKyBcIiByZXRyeSB0aW1lIGFuZCBjb3VudC5cIik7XG4gICAgICB9LCBhbGxDbGVhclJlc2V0VGltZSk7XG4gICAgfTtcblxuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJtZXNzYWdlXCIsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVDbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSBfYS5tYXhSZWNvbm5lY3RBdHRlbXB0cyxcbiAgICAgICAgICBzaG91bGRSZWNvbm5lY3QgPSBfYS5zaG91bGRSZWNvbm5lY3Q7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcblxuICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgdGhpcy5sYXN0S25vd25FeHRlbnNpb25zID0gdGhpcy53cy5leHRlbnNpb25zO1xuICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gdGhpcy53cy5wcm90b2NvbDtcbiAgICAgICAgdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZG93blwiLCBldmVudCk7XG5cbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdENvdW50ID49IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgIHRoaXMuc3RvcFJlY29ubmVjdGluZyhldmVudCwgdGhpcy5nZXRUb29NYW55RmFpbGVkUmVjb25uZWN0c01lc3NhZ2UoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpbGxSZWNvbm5lY3QgPSBzaG91bGRSZWNvbm5lY3QoZXZlbnQpO1xuXG4gICAgICBpZiAodHlwZW9mIHdpbGxSZWNvbm5lY3QgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0LCBldmVudCwgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbGxSZWNvbm5lY3QudGhlbihmdW5jdGlvbiAod2lsbFJlY29ubmVjdFJlc29sdmVkKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0UmVzb2x2ZWQsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJlcnJvclwiLCBldmVudCk7XG4gICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IGVuY291bnRlcmVkIGFuIGVycm9yLlwiKTtcbiAgICB9O1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVXaWxsUmVjb25uZWN0ID0gZnVuY3Rpb24gKHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBkZW5pYWxSZWFzb24pIHtcbiAgICAgIGlmICh3aWxsUmVjb25uZWN0KSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIGRlbmlhbFJlYXNvbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIG1pblJlY29ubmVjdERlbGF5ID0gX2EubWluUmVjb25uZWN0RGVsYXksXG4gICAgICAgICAgbWF4UmVjb25uZWN0RGVsYXkgPSBfYS5tYXhSZWNvbm5lY3REZWxheSxcbiAgICAgICAgICByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yID0gX2EucmVjb25uZWN0QmFja29mZkZhY3RvcjtcbiAgICAgIHRoaXMucmVjb25uZWN0Q291bnQrKztcbiAgICAgIHZhciByZXRyeVRpbWUgPSB0aGlzLm5leHRSZXRyeVRpbWU7XG4gICAgICB0aGlzLm5leHRSZXRyeVRpbWUgPSBNYXRoLm1heChtaW5SZWNvbm5lY3REZWxheSwgTWF0aC5taW4odGhpcy5uZXh0UmV0cnlUaW1lICogcmVjb25uZWN0QmFja29mZkZhY3RvciwgbWF4UmVjb25uZWN0RGVsYXkpKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMub3Blbk5ld1dlYlNvY2tldCgpO1xuICAgICAgfSwgcmV0cnlUaW1lKTtcbiAgICAgIHZhciByZXRyeVRpbWVTZWNvbmRzID0gcmV0cnlUaW1lIC8gMTAwMCB8IDA7XG4gICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHdhcyBjbG9zZWQuIFJlLW9wZW5pbmcgaW4gXCIgKyByZXRyeVRpbWVTZWNvbmRzICsgXCIgc2Vjb25kcy5cIik7XG4gICAgfTtcblxuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc3RvcFJlY29ubmVjdGluZyA9IGZ1bmN0aW9uIChldmVudCwgZGVidWdSZWFzb24pIHtcbiAgICAgIHRoaXMuZGVidWdMb2coZGVidWdSZWFzb24pO1xuICAgICAgdGhpcy5zaHV0ZG93bigpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiY2xvc2VcIiwgZXZlbnQpO1xuICAgIH07XG5cbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLmNsZWFyQWxsVGltZW91dHMoKTtcbiAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgIH07XG5cbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQWxsVGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckNvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJBbGxDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5hbGxDbGVhclRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFsbENsZWFyVGltZW91dElkKTtcbiAgICAgICAgdGhpcy5hbGxDbGVhclRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50T2ZUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgaWYgKHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm9ubWVzc2FnZShldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICBpZiAodGhpcy5vbm9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub25vcGVuKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgIGlmICh0aGlzLm9uZG93bikge1xuICAgICAgICAgICAgdGhpcy5vbmRvd24oZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJyZW9wZW5cIjpcbiAgICAgICAgICBpZiAodGhpcy5vbnJlb3Blbikge1xuICAgICAgICAgICAgdGhpcy5vbnJlb3BlbihldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2FsbExpc3RlbmVyKGxpc3RlbmVyLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWV2ZW50IHx8ICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH07XG5cbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNhbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZXZlbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRlYnVnTG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1heFJlY29ubmVjdEF0dGVtcHRzID0gdGhpcy5vcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzO1xuICAgICAgcmV0dXJuIFwiRmFpbGVkIHRvIHJlY29ubmVjdCBhZnRlciBcIiArIG1heFJlY29ubmVjdEF0dGVtcHRzICsgXCIgXCIgKyBwbHVyYWxpemUoXCJhdHRlbXB0XCIsIG1heFJlY29ubmVjdEF0dGVtcHRzKSArIFwiLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xuICAgIH07XG5cbiAgICBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgYWxsQ2xlYXJSZXNldFRpbWU6IDUwMDAsXG4gICAgICBjb25uZWN0VGltZW91dDogNTAwMCxcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgIG1pblJlY29ubmVjdERlbGF5OiAxMDAwLFxuICAgICAgbWF4UmVjb25uZWN0RGVsYXk6IDMwMDAwLFxuICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgIHJlY29ubmVjdEJhY2tvZmZGYWN0b3I6IDEuNSxcbiAgICAgIHNob3VsZFJlY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICB3c0NvbnN0cnVjdG9yOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HID0gMDtcbiAgICBTdHVyZHlXZWJTb2NrZXQuT1BFTiA9IDE7XG4gICAgU3R1cmR5V2ViU29ja2V0LkNMT1NJTkcgPSAyO1xuICAgIFN0dXJkeVdlYlNvY2tldC5DTE9TRUQgPSAzO1xuICAgIHJldHVybiBTdHVyZHlXZWJTb2NrZXQ7XG4gIH0oKTtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBTdHVyZHlXZWJTb2NrZXQ7XG5cbiAgZnVuY3Rpb24gZ2V0RGF0YUJ5dGVMZW5ndGgoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gVVRGLTE2IHN0cmluZ3MgdXNlIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLlxuICAgICAgcmV0dXJuIDIgKiBkYXRhLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICByZXR1cm4gZGF0YS5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsdXJhbGl6ZShzLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IDEgPyBzIDogcyArIFwic1wiO1xuICB9XG59KTtcbnZhciBTdHVyZHlXZWJTb2NrZXQgPSB1bndyYXBFeHBvcnRzKGRpc3QpO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBpbmhlcml0YW5jZS5cbiAqL1xuXG5jbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoLi4uYXJncyk7XG4gIH1cbiAgLyoqXG4gICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIE15VHlwZS5taXhJbih7XG4gICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcbiAgICogICAgIH0pO1xuICAgKi9cblxuXG4gIG1peEluKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcbiAgICovXG5cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdGhpcyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbn1cbi8qKlxuICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG4gKi9cblxuXG5jbGFzcyBXb3JkQXJyYXkgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3b3JkcyA9IFtdLCBzaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQpIHtcbiAgICBzdXBlcigpO1xuICAgIGxldCB0eXBlZEFycmF5ID0gd29yZHM7IC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuXG4gICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuICAgIH0gLy8gQ29udmVydCBvdGhlciBhcnJheSB2aWV3cyB0byB1aW50OFxuXG5cbiAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xuICAgIH0gLy8gSGFuZGxlIFVpbnQ4QXJyYXlcblxuXG4gICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgY29uc3QgdHlwZWRBcnJheUJ5dGVMZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7IC8vIEV4dHJhY3QgYnl0ZXNcblxuICAgICAgY29uc3QgX3dvcmRzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZWRBcnJheUJ5dGVMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfd29yZHNbaSA+Pj4gMl0gfD0gdHlwZWRBcnJheVtpXSA8PCAyNCAtIGkgJSA0ICogODtcbiAgICAgIH0gLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcblxuXG4gICAgICB0aGlzLndvcmRzID0gX3dvcmRzO1xuICAgICAgdGhpcy5zaWdCeXRlcyA9IHR5cGVkQXJyYXlCeXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcbiAgICAgIHRoaXMud29yZHMgPSB3b3JkcztcbiAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG4gICAqL1xuXG5cbiAgc3RhdGljIHJhbmRvbShuQnl0ZXMpIHtcbiAgICBjb25zdCB3b3JkcyA9IFtdO1xuXG4gICAgY29uc3QgciA9IG1fdyA9PiB7XG4gICAgICBsZXQgX21fdyA9IG1fdztcbiAgICAgIGxldCBfbV96ID0gMHgzYWRlNjhiMTtcbiAgICAgIGNvbnN0IG1hc2sgPSAweGZmZmZmZmZmO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgX21feiA9IDB4OTA2OSAqIChfbV96ICYgMHhGRkZGKSArIChfbV96ID4+IDB4MTApICYgbWFzaztcbiAgICAgICAgX21fdyA9IDB4NDY1MCAqIChfbV93ICYgMHhGRkZGKSArIChfbV93ID4+IDB4MTApICYgbWFzaztcbiAgICAgICAgbGV0IHJlc3VsdCA9IChfbV96IDw8IDB4MTApICsgX21fdyAmIG1hc2s7XG4gICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcbiAgICAgICAgcmVzdWx0ICs9IDAuNTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuICAgICAgY29uc3QgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cbiAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuICAgICAgd29yZHMucHVzaChfcigpICogMHgxMDAwMDAwMDAgfCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdvcmRBcnJheSh3b3JkcywgbkJ5dGVzKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG4gICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG4gICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICovXG5cblxuICB0b1N0cmluZyhlbmNvZGVyID0gSGV4KSB7XG4gICAgcmV0dXJuIGVuY29kZXIuc3RyaW5naWZ5KHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG4gICAqL1xuXG5cbiAgY29uY2F0KHdvcmRBcnJheSkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG4gICAgY29uc3QgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgIGNvbnN0IHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG4gICAgY29uc3QgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzOyAvLyBDbGFtcCBleGNlc3MgYml0c1xuXG4gICAgdGhpcy5jbGFtcCgpOyAvLyBDb25jYXRcblxuICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG4gICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB0aGF0Qnl0ZSA9IHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAweGZmO1xuICAgICAgICB0aGlzV29yZHNbdGhpc1NpZ0J5dGVzICsgaSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgMjQgLSAodGhpc1NpZ0J5dGVzICsgaSkgJSA0ICogODtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcbiAgICAgICAgdGhpc1dvcmRzW3RoaXNTaWdCeXRlcyArIGkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzOyAvLyBDaGFpbmFibGVcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuICAgKi9cblxuXG4gIGNsYW1wKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHtcbiAgICAgIHdvcmRzLFxuICAgICAgc2lnQnl0ZXNcbiAgICB9ID0gdGhpczsgLy8gQ2xhbXBcblxuICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8IDMyIC0gc2lnQnl0ZXMgJSA0ICogODtcbiAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuICAgKi9cblxuXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gc3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbn1cbi8qKlxuICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuICovXG5cblxuY29uc3QgSGV4ID0ge1xuICAvKipcbiAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAqL1xuICBzdHJpbmdpZnkod29yZEFycmF5KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qge1xuICAgICAgd29yZHMsXG4gICAgICBzaWdCeXRlc1xuICAgIH0gPSB3b3JkQXJyYXk7IC8vIENvbnZlcnRcblxuICAgIGNvbnN0IGhleENoYXJzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGJpdGUgPSB3b3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAweGZmO1xuICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuICAgIH1cblxuICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKGhleFN0cikge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDsgLy8gQ29udmVydFxuXG4gICAgY29uc3Qgd29yZHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAyNCAtIGkgJSA4ICogNDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdvcmRBcnJheSh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG4gIH1cblxufTtcbi8qKlxuICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuICovXG5cbmNvbnN0IExhdGluMSA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgc3RyaW5naWZ5KHdvcmRBcnJheSkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHtcbiAgICAgIHdvcmRzLFxuICAgICAgc2lnQnl0ZXNcbiAgICB9ID0gd29yZEFycmF5OyAvLyBDb252ZXJ0XG5cbiAgICBjb25zdCBsYXRpbjFDaGFycyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAxKSB7XG4gICAgICBjb25zdCBiaXRlID0gd29yZHNbaSA+Pj4gMl0gPj4+IDI0IC0gaSAlIDQgKiA4ICYgMHhmZjtcbiAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UobGF0aW4xU3RyKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoOyAvLyBDb252ZXJ0XG5cbiAgICBjb25zdCB3b3JkcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgMjQgLSBpICUgNCAqIDg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG4gIH1cblxufTtcbi8qKlxuICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gKi9cblxuY29uc3QgVXRmOCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgc3RyaW5naWZ5KHdvcmRBcnJheSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKHV0ZjhTdHIpIHtcbiAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuICB9XG5cbn07XG4vKipcbiAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZVxuICpcbiAqICAgICBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcbiAqL1xuXG5jbGFzcyBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtIGV4dGVuZHMgQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuICAgKi9cblxuXG4gIHJlc2V0KCkge1xuICAgIC8vIEluaXRpYWwgdmFsdWVzXG4gICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkoKTtcbiAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcbiAgfVxuICAvKipcbiAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhXG4gICAqXG4gICAqICAgICBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG4gICAqL1xuXG5cbiAgX2FwcGVuZChkYXRhKSB7XG4gICAgbGV0IG1fZGF0YSA9IGRhdGE7IC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblxuICAgIGlmICh0eXBlb2YgbV9kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgbV9kYXRhID0gVXRmOC5wYXJzZShtX2RhdGEpO1xuICAgIH0gLy8gQXBwZW5kXG5cblxuICAgIHRoaXMuX2RhdGEuY29uY2F0KG1fZGF0YSk7XG5cbiAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IG1fZGF0YS5zaWdCeXRlcztcbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG4gICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcbiAgICovXG5cblxuICBfcHJvY2Vzcyhkb0ZsdXNoKSB7XG4gICAgbGV0IHByb2Nlc3NlZFdvcmRzOyAvLyBTaG9ydGN1dHNcblxuICAgIGNvbnN0IHtcbiAgICAgIF9kYXRhOiBkYXRhLFxuICAgICAgYmxvY2tTaXplXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcbiAgICBjb25zdCBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDsgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cbiAgICBsZXQgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cbiAgICBpZiAoZG9GbHVzaCkge1xuICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcbiAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuICAgIH0gLy8gQ291bnQgd29yZHMgcmVhZHlcblxuXG4gICAgY29uc3QgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7IC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cbiAgICBjb25zdCBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTsgLy8gUHJvY2VzcyBibG9ja3NcblxuICAgIGlmIChuV29yZHNSZWFkeSkge1xuICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcbiAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuICAgICAgfSAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cblxuICAgICAgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcbiAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG4gICAgfSAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cblxuICAgIHJldHVybiBuZXcgV29yZEFycmF5KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcbiAgICovXG5cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbn1cbi8qKlxuICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemVcbiAqXG4gKiAgICAgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcbiAqL1xuXG5cbmNsYXNzIEhhc2hlciBleHRlbmRzIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gMzI7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqL1xuXG4gICAgdGhpcy5jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIGNmZyk7IC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0hhc2hlcn0gU3ViSGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG4gICAqL1xuXG5cbiAgc3RhdGljIF9jcmVhdGVIZWxwZXIoU3ViSGFzaGVyKSB7XG4gICAgcmV0dXJuIChtZXNzYWdlLCBjZmcpID0+IG5ldyBTdWJIYXNoZXIoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtIYXNoZXJ9IFN1Ykhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuICAgKi9cblxuXG4gIHN0YXRpYyBfY3JlYXRlSG1hY0hlbHBlcihTdWJIYXNoZXIpIHtcbiAgICByZXR1cm4gKG1lc3NhZ2UsIGtleSkgPT4gbmV3IEhNQUMoU3ViSGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBoYXNoZXIucmVzZXQoKTtcbiAgICovXG5cblxuICByZXNldCgpIHtcbiAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuICAgIHN1cGVyLnJlc2V0LmNhbGwodGhpcyk7IC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cbiAgICB0aGlzLl9kb1Jlc2V0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG4gICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG4gICAqL1xuXG5cbiAgdXBkYXRlKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICAvLyBBcHBlbmRcbiAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7IC8vIFVwZGF0ZSB0aGUgaGFzaFxuXG5cbiAgICB0aGlzLl9wcm9jZXNzKCk7IC8vIENoYWluYWJsZVxuXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcbiAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG4gICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgKi9cblxuXG4gIGZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG4gICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG4gICAgfSAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXG5cbiAgICBjb25zdCBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxufVxuLyoqXG4gKiBITUFDIGFsZ29yaXRobS5cbiAqL1xuXG5cbmNsYXNzIEhNQUMgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuICAgKlxuICAgKiBAcGFyYW0ge0hhc2hlcn0gU3ViSGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuICAgKi9cbiAgY29uc3RydWN0b3IoU3ViSGFzaGVyLCBrZXkpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IGhhc2hlciA9IG5ldyBTdWJIYXNoZXIoKTtcbiAgICB0aGlzLl9oYXNoZXIgPSBoYXNoZXI7IC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblxuICAgIGxldCBfa2V5ID0ga2V5O1xuXG4gICAgaWYgKHR5cGVvZiBfa2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgX2tleSA9IFV0ZjgucGFyc2UoX2tleSk7XG4gICAgfSAvLyBTaG9ydGN1dHNcblxuXG4gICAgY29uc3QgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcbiAgICBjb25zdCBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7IC8vIEFsbG93IGFyYml0cmFyeSBsZW5ndGgga2V5c1xuXG4gICAgaWYgKF9rZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuICAgICAgX2tleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuICAgIH0gLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblxuXG4gICAgX2tleS5jbGFtcCgpOyAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG5cblxuICAgIGNvbnN0IG9LZXkgPSBfa2V5LmNsb25lKCk7XG5cbiAgICB0aGlzLl9vS2V5ID0gb0tleTtcblxuICAgIGNvbnN0IGlLZXkgPSBfa2V5LmNsb25lKCk7XG5cbiAgICB0aGlzLl9pS2V5ID0gaUtleTsgLy8gU2hvcnRjdXRzXG5cbiAgICBjb25zdCBvS2V5V29yZHMgPSBvS2V5LndvcmRzO1xuICAgIGNvbnN0IGlLZXlXb3JkcyA9IGlLZXkud29yZHM7IC8vIFhPUiBrZXlzIHdpdGggcGFkIGNvbnN0YW50c1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkgKz0gMSkge1xuICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG4gICAgICBpS2V5V29yZHNbaV0gXj0gMHgzNjM2MzYzNjtcbiAgICB9XG5cbiAgICBvS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG4gICAgaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzOyAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcbiAgICovXG5cblxuICByZXNldCgpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGhhc2hlciA9IHRoaXMuX2hhc2hlcjsgLy8gUmVzZXRcblxuICAgIGhhc2hlci5yZXNldCgpO1xuICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBITUFDIHdpdGggYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtITUFDfSBUaGlzIEhNQUMgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUod29yZEFycmF5KTtcbiAgICovXG5cblxuICB1cGRhdGUobWVzc2FnZVVwZGF0ZSkge1xuICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7IC8vIENoYWluYWJsZVxuXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG4gICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcbiAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgKi9cblxuXG4gIGZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGhhc2hlciA9IHRoaXMuX2hhc2hlcjsgLy8gQ29tcHV0ZSBITUFDXG5cbiAgICBjb25zdCBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG4gICAgaGFzaGVyLnJlc2V0KCk7XG4gICAgY29uc3QgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuICAgIHJldHVybiBobWFjO1xuICB9XG5cbn1cblxuY29uc3QgWDMyV29yZEFycmF5ID0gV29yZEFycmF5O1xuLyoqXG4gKiBBIDY0LWJpdCB3b3JkLlxuICovXG5cbmNsYXNzIFg2NFdvcmQgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCA2NC1iaXQgd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggMzIgYml0cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IDMyIGJpdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgeDY0V29yZCA9IENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKGhpZ2gsIGxvdykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5oaWdoID0gaGlnaDtcbiAgICB0aGlzLmxvdyA9IGxvdztcbiAgfVxuXG59XG4vKipcbiAqIEFuIGFycmF5IG9mIDY0LWJpdCB3b3Jkcy5cbiAqXG4gKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgQ3J5cHRvSlMueDY0LldvcmQgb2JqZWN0cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cbiAqL1xuXG5cbmNsYXNzIFg2NFdvcmRBcnJheSBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgQ3J5cHRvSlMueDY0LldvcmQgb2JqZWN0cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoKTtcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZShbXG4gICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpLFxuICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxuICAgKiAgICAgXSk7XG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoW1xuICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcbiAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgxODE5MWExYiwgMHgxYzFkMWUxZilcbiAgICogICAgIF0sIDEwKTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdvcmRzID0gW10sIHNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogOCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JkcyA9IHdvcmRzO1xuICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyA2NC1iaXQgd29yZCBhcnJheSB0byBhIDMyLWJpdCB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDcnlwdG9KUy5saWIuV29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkncyBkYXRhIGFzIGEgMzItYml0IHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgeDMyV29yZEFycmF5ID0geDY0V29yZEFycmF5LnRvWDMyKCk7XG4gICAqL1xuXG5cbiAgdG9YMzIoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeDY0V29yZHMgPSB0aGlzLndvcmRzO1xuICAgIGNvbnN0IHg2NFdvcmRzTGVuZ3RoID0geDY0V29yZHMubGVuZ3RoOyAvLyBDb252ZXJ0XG5cbiAgICBjb25zdCB4MzJXb3JkcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4NjRXb3Jkc0xlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB4NjRXb3JkID0geDY0V29yZHNbaV07XG4gICAgICB4MzJXb3Jkcy5wdXNoKHg2NFdvcmQuaGlnaCk7XG4gICAgICB4MzJXb3Jkcy5wdXNoKHg2NFdvcmQubG93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gWDMyV29yZEFycmF5LmNyZWF0ZSh4MzJXb3JkcywgdGhpcy5zaWdCeXRlcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7WDY0V29yZEFycmF5fSBUaGUgY2xvbmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2xvbmUgPSB4NjRXb3JkQXJyYXkuY2xvbmUoKTtcbiAgICovXG5cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7IC8vIENsb25lIFwid29yZHNcIiBhcnJheVxuXG4gICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuICAgIGNvbnN0IHtcbiAgICAgIHdvcmRzXG4gICAgfSA9IGNsb25lOyAvLyBDbG9uZSBlYWNoIFg2NFdvcmQgb2JqZWN0XG5cbiAgICBjb25zdCB3b3Jkc0xlbmd0aCA9IHdvcmRzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHNMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgd29yZHNbaV0gPSB3b3Jkc1tpXS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG59XG5cbmNvbnN0IHBhcnNlTG9vcCA9IChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkgPT4ge1xuICBjb25zdCB3b3JkcyA9IFtdO1xuICBsZXQgbkJ5dGVzID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGkgJSA0KSB7XG4gICAgICBjb25zdCBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCBpICUgNCAqIDI7XG4gICAgICBjb25zdCBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiA2IC0gaSAlIDQgKiAyO1xuICAgICAgY29uc3QgYml0c0NvbWJpbmVkID0gYml0czEgfCBiaXRzMjtcbiAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gYml0c0NvbWJpbmVkIDw8IDI0IC0gbkJ5dGVzICUgNCAqIDg7XG4gICAgICBuQnl0ZXMgKz0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcbn07XG4vKipcbiAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuXG5cbmNvbnN0IEJhc2U2NCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAqL1xuICBzdHJpbmdpZnkod29yZEFycmF5KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qge1xuICAgICAgd29yZHMsXG4gICAgICBzaWdCeXRlc1xuICAgIH0gPSB3b3JkQXJyYXk7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fbWFwOyAvLyBDbGFtcCBleGNlc3MgYml0c1xuXG4gICAgd29yZEFycmF5LmNsYW1wKCk7IC8vIENvbnZlcnRcblxuICAgIGNvbnN0IGJhc2U2NENoYXJzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcbiAgICAgIGNvbnN0IGJ5dGUxID0gd29yZHNbaSA+Pj4gMl0gPj4+IDI0IC0gaSAlIDQgKiA4ICYgMHhmZjtcbiAgICAgIGNvbnN0IGJ5dGUyID0gd29yZHNbaSArIDEgPj4+IDJdID4+PiAyNCAtIChpICsgMSkgJSA0ICogOCAmIDB4ZmY7XG4gICAgICBjb25zdCBieXRlMyA9IHdvcmRzW2kgKyAyID4+PiAyXSA+Pj4gMjQgLSAoaSArIDIpICUgNCAqIDggJiAweGZmO1xuICAgICAgY29uc3QgdHJpcGxldCA9IGJ5dGUxIDw8IDE2IHwgYnl0ZTIgPDwgOCB8IGJ5dGUzO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQgJiYgaSArIGogKiAwLjc1IDwgc2lnQnl0ZXM7IGogKz0gMSkge1xuICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQodHJpcGxldCA+Pj4gNiAqICgzIC0gaikgJiAweDNmKSk7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgcGFkZGluZ1xuXG5cbiAgICBjb25zdCBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXG4gICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKGJhc2U2NFN0cikge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGxldCBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuX21hcDtcbiAgICBsZXQgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cbiAgICBpZiAoIXJldmVyc2VNYXApIHtcbiAgICAgIHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcbiAgICAgIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG4gICAgICB9XG4gICAgfSAvLyBJZ25vcmUgcGFkZGluZ1xuXG5cbiAgICBjb25zdCBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXG4gICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICBjb25zdCBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG5cbiAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcbiAgICAgIH1cbiAgICB9IC8vIENvbnZlcnRcblxuXG4gICAgcmV0dXJuIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCk7XG4gIH0sXG5cbiAgX21hcDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xufTsgLy8gQ29uc3RhbnRzIHRhYmxlXG5cbmNvbnN0IFQgPSBbXTsgLy8gQ29tcHV0ZSBjb25zdGFudHNcblxuZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSArPSAxKSB7XG4gIFRbaV0gPSBNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDAgfCAwO1xufVxuXG5jb25zdCBGRiA9IChhLCBiLCBjLCBkLCB4LCBzLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBhICsgKGIgJiBjIHwgfmIgJiBkKSArIHggKyB0O1xuICByZXR1cm4gKG4gPDwgcyB8IG4gPj4+IDMyIC0gcykgKyBiO1xufTtcblxuY29uc3QgR0cgPSAoYSwgYiwgYywgZCwgeCwgcywgdCkgPT4ge1xuICBjb25zdCBuID0gYSArIChiICYgZCB8IGMgJiB+ZCkgKyB4ICsgdDtcbiAgcmV0dXJuIChuIDw8IHMgfCBuID4+PiAzMiAtIHMpICsgYjtcbn07XG5cbmNvbnN0IEhIID0gKGEsIGIsIGMsIGQsIHgsIHMsIHQpID0+IHtcbiAgY29uc3QgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuICByZXR1cm4gKG4gPDwgcyB8IG4gPj4+IDMyIC0gcykgKyBiO1xufTtcblxuY29uc3QgSUkgPSAoYSwgYiwgYywgZCwgeCwgcywgdCkgPT4ge1xuICBjb25zdCBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG4gIHJldHVybiAobiA8PCBzIHwgbiA+Pj4gMzIgLSBzKSArIGI7XG59O1xuLyoqXG4gKiBNRDUgaGFzaCBhbGdvcml0aG0uXG4gKi9cblxuXG5jbGFzcyBNRDVBbGdvIGV4dGVuZHMgSGFzaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkoWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZdKTtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfTSA9IE07IC8vIFN3YXAgZW5kaWFuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3Qgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuICAgICAgY29uc3QgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuICAgICAgX01bb2Zmc2V0X2ldID0gKE1fb2Zmc2V0X2kgPDwgOCB8IE1fb2Zmc2V0X2kgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoTV9vZmZzZXRfaSA8PCAyNCB8IE1fb2Zmc2V0X2kgPj4+IDgpICYgMHhmZjAwZmYwMDtcbiAgICB9IC8vIFNob3J0Y3V0c1xuXG5cbiAgICBjb25zdCBIID0gdGhpcy5faGFzaC53b3JkcztcbiAgICBjb25zdCBNX29mZnNldF8wID0gX01bb2Zmc2V0ICsgMF07XG4gICAgY29uc3QgTV9vZmZzZXRfMSA9IF9NW29mZnNldCArIDFdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzIgPSBfTVtvZmZzZXQgKyAyXTtcbiAgICBjb25zdCBNX29mZnNldF8zID0gX01bb2Zmc2V0ICsgM107XG4gICAgY29uc3QgTV9vZmZzZXRfNCA9IF9NW29mZnNldCArIDRdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzUgPSBfTVtvZmZzZXQgKyA1XTtcbiAgICBjb25zdCBNX29mZnNldF82ID0gX01bb2Zmc2V0ICsgNl07XG4gICAgY29uc3QgTV9vZmZzZXRfNyA9IF9NW29mZnNldCArIDddO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzggPSBfTVtvZmZzZXQgKyA4XTtcbiAgICBjb25zdCBNX29mZnNldF85ID0gX01bb2Zmc2V0ICsgOV07XG4gICAgY29uc3QgTV9vZmZzZXRfMTAgPSBfTVtvZmZzZXQgKyAxMF07XG4gICAgY29uc3QgTV9vZmZzZXRfMTEgPSBfTVtvZmZzZXQgKyAxMV07XG4gICAgY29uc3QgTV9vZmZzZXRfMTIgPSBfTVtvZmZzZXQgKyAxMl07XG4gICAgY29uc3QgTV9vZmZzZXRfMTMgPSBfTVtvZmZzZXQgKyAxM107XG4gICAgY29uc3QgTV9vZmZzZXRfMTQgPSBfTVtvZmZzZXQgKyAxNF07XG4gICAgY29uc3QgTV9vZmZzZXRfMTUgPSBfTVtvZmZzZXQgKyAxNV07IC8vIFdvcmtpbmcgdmFyaWFsYmVzXG5cbiAgICBsZXQgYSA9IEhbMF07XG4gICAgbGV0IGIgPSBIWzFdO1xuICAgIGxldCBjID0gSFsyXTtcbiAgICBsZXQgZCA9IEhbM107IC8vIENvbXB1dGF0aW9uXG5cbiAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgNywgVFswXSk7XG4gICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsIDEyLCBUWzFdKTtcbiAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgMTcsIFRbMl0pO1xuICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAyMiwgVFszXSk7XG4gICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsIDcsIFRbNF0pO1xuICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAxMiwgVFs1XSk7XG4gICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsIDE3LCBUWzZdKTtcbiAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgMjIsIFRbN10pO1xuICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCA3LCBUWzhdKTtcbiAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgMTIsIFRbOV0pO1xuICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcbiAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG4gICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCBUWzEyXSk7XG4gICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcbiAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG4gICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsIDUsIFRbMTZdKTtcbiAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgOSwgVFsxN10pO1xuICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcbiAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgMjAsIFRbMTldKTtcbiAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgNSwgVFsyMF0pO1xuICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgVFsyMV0pO1xuICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcbiAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgMjAsIFRbMjNdKTtcbiAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgNSwgVFsyNF0pO1xuICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgVFsyNV0pO1xuICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAxNCwgVFsyNl0pO1xuICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAyMCwgVFsyN10pO1xuICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgVFsyOF0pO1xuICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCA5LCBUWzI5XSk7XG4gICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsIDE0LCBUWzMwXSk7XG4gICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xuICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCA0LCBUWzMyXSk7XG4gICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsIDExLCBUWzMzXSk7XG4gICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcbiAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgNCwgVFszNl0pO1xuICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAxMSwgVFszN10pO1xuICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAxNiwgVFszOF0pO1xuICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcbiAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsIFRbNDBdKTtcbiAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgMTEsIFRbNDFdKTtcbiAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgMTYsIFRbNDJdKTtcbiAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgMjMsIFRbNDNdKTtcbiAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgNCwgVFs0NF0pO1xuICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcbiAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG4gICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsIDIzLCBUWzQ3XSk7XG4gICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsIDYsIFRbNDhdKTtcbiAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgMTAsIFRbNDldKTtcbiAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG4gICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsIDIxLCBUWzUxXSk7XG4gICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCBUWzUyXSk7XG4gICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsIDEwLCBUWzUzXSk7XG4gICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAyMSwgVFs1NV0pO1xuICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCA2LCBUWzU2XSk7XG4gICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAxNSwgVFs1OF0pO1xuICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcbiAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgNiwgVFs2MF0pO1xuICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcbiAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgMTUsIFRbNjJdKTtcbiAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgMjEsIFRbNjNdKTsgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblxuICAgIEhbMF0gPSBIWzBdICsgYSB8IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiIHwgMDtcbiAgICBIWzJdID0gSFsyXSArIGMgfCAwO1xuICAgIEhbM10gPSBIWzNdICsgZCB8IDA7XG4gIH1cbiAgLyogZXNsaW50LWVuc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG4gICAgY29uc3QgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgIGNvbnN0IG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4OyAvLyBBZGQgcGFkZGluZ1xuXG4gICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAyNCAtIG5CaXRzTGVmdCAlIDMyO1xuICAgIGNvbnN0IG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuICAgIGNvbnN0IG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcbiAgICBkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTVdID0gKG5CaXRzVG90YWxIIDw8IDggfCBuQml0c1RvdGFsSCA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChuQml0c1RvdGFsSCA8PCAyNCB8IG5CaXRzVG90YWxIID4+PiA4KSAmIDB4ZmYwMGZmMDA7XG4gICAgZGF0YVdvcmRzWyhuQml0c0xlZnQgKyA2NCA+Pj4gOSA8PCA0KSArIDE0XSA9IChuQml0c1RvdGFsTCA8PCA4IHwgbkJpdHNUb3RhbEwgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAobkJpdHNUb3RhbEwgPDwgMjQgfCBuQml0c1RvdGFsTCA+Pj4gOCkgJiAweGZmMDBmZjAwO1xuICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDsgLy8gSGFzaCBmaW5hbCBibG9ja3NcblxuICAgIHRoaXMuX3Byb2Nlc3MoKTsgLy8gU2hvcnRjdXRzXG5cblxuICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9oYXNoO1xuICAgIGNvbnN0IEggPSBoYXNoLndvcmRzOyAvLyBTd2FwIGVuZGlhblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCBIX2kgPSBIW2ldO1xuICAgICAgSFtpXSA9IChIX2kgPDwgOCB8IEhfaSA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChIX2kgPDwgMjQgfCBIX2kgPj4+IDgpICYgMHhmZjAwZmYwMDtcbiAgICB9IC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cblxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG59XG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcbiAqL1xuXG5cbmNvbnN0IE1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENUFsZ28pO1xuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcbiAqL1xuXG5cbmNvbnN0IEhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1QWxnbyk7XG4vKipcbiAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxuICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcbiAqL1xuXG5cbmNsYXNzIEV2cEtERkFsZ28gZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuICAgKiAgICAgY29uc3Qga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcbiAgICogICAgIGNvbnN0IGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG4gICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuICAgICAqL1xuXG4gICAgdGhpcy5jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHtcbiAgICAgIGtleVNpemU6IDEyOCAvIDMyLFxuICAgICAgaGFzaGVyOiBNRDVBbGdvLFxuICAgICAgaXRlcmF0aW9uczogMVxuICAgIH0sIGNmZyk7XG4gIH1cbiAgLyoqXG4gICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG4gICAqL1xuXG5cbiAgY29tcHV0ZShwYXNzd29yZCwgc2FsdCkge1xuICAgIGxldCBibG9jazsgLy8gU2hvcnRjdXRcblxuICAgIGNvbnN0IHtcbiAgICAgIGNmZ1xuICAgIH0gPSB0aGlzOyAvLyBJbml0IGhhc2hlclxuXG4gICAgY29uc3QgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTsgLy8gSW5pdGlhbCB2YWx1ZXNcblxuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7IC8vIFNob3J0Y3V0c1xuXG4gICAgY29uc3QgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3JkcztcbiAgICBjb25zdCB7XG4gICAgICBrZXlTaXplLFxuICAgICAgaXRlcmF0aW9uc1xuICAgIH0gPSBjZmc7IC8vIEdlbmVyYXRlIGtleVxuXG4gICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG4gICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG4gICAgICBoYXNoZXIucmVzZXQoKTsgLy8gSXRlcmF0aW9uc1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkgKz0gMSkge1xuICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG4gICAgICAgIGhhc2hlci5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG4gICAgfVxuXG4gICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuICAgIHJldHVybiBkZXJpdmVkS2V5O1xuICB9XG5cbn1cbi8qKlxuICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcbiAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG4gKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuICovXG5cblxuY29uc3QgRXZwS0RGID0gKHBhc3N3b3JkLCBzYWx0LCBjZmcpID0+IEV2cEtERkFsZ28uY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cbiAqL1xuXG5cbmNsYXNzIENpcGhlciBleHRlbmRzIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShcbiAgICogICAgICAgQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH1cbiAgICogICAgICk7XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleVNpemUgPSAxMjggLyAzMjtcbiAgICB0aGlzLml2U2l6ZSA9IDEyOCAvIDMyO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKi9cblxuICAgIHRoaXMuY2ZnID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZSgpLCBjZmcpOyAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XG5cbiAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG4gICAgdGhpcy5fa2V5ID0ga2V5OyAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG4gICAqL1xuXG5cbiAgc3RhdGljIGNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcbiAgICovXG5cblxuICBzdGF0aWMgY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG4gICAqL1xuXG5cbiAgc3RhdGljIF9jcmVhdGVIZWxwZXIoU3ViQ2lwaGVyKSB7XG4gICAgY29uc3Qgc2VsZWN0Q2lwaGVyU3RyYXRlZ3kgPSBrZXkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZykge1xuICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KFN1YkNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuICAgICAgfSxcblxuICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KFN1YkNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICAgICAgfVxuXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG4gICAqL1xuXG5cbiAgcmVzZXQoKSB7XG4gICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcbiAgICBzdXBlci5yZXNldC5jYWxsKHRoaXMpOyAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXG4gICAgdGhpcy5fZG9SZXNldCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcbiAgICogICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XG4gICAqL1xuXG5cbiAgcHJvY2VzcyhkYXRhVXBkYXRlKSB7XG4gICAgLy8gQXBwZW5kXG4gICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpOyAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3NcblxuXG4gICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cbiAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG4gICAqICAgICBjb25zdCBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcbiAgICogICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgKi9cblxuXG4gIGZpbmFsaXplKGRhdGFVcGRhdGUpIHtcbiAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuICAgIGlmIChkYXRhVXBkYXRlKSB7XG4gICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG4gICAgfSAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXG5cbiAgICBjb25zdCBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cbiAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuICB9XG5cbn1cblxuQ2lwaGVyLl9FTkNfWEZPUk1fTU9ERSA9IDE7XG5DaXBoZXIuX0RFQ19YRk9STV9NT0RFID0gMjtcbi8qKlxuICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemVcbiAqXG4gKiAgICAgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXG4gKi9cblxuY2xhc3MgU3RyZWFtQ2lwaGVyIGV4dGVuZHMgQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuYmxvY2tTaXplID0gMTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3NcbiAgICBjb25zdCBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcbiAgfVxuXG59XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG4gKi9cblxuXG5jbGFzcyBCbG9ja0NpcGhlck1vZGUgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNpcGhlciwgaXYpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcbiAgICB0aGlzLl9pdiA9IGl2O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuICAgKi9cblxuXG4gIHN0YXRpYyBjcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdikge1xuICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAqL1xuXG5cbiAgc3RhdGljIGNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2KSB7XG4gICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuICBjb25zdCBfd29yZHMgPSB3b3JkcztcbiAgbGV0IGJsb2NrOyAvLyBTaG9ydGN1dFxuXG4gIGNvbnN0IGl2ID0gdGhpcy5faXY7IC8vIENob29zZSBtaXhpbmcgYmxvY2tcblxuICBpZiAoaXYpIHtcbiAgICBibG9jayA9IGl2OyAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cbiAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcbiAgfSAvLyBYT1IgYmxvY2tzXG5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSArPSAxKSB7XG4gICAgX3dvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xuICB9XG59XG4vKipcbiAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cbiAqL1xuXG5cbmNsYXNzIENCQyBleHRlbmRzIEJsb2NrQ2lwaGVyTW9kZSB7fVxuLyoqXG4gKiBDQkMgZW5jcnlwdG9yLlxuICovXG5cblxuQ0JDLkVuY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgQ0JDIHtcbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICovXG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrU2l6ZVxuICAgIH0gPSBjaXBoZXI7IC8vIFhPUiBhbmQgZW5jcnlwdFxuXG4gICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7IC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXG4gICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuICB9XG5cbn07XG4vKipcbiAqIENCQyBkZWNyeXB0b3IuXG4gKi9cblxuQ0JDLkRlY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgQ0JDIHtcbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICovXG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrU2l6ZVxuICAgIH0gPSBjaXBoZXI7IC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXG4gICAgY29uc3QgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpOyAvLyBEZWNyeXB0IGFuZCBYT1JcblxuICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG4gICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpOyAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cbiAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG4gIH1cblxufTtcbi8qKlxuICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXG4gKi9cblxuY29uc3QgUGtjczcgPSB7XG4gIC8qKlxuICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcbiAgICovXG4gIHBhZChkYXRhLCBibG9ja1NpemUpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDsgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzOyAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG5cbiAgICBjb25zdCBwYWRkaW5nV29yZCA9IG5QYWRkaW5nQnl0ZXMgPDwgMjQgfCBuUGFkZGluZ0J5dGVzIDw8IDE2IHwgblBhZGRpbmdCeXRlcyA8PCA4IHwgblBhZGRpbmdCeXRlczsgLy8gQ3JlYXRlIHBhZGRpbmdcblxuICAgIGNvbnN0IHBhZGRpbmdXb3JkcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcbiAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpOyAvLyBBZGQgcGFkZGluZ1xuXG4gICAgZGF0YS5jb25jYXQocGFkZGluZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcbiAgICovXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7IC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IF9kYXRhLndvcmRzW19kYXRhLnNpZ0J5dGVzIC0gMSA+Pj4gMl0gJiAweGZmOyAvLyBSZW1vdmUgcGFkZGluZ1xuXG4gICAgX2RhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcbiAgfVxuXG59O1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplXG4gKlxuICogICAgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICovXG5cbmNsYXNzIEJsb2NrQ2lwaGVyIGV4dGVuZHMgQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xuICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XG4gICAgICovXG4gICAgc3VwZXIoeGZvcm1Nb2RlLCBrZXksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgbW9kZTogQ0JDLFxuICAgICAgcGFkZGluZzogUGtjczdcbiAgICB9LCBjZmcpKTtcbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDEyOCAvIDMyO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgbGV0IG1vZGVDcmVhdG9yOyAvLyBSZXNldCBjaXBoZXJcblxuICAgIHN1cGVyLnJlc2V0LmNhbGwodGhpcyk7IC8vIFNob3J0Y3V0c1xuXG4gICAgY29uc3Qge1xuICAgICAgY2ZnXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgaXYsXG4gICAgICBtb2RlXG4gICAgfSA9IGNmZzsgLy8gUmVzZXQgYmxvY2sgbW9kZVxuXG4gICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PT0gdGhpcy5jb25zdHJ1Y3Rvci5fRU5DX1hGT1JNX01PREUpIHtcbiAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG4gICAgfSBlbHNlXG4gICAgICAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqL1xuICAgICAge1xuICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yOyAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcblxuICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcbiAgICAgIH1cblxuICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcbiAgICB0aGlzLl9tb2RlLl9fY3JlYXRvciA9IG1vZGVDcmVhdG9yO1xuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIGxldCBmaW5hbFByb2Nlc3NlZEJsb2NrczsgLy8gU2hvcnRjdXRcblxuICAgIGNvbnN0IHtcbiAgICAgIHBhZGRpbmdcbiAgICB9ID0gdGhpcy5jZmc7IC8vIEZpbmFsaXplXG5cbiAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09PSB0aGlzLmNvbnN0cnVjdG9yLl9FTkNfWEZPUk1fTU9ERSkge1xuICAgICAgLy8gUGFkIGRhdGFcbiAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTsgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3NcblxuICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG4gICAgfSBlbHNlXG4gICAgICAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqL1xuICAgICAge1xuICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTsgLy8gVW5wYWQgZGF0YVxuXG4gICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuICB9XG5cbn1cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cbiAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG4gKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG4gKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG4gKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cbiAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXJcbiAqICAgIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICovXG5cblxuY2xhc3MgQ2lwaGVyUGFyYW1zIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG4gICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcbiAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcbiAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG4gICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcbiAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxuICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcbiAgICogICAgICAgICBibG9ja1NpemU6IDQsXG4gICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuICAgKiAgICAgfSk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaXBoZXJQYXJhbXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cbiAgICpcbiAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG4gICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcbiAgICovXG5cblxuICB0b1N0cmluZyhmb3JtYXR0ZXIpIHtcbiAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuICB9XG5cbn1cbi8qKlxuICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuICovXG5cblxuY29uc3QgT3BlblNTTEZvcm1hdHRlciA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG4gICAqL1xuICBzdHJpbmdpZnkoY2lwaGVyUGFyYW1zKSB7XG4gICAgbGV0IHdvcmRBcnJheTsgLy8gU2hvcnRjdXRzXG5cbiAgICBjb25zdCB7XG4gICAgICBjaXBoZXJ0ZXh0LFxuICAgICAgc2FsdFxuICAgIH0gPSBjaXBoZXJQYXJhbXM7IC8vIEZvcm1hdFxuXG4gICAgaWYgKHNhbHQpIHtcbiAgICAgIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKG9wZW5TU0xTdHIpIHtcbiAgICBsZXQgc2FsdDsgLy8gUGFyc2UgYmFzZTY0XG5cbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpOyAvLyBTaG9ydGN1dFxuXG4gICAgY29uc3QgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkczsgLy8gVGVzdCBmb3Igc2FsdFxuXG4gICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT09IDB4NjU2NDVmNWYpIHtcbiAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuICAgICAgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTsgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cbiAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG4gICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuICAgIH1cblxuICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcbiAgICAgIGNpcGhlcnRleHQsXG4gICAgICBzYWx0XG4gICAgfSk7XG4gIH1cblxufTtcbi8qKlxuICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAqL1xuXG5jbGFzcyBTZXJpYWxpemFibGVDaXBoZXIgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgKi9cbiAgc3RhdGljIGVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgIGNvbnN0IF9jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHRoaXMuY2ZnLCBjZmcpOyAvLyBFbmNyeXB0XG5cblxuICAgIGNvbnN0IGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBfY2ZnKTtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpOyAvLyBTaG9ydGN1dFxuXG4gICAgY29uc3QgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZzsgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcblxuICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcbiAgICAgIGNpcGhlcnRleHQsXG4gICAgICBrZXksXG4gICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG4gICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcbiAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuICAgICAgYmxvY2tTaXplOiBlbmNyeXB0b3IuYmxvY2tTaXplLFxuICAgICAgZm9ybWF0dGVyOiBfY2ZnLmZvcm1hdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksXG4gICAqICAgICAgICAgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlclxuICAgKiAgICAgICAuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LFxuICAgKiAgICAgICAgIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgKi9cblxuXG4gIHN0YXRpYyBkZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcbiAgICBsZXQgX2NpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0OyAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblxuICAgIGNvbnN0IF9jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHRoaXMuY2ZnLCBjZmcpOyAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblxuXG4gICAgX2NpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShfY2lwaGVydGV4dCwgX2NmZy5mb3JtYXQpOyAvLyBEZWNyeXB0XG5cbiAgICBjb25zdCBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgX2NmZykuZmluYWxpemUoX2NpcGhlcnRleHQuY2lwaGVydGV4dCk7XG4gICAgcmV0dXJuIHBsYWludGV4dDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcbiAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG4gICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlclxuICAgKiAgICAgICAuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcbiAgICovXG5cblxuICBzdGF0aWMgX3BhcnNlKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gIH1cblxufVxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKlxuICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdFxuICpcbiAqICAgIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuXG4gKiAgICBEZWZhdWx0OiBPcGVuU1NMXG4gKi9cblxuXG5TZXJpYWxpemFibGVDaXBoZXIuY2ZnID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZSgpLCB7XG4gIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxufSk7XG4vKipcbiAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gKi9cblxuY29uc3QgT3BlblNTTEtkZiA9IHtcbiAgLyoqXG4gICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdFxuICAgKiAgICAgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG4gICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuICAgKi9cbiAgZXhlY3V0ZShwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG4gICAgbGV0IF9zYWx0ID0gc2FsdDsgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcblxuICAgIGlmICghX3NhbHQpIHtcbiAgICAgIF9zYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NCAvIDgpO1xuICAgIH0gLy8gRGVyaXZlIGtleSBhbmQgSVZcblxuXG4gICAgY29uc3Qga2V5ID0gRXZwS0RGQWxnby5jcmVhdGUoe1xuICAgICAga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZVxuICAgIH0pLmNvbXB1dGUocGFzc3dvcmQsIF9zYWx0KTsgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXG4gICAgY29uc3QgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG4gICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7IC8vIFJldHVybiBwYXJhbXNcblxuICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcbiAgICAgIGtleSxcbiAgICAgIGl2LFxuICAgICAgc2FsdDogX3NhbHRcbiAgICB9KTtcbiAgfVxuXG59O1xuLyoqXG4gKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG4gKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICovXG5cbmNsYXNzIFBhc3N3b3JkQmFzZWRDaXBoZXIgZXh0ZW5kcyBTZXJpYWxpemFibGVDaXBoZXIge1xuICAvKipcbiAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcbiAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXJcbiAgICogICAgICAgLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICovXG4gIHN0YXRpYyBlbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgIGNvbnN0IF9jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHRoaXMuY2ZnLCBjZmcpOyAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblxuXG4gICAgY29uc3QgZGVyaXZlZFBhcmFtcyA9IF9jZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTsgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXG5cbiAgICBfY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjsgLy8gRW5jcnlwdFxuXG4gICAgY29uc3QgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgX2NmZyk7IC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuXG4gICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcbiAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgfVxuICAvKipcbiAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXJcbiAgICogICAgICAgLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsXG4gICAqICAgICAgICAgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyXG4gICAqICAgICAgIC5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLFxuICAgKiAgICAgICAgIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICovXG5cblxuICBzdGF0aWMgZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcbiAgICBsZXQgX2NpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0OyAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblxuICAgIGNvbnN0IF9jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHRoaXMuY2ZnLCBjZmcpOyAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblxuXG4gICAgX2NpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShfY2lwaGVydGV4dCwgX2NmZy5mb3JtYXQpOyAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblxuICAgIGNvbnN0IGRlcml2ZWRQYXJhbXMgPSBfY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgX2NpcGhlcnRleHQuc2FsdCk7IC8vIEFkZCBJViB0byBjb25maWdcblxuXG4gICAgX2NmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7IC8vIERlY3J5cHRcblxuICAgIGNvbnN0IHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBfY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIF9jZmcpO1xuICAgIHJldHVybiBwbGFpbnRleHQ7XG4gIH1cblxufVxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKlxuICogQHByb3BlcnR5IHtLREZ9IGtkZlxuICogICAgIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cbiAqICAgICBEZWZhdWx0OiBPcGVuU1NMXG4gKi9cblxuXG5QYXNzd29yZEJhc2VkQ2lwaGVyLmNmZyA9IE9iamVjdC5hc3NpZ24oU2VyaWFsaXphYmxlQ2lwaGVyLmNmZywge1xuICBrZGY6IE9wZW5TU0xLZGZcbn0pO1xuXG5jb25zdCBzd2FwRW5kaWFuID0gd29yZCA9PiB3b3JkIDw8IDggJiAweGZmMDBmZjAwIHwgd29yZCA+Pj4gOCAmIDB4MDBmZjAwZmY7XG4vKipcbiAqIFVURi0xNiBCRSBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuXG5cbmNvbnN0IFV0ZjE2QkUgPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgQkUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCB1dGYxNlN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGYxNi5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICovXG4gIHN0cmluZ2lmeSh3b3JkQXJyYXkpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB7XG4gICAgICB3b3JkcyxcbiAgICAgIHNpZ0J5dGVzXG4gICAgfSA9IHdvcmRBcnJheTsgLy8gQ29udmVydFxuXG4gICAgY29uc3QgdXRmMTZDaGFycyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSB3b3Jkc1tpID4+PiAyXSA+Pj4gMTYgLSBpICUgNCAqIDggJiAweGZmZmY7XG4gICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBVVEYtMTYgQkUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTYucGFyc2UodXRmMTZTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UodXRmMTZTdHIpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoOyAvLyBDb252ZXJ0XG5cbiAgICBjb25zdCB3b3JkcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8IDE2IC0gaSAlIDIgKiAxNjtcbiAgICB9XG5cbiAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcbiAgfVxuXG59O1xuY29uc3QgVXRmMTYgPSBVdGYxNkJFO1xuLyoqXG4gKiBVVEYtMTYgTEUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG4gKi9cblxuY29uc3QgVXRmMTZMRSA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBMRSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IHV0ZjE2U3RyID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAqL1xuICBzdHJpbmdpZnkod29yZEFycmF5KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qge1xuICAgICAgd29yZHMsXG4gICAgICBzaWdCeXRlc1xuICAgIH0gPSB3b3JkQXJyYXk7IC8vIENvbnZlcnRcblxuICAgIGNvbnN0IHV0ZjE2Q2hhcnMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gc3dhcEVuZGlhbih3b3Jkc1tpID4+PiAyXSA+Pj4gMTYgLSBpICUgNCAqIDggJiAweGZmZmYpO1xuICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVVRGLTE2IExFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUucGFyc2UodXRmMTZTdHIpO1xuICAgKi9cbiAgcGFyc2UodXRmMTZTdHIpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoOyAvLyBDb252ZXJ0XG5cbiAgICBjb25zdCB3b3JkcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB3b3Jkc1tpID4+PiAxXSB8PSBzd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgMTYgLSBpICUgMiAqIDE2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcbiAgfVxuXG59OyAvLyBSZXVzYWJsZSBvYmplY3RcblxuY29uc3QgVyA9IFtdO1xuLyoqXG4gKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cbiAqL1xuXG5jbGFzcyBTSEExQWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5KFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXSk7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBIID0gdGhpcy5faGFzaC53b3JkczsgLy8gV29ya2luZyB2YXJpYWJsZXNcblxuICAgIGxldCBhID0gSFswXTtcbiAgICBsZXQgYiA9IEhbMV07XG4gICAgbGV0IGMgPSBIWzJdO1xuICAgIGxldCBkID0gSFszXTtcbiAgICBsZXQgZSA9IEhbNF07IC8vIENvbXB1dGF0aW9uXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgIFdbaV0gPSBuIDw8IDEgfCBuID4+PiAzMTtcbiAgICAgIH1cblxuICAgICAgbGV0IHQgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgZSArIFdbaV07XG5cbiAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgdCArPSAoYiAmIGMgfCB+YiAmIGQpICsgMHg1YTgyNzk5OTtcbiAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG4gICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgKyAweDZlZDllYmExO1xuICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcbiAgICAgICAgdCArPSAoYiAmIGMgfCBiICYgZCB8IGMgJiBkKSAtIDB4NzBlNDQzMjQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgLyogaWYgKGkgPCA4MCkgKi9cbiAgICAgICAge1xuICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xuICAgICAgICB9XG5cbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gYiA8PCAzMCB8IGIgPj4+IDI7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH0gLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblxuXG4gICAgSFswXSA9IEhbMF0gKyBhIHwgMDtcbiAgICBIWzFdID0gSFsxXSArIGIgfCAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyB8IDA7XG4gICAgSFszXSA9IEhbM10gKyBkIHwgMDtcbiAgICBIWzRdID0gSFs0XSArIGUgfCAwO1xuICB9XG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcbiAgICBjb25zdCBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG4gICAgY29uc3QgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7IC8vIEFkZCBwYWRkaW5nXG5cbiAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8IDI0IC0gbkJpdHNMZWZ0ICUgMzI7XG4gICAgZGF0YVdvcmRzWyhuQml0c0xlZnQgKyA2NCA+Pj4gOSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcbiAgICBkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcbiAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7IC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cbiAgICB0aGlzLl9wcm9jZXNzKCk7IC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cblxuICAgIHJldHVybiB0aGlzLl9oYXNoO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG59XG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSgnbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSh3b3JkQXJyYXkpO1xuICovXG5cblxuY29uc3QgU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTFBbGdvKTtcbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuICovXG5cblxuY29uc3QgSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMUFsZ28pOyAvLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuXG5cbmNvbnN0IEggPSBbXTtcbmNvbnN0IEsgPSBbXTsgLy8gQ29tcHV0ZSBjb25zdGFudHNcblxuY29uc3QgaXNQcmltZSA9IG4gPT4ge1xuICBjb25zdCBzcXJ0TiA9IE1hdGguc3FydChuKTtcblxuICBmb3IgKGxldCBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvciArPSAxKSB7XG4gICAgaWYgKCEobiAlIGZhY3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGdldEZyYWN0aW9uYWxCaXRzID0gbiA9PiAobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDAgfCAwO1xuXG5sZXQgbiA9IDI7XG5sZXQgblByaW1lID0gMDtcblxud2hpbGUgKG5QcmltZSA8IDY0KSB7XG4gIGlmIChpc1ByaW1lKG4pKSB7XG4gICAgaWYgKG5QcmltZSA8IDgpIHtcbiAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKG4gKiogKDEgLyAyKSk7XG4gICAgfVxuXG4gICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMobiAqKiAoMSAvIDMpKTtcbiAgICBuUHJpbWUgKz0gMTtcbiAgfVxuXG4gIG4gKz0gMTtcbn0gLy8gUmV1c2FibGUgb2JqZWN0XG5cblxuY29uc3QgVyQxID0gW107XG4vKipcbiAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG4gKi9cblxuY2xhc3MgU0hBMjU2QWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5KEguc2xpY2UoMCkpO1xuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKE0sIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgX0ggPSB0aGlzLl9oYXNoLndvcmRzOyAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXG4gICAgbGV0IGEgPSBfSFswXTtcbiAgICBsZXQgYiA9IF9IWzFdO1xuICAgIGxldCBjID0gX0hbMl07XG4gICAgbGV0IGQgPSBfSFszXTtcbiAgICBsZXQgZSA9IF9IWzRdO1xuICAgIGxldCBmID0gX0hbNV07XG4gICAgbGV0IGcgPSBfSFs2XTtcbiAgICBsZXQgaCA9IF9IWzddOyAvLyBDb21wdXRhdGlvblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSArPSAxKSB7XG4gICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIFckMVtpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZ2FtbWEweCA9IFckMVtpIC0gMTVdO1xuICAgICAgICBjb25zdCBnYW1tYTAgPSAoZ2FtbWEweCA8PCAyNSB8IGdhbW1hMHggPj4+IDcpIF4gKGdhbW1hMHggPDwgMTQgfCBnYW1tYTB4ID4+PiAxOCkgXiBnYW1tYTB4ID4+PiAzO1xuICAgICAgICBjb25zdCBnYW1tYTF4ID0gVyQxW2kgLSAyXTtcbiAgICAgICAgY29uc3QgZ2FtbWExID0gKGdhbW1hMXggPDwgMTUgfCBnYW1tYTF4ID4+PiAxNykgXiAoZ2FtbWExeCA8PCAxMyB8IGdhbW1hMXggPj4+IDE5KSBeIGdhbW1hMXggPj4+IDEwO1xuICAgICAgICBXJDFbaV0gPSBnYW1tYTAgKyBXJDFbaSAtIDddICsgZ2FtbWExICsgVyQxW2kgLSAxNl07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoID0gZSAmIGYgXiB+ZSAmIGc7XG4gICAgICBjb25zdCBtYWogPSBhICYgYiBeIGEgJiBjIF4gYiAmIGM7XG4gICAgICBjb25zdCBzaWdtYTAgPSAoYSA8PCAzMCB8IGEgPj4+IDIpIF4gKGEgPDwgMTkgfCBhID4+PiAxMykgXiAoYSA8PCAxMCB8IGEgPj4+IDIyKTtcbiAgICAgIGNvbnN0IHNpZ21hMSA9IChlIDw8IDI2IHwgZSA+Pj4gNikgXiAoZSA8PCAyMSB8IGUgPj4+IDExKSBeIChlIDw8IDcgfCBlID4+PiAyNSk7XG4gICAgICBjb25zdCB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXJDFbaV07XG4gICAgICBjb25zdCB0MiA9IHNpZ21hMCArIG1hajtcbiAgICAgIGggPSBnO1xuICAgICAgZyA9IGY7XG4gICAgICBmID0gZTtcbiAgICAgIGUgPSBkICsgdDEgfCAwO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gYjtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQxICsgdDIgfCAwO1xuICAgIH0gLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblxuXG4gICAgX0hbMF0gPSBfSFswXSArIGEgfCAwO1xuICAgIF9IWzFdID0gX0hbMV0gKyBiIHwgMDtcbiAgICBfSFsyXSA9IF9IWzJdICsgYyB8IDA7XG4gICAgX0hbM10gPSBfSFszXSArIGQgfCAwO1xuICAgIF9IWzRdID0gX0hbNF0gKyBlIHwgMDtcbiAgICBfSFs1XSA9IF9IWzVdICsgZiB8IDA7XG4gICAgX0hbNl0gPSBfSFs2XSArIGcgfCAwO1xuICAgIF9IWzddID0gX0hbN10gKyBoIHwgMDtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG4gICAgY29uc3QgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgIGNvbnN0IG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4OyAvLyBBZGQgcGFkZGluZ1xuXG4gICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAyNCAtIG5CaXRzTGVmdCAlIDMyO1xuICAgIGRhdGFXb3Jkc1sobkJpdHNMZWZ0ICsgNjQgPj4+IDkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgZGF0YVdvcmRzWyhuQml0c0xlZnQgKyA2NCA+Pj4gOSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0OyAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXG4gICAgdGhpcy5fcHJvY2VzcygpOyAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXG5cbiAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gc3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxufVxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1NignbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KHdvcmRBcnJheSk7XG4gKi9cblxuXG5jb25zdCBTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTZBbGdvKTtcbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG4gKi9cblxuXG5jb25zdCBIbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1NkFsZ28pO1xuLyoqXG4gKiBTSEEtMjI0IGhhc2ggYWxnb3JpdGhtLlxuICovXG5cblxuY2xhc3MgU0hBMjI0QWxnbyBleHRlbmRzIFNIQTI1NkFsZ28ge1xuICBfZG9SZXNldCgpIHtcbiAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheShbMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSwgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNF0pO1xuICB9XG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgY29uc3QgaGFzaCA9IHN1cGVyLl9kb0ZpbmFsaXplLmNhbGwodGhpcyk7XG5cbiAgICBoYXNoLnNpZ0J5dGVzIC09IDQ7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxufVxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCgnbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjI0KHdvcmRBcnJheSk7XG4gKi9cblxuXG5jb25zdCBTSEEyMjQgPSBTSEEyNTZBbGdvLl9jcmVhdGVIZWxwZXIoU0hBMjI0QWxnbyk7XG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTIyNChtZXNzYWdlLCBrZXkpO1xuICovXG5cblxuY29uc3QgSG1hY1NIQTIyNCA9IFNIQTI1NkFsZ28uX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjI0QWxnbyk7IC8vIENvbnN0YW50c1xuXG5cbmNvbnN0IEskMSA9IFtuZXcgWDY0V29yZCgweDQyOGEyZjk4LCAweGQ3MjhhZTIyKSwgbmV3IFg2NFdvcmQoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksIG5ldyBYNjRXb3JkKDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYpLCBuZXcgWDY0V29yZCgweGU5YjVkYmE1LCAweDgxODlkYmJjKSwgbmV3IFg2NFdvcmQoMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCksIG5ldyBYNjRXb3JkKDB4NTlmMTExZjEsIDB4YjYwNWQwMTkpLCBuZXcgWDY0V29yZCgweDkyM2Y4MmE0LCAweGFmMTk0ZjliKSwgbmV3IFg2NFdvcmQoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksIG5ldyBYNjRXb3JkKDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIpLCBuZXcgWDY0V29yZCgweDEyODM1YjAxLCAweDQ1NzA2ZmJlKSwgbmV3IFg2NFdvcmQoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksIG5ldyBYNjRXb3JkKDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIpLCBuZXcgWDY0V29yZCgweDcyYmU1ZDc0LCAweGYyN2I4OTZmKSwgbmV3IFg2NFdvcmQoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksIG5ldyBYNjRXb3JkKDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUpLCBuZXcgWDY0V29yZCgweGMxOWJmMTc0LCAweGNmNjkyNjk0KSwgbmV3IFg2NFdvcmQoMHhlNDliNjljMSwgMHg5ZWYxNGFkMiksIG5ldyBYNjRXb3JkKDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMpLCBuZXcgWDY0V29yZCgweDBmYzE5ZGM2LCAweDhiOGNkNWI1KSwgbmV3IFg2NFdvcmQoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksIG5ldyBYNjRXb3JkKDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUpLCBuZXcgWDY0V29yZCgweDRhNzQ4NGFhLCAweDZlYTZlNDgzKSwgbmV3IFg2NFdvcmQoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksIG5ldyBYNjRXb3JkKDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUpLCBuZXcgWDY0V29yZCgweDk4M2U1MTUyLCAweGVlNjZkZmFiKSwgbmV3IFg2NFdvcmQoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksIG5ldyBYNjRXb3JkKDB4YjAwMzI3YzgsIDB4OThmYjIxM2YpLCBuZXcgWDY0V29yZCgweGJmNTk3ZmM3LCAweGJlZWYwZWU0KSwgbmV3IFg2NFdvcmQoMHhjNmUwMGJmMywgMHgzZGE4OGZjMiksIG5ldyBYNjRXb3JkKDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUpLCBuZXcgWDY0V29yZCgweDA2Y2E2MzUxLCAweGUwMDM4MjZmKSwgbmV3IFg2NFdvcmQoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksIG5ldyBYNjRXb3JkKDB4MjdiNzBhODUsIDB4NDZkMjJmZmMpLCBuZXcgWDY0V29yZCgweDJlMWIyMTM4LCAweDVjMjZjOTI2KSwgbmV3IFg2NFdvcmQoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksIG5ldyBYNjRXb3JkKDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYpLCBuZXcgWDY0V29yZCgweDY1MGE3MzU0LCAweDhiYWY2M2RlKSwgbmV3IFg2NFdvcmQoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksIG5ldyBYNjRXb3JkKDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYpLCBuZXcgWDY0V29yZCgweDkyNzIyYzg1LCAweDE0ODIzNTNiKSwgbmV3IFg2NFdvcmQoMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCksIG5ldyBYNjRXb3JkKDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEpLCBuZXcgWDY0V29yZCgweGMyNGI4YjcwLCAweGQwZjg5NzkxKSwgbmV3IFg2NFdvcmQoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksIG5ldyBYNjRXb3JkKDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgpLCBuZXcgWDY0V29yZCgweGQ2OTkwNjI0LCAweDU1NjVhOTEwKSwgbmV3IFg2NFdvcmQoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksIG5ldyBYNjRXb3JkKDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgpLCBuZXcgWDY0V29yZCgweDE5YTRjMTE2LCAweGI4ZDJkMGM4KSwgbmV3IFg2NFdvcmQoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksIG5ldyBYNjRXb3JkKDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTkpLCBuZXcgWDY0V29yZCgweDM0YjBiY2I1LCAweGUxOWI0OGE4KSwgbmV3IFg2NFdvcmQoMHgzOTFjMGNiMywgMHhjNWM5NWE2MyksIG5ldyBYNjRXb3JkKDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IpLCBuZXcgWDY0V29yZCgweDViOWNjYTRmLCAweDc3NjNlMzczKSwgbmV3IFg2NFdvcmQoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksIG5ldyBYNjRXb3JkKDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMpLCBuZXcgWDY0V29yZCgweDc4YTU2MzZmLCAweDQzMTcyZjYwKSwgbmV3IFg2NFdvcmQoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksIG5ldyBYNjRXb3JkKDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMpLCBuZXcgWDY0V29yZCgweDkwYmVmZmZhLCAweDIzNjMxZTI4KSwgbmV3IFg2NFdvcmQoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksIG5ldyBYNjRXb3JkKDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUpLCBuZXcgWDY0V29yZCgweGM2NzE3OGYyLCAweGUzNzI1MzJiKSwgbmV3IFg2NFdvcmQoMHhjYTI3M2VjZSwgMHhlYTI2NjE5YyksIG5ldyBYNjRXb3JkKDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcpLCBuZXcgWDY0V29yZCgweGVhZGE3ZGQ2LCAweGNkZTBlYjFlKSwgbmV3IFg2NFdvcmQoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksIG5ldyBYNjRXb3JkKDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEpLCBuZXcgWDY0V29yZCgweDBhNjM3ZGM1LCAweGEyYzg5OGE2KSwgbmV3IFg2NFdvcmQoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksIG5ldyBYNjRXb3JkKDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIpLCBuZXcgWDY0V29yZCgweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0KSwgbmV3IFg2NFdvcmQoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksIG5ldyBYNjRXb3JkKDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMpLCBuZXcgWDY0V29yZCgweDQzMWQ2N2M0LCAweDljMTAwZDRjKSwgbmV3IFg2NFdvcmQoMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiksIG5ldyBYNjRXb3JkKDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEpLCBuZXcgWDY0V29yZCgweDVmY2I2ZmFiLCAweDNhZDZmYWVjKSwgbmV3IFg2NFdvcmQoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNyldOyAvLyBSZXVzYWJsZSBvYmplY3RzXG5cbmNvbnN0IFckMiA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgVyQyW2ldID0gbmV3IFg2NFdvcmQoKTtcbn1cbi8qKlxuICogU0hBLTUxMiBoYXNoIGFsZ29yaXRobS5cbiAqL1xuXG5cbmNsYXNzIFNIQTUxMkFsZ28gZXh0ZW5kcyBIYXNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmxvY2tTaXplID0gMTAyNCAvIDMyO1xuICB9XG5cbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBYNjRXb3JkQXJyYXkoW25ldyBYNjRXb3JkKDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgpLCBuZXcgWDY0V29yZCgweGJiNjdhZTg1LCAweDg0Y2FhNzNiKSwgbmV3IFg2NFdvcmQoMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiksIG5ldyBYNjRXb3JkKDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEpLCBuZXcgWDY0V29yZCgweDUxMGU1MjdmLCAweGFkZTY4MmQxKSwgbmV3IFg2NFdvcmQoMHg5YjA1Njg4YywgMHgyYjNlNmMxZiksIG5ldyBYNjRXb3JkKDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIpLCBuZXcgWDY0V29yZCgweDViZTBjZDE5LCAweDEzN2UyMTc5KV0pO1xuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKE0sIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IEggPSB0aGlzLl9oYXNoLndvcmRzO1xuICAgIGNvbnN0IEgwID0gSFswXTtcbiAgICBjb25zdCBIMSA9IEhbMV07XG4gICAgY29uc3QgSDIgPSBIWzJdO1xuICAgIGNvbnN0IEgzID0gSFszXTtcbiAgICBjb25zdCBINCA9IEhbNF07XG4gICAgY29uc3QgSDUgPSBIWzVdO1xuICAgIGNvbnN0IEg2ID0gSFs2XTtcbiAgICBjb25zdCBINyA9IEhbN107XG4gICAgY29uc3QgSDBoID0gSDAuaGlnaDtcbiAgICBsZXQgSDBsID0gSDAubG93O1xuICAgIGNvbnN0IEgxaCA9IEgxLmhpZ2g7XG4gICAgbGV0IEgxbCA9IEgxLmxvdztcbiAgICBjb25zdCBIMmggPSBIMi5oaWdoO1xuICAgIGxldCBIMmwgPSBIMi5sb3c7XG4gICAgY29uc3QgSDNoID0gSDMuaGlnaDtcbiAgICBsZXQgSDNsID0gSDMubG93O1xuICAgIGNvbnN0IEg0aCA9IEg0LmhpZ2g7XG4gICAgbGV0IEg0bCA9IEg0LmxvdztcbiAgICBjb25zdCBINWggPSBINS5oaWdoO1xuICAgIGxldCBINWwgPSBINS5sb3c7XG4gICAgY29uc3QgSDZoID0gSDYuaGlnaDtcbiAgICBsZXQgSDZsID0gSDYubG93O1xuICAgIGNvbnN0IEg3aCA9IEg3LmhpZ2g7XG4gICAgbGV0IEg3bCA9IEg3LmxvdzsgLy8gV29ya2luZyB2YXJpYWJsZXNcblxuICAgIGxldCBhaCA9IEgwaDtcbiAgICBsZXQgYWwgPSBIMGw7XG4gICAgbGV0IGJoID0gSDFoO1xuICAgIGxldCBibCA9IEgxbDtcbiAgICBsZXQgY2ggPSBIMmg7XG4gICAgbGV0IGNsID0gSDJsO1xuICAgIGxldCBkaCA9IEgzaDtcbiAgICBsZXQgZGwgPSBIM2w7XG4gICAgbGV0IGVoID0gSDRoO1xuICAgIGxldCBlbCA9IEg0bDtcbiAgICBsZXQgZmggPSBINWg7XG4gICAgbGV0IGZsID0gSDVsO1xuICAgIGxldCBnaCA9IEg2aDtcbiAgICBsZXQgZ2wgPSBINmw7XG4gICAgbGV0IGhoID0gSDdoO1xuICAgIGxldCBobCA9IEg3bDsgLy8gUm91bmRzXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICAgIGxldCBXaWw7XG4gICAgICBsZXQgV2loOyAvLyBTaG9ydGN1dFxuXG4gICAgICBjb25zdCBXaSA9IFckMltpXTsgLy8gRXh0ZW5kIG1lc3NhZ2VcblxuICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICBXaS5oaWdoID0gTVtvZmZzZXQgKyBpICogMl0gfCAwO1xuICAgICAgICBXaWggPSBXaS5oaWdoO1xuICAgICAgICBXaS5sb3cgPSBNW29mZnNldCArIGkgKiAyICsgMV0gfCAwO1xuICAgICAgICBXaWwgPSBXaS5sb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHYW1tYTBcbiAgICAgICAgY29uc3QgZ2FtbWEweCA9IFckMltpIC0gMTVdO1xuICAgICAgICBjb25zdCBnYW1tYTB4aCA9IGdhbW1hMHguaGlnaDtcbiAgICAgICAgY29uc3QgZ2FtbWEweGwgPSBnYW1tYTB4LmxvdztcbiAgICAgICAgY29uc3QgZ2FtbWEwaCA9IChnYW1tYTB4aCA+Pj4gMSB8IGdhbW1hMHhsIDw8IDMxKSBeIChnYW1tYTB4aCA+Pj4gOCB8IGdhbW1hMHhsIDw8IDI0KSBeIGdhbW1hMHhoID4+PiA3O1xuICAgICAgICBjb25zdCBnYW1tYTBsID0gKGdhbW1hMHhsID4+PiAxIHwgZ2FtbWEweGggPDwgMzEpIF4gKGdhbW1hMHhsID4+PiA4IHwgZ2FtbWEweGggPDwgMjQpIF4gKGdhbW1hMHhsID4+PiA3IHwgZ2FtbWEweGggPDwgMjUpOyAvLyBHYW1tYTFcblxuICAgICAgICBjb25zdCBnYW1tYTF4ID0gVyQyW2kgLSAyXTtcbiAgICAgICAgY29uc3QgZ2FtbWExeGggPSBnYW1tYTF4LmhpZ2g7XG4gICAgICAgIGNvbnN0IGdhbW1hMXhsID0gZ2FtbWExeC5sb3c7XG4gICAgICAgIGNvbnN0IGdhbW1hMWggPSAoZ2FtbWExeGggPj4+IDE5IHwgZ2FtbWExeGwgPDwgMTMpIF4gKGdhbW1hMXhoIDw8IDMgfCBnYW1tYTF4bCA+Pj4gMjkpIF4gZ2FtbWExeGggPj4+IDY7XG4gICAgICAgIGNvbnN0IGdhbW1hMWwgPSAoZ2FtbWExeGwgPj4+IDE5IHwgZ2FtbWExeGggPDwgMTMpIF4gKGdhbW1hMXhsIDw8IDMgfCBnYW1tYTF4aCA+Pj4gMjkpIF4gKGdhbW1hMXhsID4+PiA2IHwgZ2FtbWExeGggPDwgMjYpOyAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cblxuICAgICAgICBjb25zdCBXaTcgPSBXJDJbaSAtIDddO1xuICAgICAgICBjb25zdCBXaTdoID0gV2k3LmhpZ2g7XG4gICAgICAgIGNvbnN0IFdpN2wgPSBXaTcubG93O1xuICAgICAgICBjb25zdCBXaTE2ID0gVyQyW2kgLSAxNl07XG4gICAgICAgIGNvbnN0IFdpMTZoID0gV2kxNi5oaWdoO1xuICAgICAgICBjb25zdCBXaTE2bCA9IFdpMTYubG93O1xuICAgICAgICBXaWwgPSBnYW1tYTBsICsgV2k3bDtcbiAgICAgICAgV2loID0gZ2FtbWEwaCArIFdpN2ggKyAoV2lsID4+PiAwIDwgZ2FtbWEwbCA+Pj4gMCA/IDEgOiAwKTtcbiAgICAgICAgV2lsICs9IGdhbW1hMWw7XG4gICAgICAgIFdpaCA9IFdpaCArIGdhbW1hMWggKyAoV2lsID4+PiAwIDwgZ2FtbWExbCA+Pj4gMCA/IDEgOiAwKTtcbiAgICAgICAgV2lsICs9IFdpMTZsO1xuICAgICAgICBXaWggPSBXaWggKyBXaTE2aCArIChXaWwgPj4+IDAgPCBXaTE2bCA+Pj4gMCA/IDEgOiAwKTtcbiAgICAgICAgV2kuaGlnaCA9IFdpaDtcbiAgICAgICAgV2kubG93ID0gV2lsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGggPSBlaCAmIGZoIF4gfmVoICYgZ2g7XG4gICAgICBjb25zdCBjaGwgPSBlbCAmIGZsIF4gfmVsICYgZ2w7XG4gICAgICBjb25zdCBtYWpoID0gYWggJiBiaCBeIGFoICYgY2ggXiBiaCAmIGNoO1xuICAgICAgY29uc3QgbWFqbCA9IGFsICYgYmwgXiBhbCAmIGNsIF4gYmwgJiBjbDtcbiAgICAgIGNvbnN0IHNpZ21hMGggPSAoYWggPj4+IDI4IHwgYWwgPDwgNCkgXiAoYWggPDwgMzAgfCBhbCA+Pj4gMikgXiAoYWggPDwgMjUgfCBhbCA+Pj4gNyk7XG4gICAgICBjb25zdCBzaWdtYTBsID0gKGFsID4+PiAyOCB8IGFoIDw8IDQpIF4gKGFsIDw8IDMwIHwgYWggPj4+IDIpIF4gKGFsIDw8IDI1IHwgYWggPj4+IDcpO1xuICAgICAgY29uc3Qgc2lnbWExaCA9IChlaCA+Pj4gMTQgfCBlbCA8PCAxOCkgXiAoZWggPj4+IDE4IHwgZWwgPDwgMTQpIF4gKGVoIDw8IDIzIHwgZWwgPj4+IDkpO1xuICAgICAgY29uc3Qgc2lnbWExbCA9IChlbCA+Pj4gMTQgfCBlaCA8PCAxOCkgXiAoZWwgPj4+IDE4IHwgZWggPDwgMTQpIF4gKGVsIDw8IDIzIHwgZWggPj4+IDkpOyAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldXG5cbiAgICAgIGNvbnN0IEtpID0gSyQxW2ldO1xuICAgICAgY29uc3QgS2loID0gS2kuaGlnaDtcbiAgICAgIGNvbnN0IEtpbCA9IEtpLmxvdztcbiAgICAgIGxldCB0MWwgPSBobCArIHNpZ21hMWw7XG4gICAgICBsZXQgdDFoID0gaGggKyBzaWdtYTFoICsgKHQxbCA+Pj4gMCA8IGhsID4+PiAwID8gMSA6IDApO1xuICAgICAgdDFsICs9IGNobDtcbiAgICAgIHQxaCA9IHQxaCArIGNoaCArICh0MWwgPj4+IDAgPCBjaGwgPj4+IDAgPyAxIDogMCk7XG4gICAgICB0MWwgKz0gS2lsO1xuICAgICAgdDFoID0gdDFoICsgS2loICsgKHQxbCA+Pj4gMCA8IEtpbCA+Pj4gMCA/IDEgOiAwKTtcbiAgICAgIHQxbCArPSBXaWw7XG4gICAgICB0MWggPSB0MWggKyBXaWggKyAodDFsID4+PiAwIDwgV2lsID4+PiAwID8gMSA6IDApOyAvLyB0MiA9IHNpZ21hMCArIG1halxuXG4gICAgICBjb25zdCB0MmwgPSBzaWdtYTBsICsgbWFqbDtcbiAgICAgIGNvbnN0IHQyaCA9IHNpZ21hMGggKyBtYWpoICsgKHQybCA+Pj4gMCA8IHNpZ21hMGwgPj4+IDAgPyAxIDogMCk7IC8vIFVwZGF0ZSB3b3JraW5nIHZhcmlhYmxlc1xuXG4gICAgICBoaCA9IGdoO1xuICAgICAgaGwgPSBnbDtcbiAgICAgIGdoID0gZmg7XG4gICAgICBnbCA9IGZsO1xuICAgICAgZmggPSBlaDtcbiAgICAgIGZsID0gZWw7XG4gICAgICBlbCA9IGRsICsgdDFsIHwgMDtcbiAgICAgIGVoID0gZGggKyB0MWggKyAoZWwgPj4+IDAgPCBkbCA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gICAgICBkaCA9IGNoO1xuICAgICAgZGwgPSBjbDtcbiAgICAgIGNoID0gYmg7XG4gICAgICBjbCA9IGJsO1xuICAgICAgYmggPSBhaDtcbiAgICAgIGJsID0gYWw7XG4gICAgICBhbCA9IHQxbCArIHQybCB8IDA7XG4gICAgICBhaCA9IHQxaCArIHQyaCArIChhbCA+Pj4gMCA8IHQxbCA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gICAgfSAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXG5cbiAgICBIMC5sb3cgPSBIMGwgKyBhbDtcbiAgICBIMGwgPSBIMC5sb3c7XG4gICAgSDAuaGlnaCA9IEgwaCArIGFoICsgKEgwbCA+Pj4gMCA8IGFsID4+PiAwID8gMSA6IDApO1xuICAgIEgxLmxvdyA9IEgxbCArIGJsO1xuICAgIEgxbCA9IEgxLmxvdztcbiAgICBIMS5oaWdoID0gSDFoICsgYmggKyAoSDFsID4+PiAwIDwgYmwgPj4+IDAgPyAxIDogMCk7XG4gICAgSDIubG93ID0gSDJsICsgY2w7XG4gICAgSDJsID0gSDIubG93O1xuICAgIEgyLmhpZ2ggPSBIMmggKyBjaCArIChIMmwgPj4+IDAgPCBjbCA+Pj4gMCA/IDEgOiAwKTtcbiAgICBIMy5sb3cgPSBIM2wgKyBkbDtcbiAgICBIM2wgPSBIMy5sb3c7XG4gICAgSDMuaGlnaCA9IEgzaCArIGRoICsgKEgzbCA+Pj4gMCA8IGRsID4+PiAwID8gMSA6IDApO1xuICAgIEg0LmxvdyA9IEg0bCArIGVsO1xuICAgIEg0bCA9IEg0LmxvdztcbiAgICBINC5oaWdoID0gSDRoICsgZWggKyAoSDRsID4+PiAwIDwgZWwgPj4+IDAgPyAxIDogMCk7XG4gICAgSDUubG93ID0gSDVsICsgZmw7XG4gICAgSDVsID0gSDUubG93O1xuICAgIEg1LmhpZ2ggPSBINWggKyBmaCArIChINWwgPj4+IDAgPCBmbCA+Pj4gMCA/IDEgOiAwKTtcbiAgICBINi5sb3cgPSBINmwgKyBnbDtcbiAgICBINmwgPSBINi5sb3c7XG4gICAgSDYuaGlnaCA9IEg2aCArIGdoICsgKEg2bCA+Pj4gMCA8IGdsID4+PiAwID8gMSA6IDApO1xuICAgIEg3LmxvdyA9IEg3bCArIGhsO1xuICAgIEg3bCA9IEg3LmxvdztcbiAgICBINy5oaWdoID0gSDdoICsgaGggKyAoSDdsID4+PiAwIDwgaGwgPj4+IDAgPyAxIDogMCk7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuICAgIGNvbnN0IG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICBjb25zdCBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODsgLy8gQWRkIHBhZGRpbmdcblxuICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcbiAgICBkYXRhV29yZHNbKG5CaXRzTGVmdCArIDEyOCA+Pj4gMTAgPDwgNSkgKyAzMF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgZGF0YVdvcmRzWyhuQml0c0xlZnQgKyAxMjggPj4+IDEwIDw8IDUpICsgMzFdID0gbkJpdHNUb3RhbDtcbiAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7IC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cbiAgICB0aGlzLl9wcm9jZXNzKCk7IC8vIENvbnZlcnQgaGFzaCB0byAzMi1iaXQgd29yZCBhcnJheSBiZWZvcmUgcmV0dXJuaW5nXG5cblxuICAgIGNvbnN0IGhhc2ggPSB0aGlzLl9oYXNoLnRvWDMyKCk7IC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cblxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG59XG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIod29yZEFycmF5KTtcbiAqL1xuXG5cbmNvbnN0IFNIQTUxMiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTUxMkFsZ28pO1xuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEE1MTIobWVzc2FnZSwga2V5KTtcbiAqL1xuXG5cbmNvbnN0IEhtYWNTSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBNTEyQWxnbyk7XG4vKipcbiAqIFNIQS0zODQgaGFzaCBhbGdvcml0aG0uXG4gKi9cblxuXG5jbGFzcyBTSEEzODRBbGdvIGV4dGVuZHMgU0hBNTEyQWxnbyB7XG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5KFtuZXcgWDY0V29yZCgweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4KSwgbmV3IFg2NFdvcmQoMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyksIG5ldyBYNjRXb3JkKDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcpLCBuZXcgWDY0V29yZCgweDE1MmZlY2Q4LCAweGY3MGU1OTM5KSwgbmV3IFg2NFdvcmQoMHg2NzMzMjY2NywgMHhmZmMwMGIzMSksIG5ldyBYNjRXb3JkKDB4OGViNDRhODcsIDB4Njg1ODE1MTEpLCBuZXcgWDY0V29yZCgweGRiMGMyZTBkLCAweDY0Zjk4ZmE3KSwgbmV3IFg2NFdvcmQoMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCldKTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIGNvbnN0IGhhc2ggPSBzdXBlci5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xuXG4gICAgaGFzaC5zaWdCeXRlcyAtPSAxNjtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG59XG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMzg0KCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQod29yZEFycmF5KTtcbiAqL1xuXG5cbmNvbnN0IFNIQTM4NCA9IFNIQTUxMkFsZ28uX2NyZWF0ZUhlbHBlcihTSEEzODRBbGdvKTtcbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMzg0KG1lc3NhZ2UsIGtleSk7XG4gKi9cblxuXG5jb25zdCBIbWFjU0hBMzg0ID0gU0hBNTEyQWxnby5fY3JlYXRlSG1hY0hlbHBlcihTSEEzODRBbGdvKTsgLy8gQ29uc3RhbnRzIHRhYmxlc1xuXG5cbmNvbnN0IFJIT19PRkZTRVRTID0gW107XG5jb25zdCBQSV9JTkRFWEVTID0gW107XG5jb25zdCBST1VORF9DT05TVEFOVFMgPSBbXTsgLy8gQ29tcHV0ZSBDb25zdGFudHNcbi8vIENvbXB1dGUgcmhvIG9mZnNldCBjb25zdGFudHNcblxubGV0IF94ID0gMTtcbmxldCBfeSA9IDA7XG5cbmZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQgKz0gMSkge1xuICBSSE9fT0ZGU0VUU1tfeCArIDUgKiBfeV0gPSAodCArIDEpICogKHQgKyAyKSAvIDIgJSA2NDtcbiAgY29uc3QgbmV3WCA9IF95ICUgNTtcbiAgY29uc3QgbmV3WSA9ICgyICogX3ggKyAzICogX3kpICUgNTtcbiAgX3ggPSBuZXdYO1xuICBfeSA9IG5ld1k7XG59IC8vIENvbXB1dGUgcGkgaW5kZXggY29uc3RhbnRzXG5cblxuZm9yIChsZXQgeCA9IDA7IHggPCA1OyB4ICs9IDEpIHtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCA1OyB5ICs9IDEpIHtcbiAgICBQSV9JTkRFWEVTW3ggKyA1ICogeV0gPSB5ICsgKDIgKiB4ICsgMyAqIHkpICUgNSAqIDU7XG4gIH1cbn0gLy8gQ29tcHV0ZSByb3VuZCBjb25zdGFudHNcblxuXG5sZXQgTEZTUiA9IDB4MDE7XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjQ7IGkgKz0gMSkge1xuICBsZXQgcm91bmRDb25zdGFudE1zdyA9IDA7XG4gIGxldCByb3VuZENvbnN0YW50THN3ID0gMDtcblxuICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGogKz0gMSkge1xuICAgIGlmIChMRlNSICYgMHgwMSkge1xuICAgICAgY29uc3QgYml0UG9zaXRpb24gPSAoMSA8PCBqKSAtIDE7XG5cbiAgICAgIGlmIChiaXRQb3NpdGlvbiA8IDMyKSB7XG4gICAgICAgIHJvdW5kQ29uc3RhbnRMc3cgXj0gMSA8PCBiaXRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICAvKiBpZiAoYml0UG9zaXRpb24gPj0gMzIpICovXG4gICAgICAgIHtcbiAgICAgICAgICByb3VuZENvbnN0YW50TXN3IF49IDEgPDwgYml0UG9zaXRpb24gLSAzMjtcbiAgICAgICAgfVxuICAgIH0gLy8gQ29tcHV0ZSBuZXh0IExGU1JcblxuXG4gICAgaWYgKExGU1IgJiAweDgwKSB7XG4gICAgICAvLyBQcmltaXRpdmUgcG9seW5vbWlhbCBvdmVyIEdGKDIpOiB4XjggKyB4XjYgKyB4XjUgKyB4XjQgKyAxXG4gICAgICBMRlNSID0gTEZTUiA8PCAxIF4gMHg3MTtcbiAgICB9IGVsc2Uge1xuICAgICAgTEZTUiA8PD0gMTtcbiAgICB9XG4gIH1cblxuICBST1VORF9DT05TVEFOVFNbaV0gPSBYNjRXb3JkLmNyZWF0ZShyb3VuZENvbnN0YW50TXN3LCByb3VuZENvbnN0YW50THN3KTtcbn0gLy8gUmV1c2FibGUgb2JqZWN0cyBmb3IgdGVtcG9yYXJ5IHZhbHVlc1xuXG5cbmNvbnN0IFQkMSA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpICs9IDEpIHtcbiAgVCQxW2ldID0gWDY0V29yZC5jcmVhdGUoKTtcbn1cbi8qKlxuICogU0hBLTMgaGFzaCBhbGdvcml0aG0uXG4gKi9cblxuXG5jbGFzcyBTSEEzQWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvdXRwdXRMZW5ndGhcbiAgICAgKiAgIFRoZSBkZXNpcmVkIG51bWJlciBvZiBiaXRzIGluIHRoZSBvdXRwdXQgaGFzaC5cbiAgICAgKiAgIE9ubHkgdmFsdWVzIHBlcm1pdHRlZCBhcmU6IDIyNCwgMjU2LCAzODQsIDUxMi5cbiAgICAgKiAgIERlZmF1bHQ6IDUxMlxuICAgICAqL1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe1xuICAgICAgb3V0cHV0TGVuZ3RoOiA1MTJcbiAgICB9LCBjZmcpKTtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX3N0YXRlID0gW107XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkgKz0gMSkge1xuICAgICAgc3RhdGVbaV0gPSBuZXcgWDY0V29yZCgpO1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2tTaXplID0gKDE2MDAgLSAyICogdGhpcy5jZmcub3V0cHV0TGVuZ3RoKSAvIDMyO1xuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKE0sIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgY29uc3QgbkJsb2NrU2l6ZUxhbmVzID0gdGhpcy5ibG9ja1NpemUgLyAyOyAvLyBBYnNvcmJcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkJsb2NrU2l6ZUxhbmVzOyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgbGV0IE0yaSA9IE1bb2Zmc2V0ICsgMiAqIGldO1xuICAgICAgbGV0IE0yaTEgPSBNW29mZnNldCArIDIgKiBpICsgMV07IC8vIFN3YXAgZW5kaWFuXG5cbiAgICAgIE0yaSA9IChNMmkgPDwgOCB8IE0yaSA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChNMmkgPDwgMjQgfCBNMmkgPj4+IDgpICYgMHhmZjAwZmYwMDtcbiAgICAgIE0yaTEgPSAoTTJpMSA8PCA4IHwgTTJpMSA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChNMmkxIDw8IDI0IHwgTTJpMSA+Pj4gOCkgJiAweGZmMDBmZjAwOyAvLyBBYnNvcmIgbWVzc2FnZSBpbnRvIHN0YXRlXG5cbiAgICAgIGNvbnN0IGxhbmUgPSBzdGF0ZVtpXTtcbiAgICAgIGxhbmUuaGlnaCBePSBNMmkxO1xuICAgICAgbGFuZS5sb3cgXj0gTTJpO1xuICAgIH0gLy8gUm91bmRzXG5cblxuICAgIGZvciAobGV0IHJvdW5kID0gMDsgcm91bmQgPCAyNDsgcm91bmQgKz0gMSkge1xuICAgICAgLy8gVGhldGFcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNTsgeCArPSAxKSB7XG4gICAgICAgIC8vIE1peCBjb2x1bW4gbGFuZXNcbiAgICAgICAgbGV0IHRNc3cgPSAwO1xuICAgICAgICBsZXQgdExzdyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1OyB5ICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcbiAgICAgICAgICB0TXN3IF49IGxhbmUuaGlnaDtcbiAgICAgICAgICB0THN3IF49IGxhbmUubG93O1xuICAgICAgICB9IC8vIFRlbXBvcmFyeSB2YWx1ZXNcblxuXG4gICAgICAgIGNvbnN0IFR4ID0gVCQxW3hdO1xuICAgICAgICBUeC5oaWdoID0gdE1zdztcbiAgICAgICAgVHgubG93ID0gdExzdztcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA1OyB4ICs9IDEpIHtcbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIGNvbnN0IFR4NCA9IFQkMVsoeCArIDQpICUgNV07XG4gICAgICAgIGNvbnN0IFR4MSA9IFQkMVsoeCArIDEpICUgNV07XG4gICAgICAgIGNvbnN0IFR4MU1zdyA9IFR4MS5oaWdoO1xuICAgICAgICBjb25zdCBUeDFMc3cgPSBUeDEubG93OyAvLyBNaXggc3Vycm91bmRpbmcgY29sdW1uc1xuXG4gICAgICAgIGNvbnN0IHRNc3cgPSBUeDQuaGlnaCBeIChUeDFNc3cgPDwgMSB8IFR4MUxzdyA+Pj4gMzEpO1xuICAgICAgICBjb25zdCB0THN3ID0gVHg0LmxvdyBeIChUeDFMc3cgPDwgMSB8IFR4MU1zdyA+Pj4gMzEpO1xuXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSArPSAxKSB7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IHN0YXRlW3ggKyA1ICogeV07XG4gICAgICAgICAgbGFuZS5oaWdoIF49IHRNc3c7XG4gICAgICAgICAgbGFuZS5sb3cgXj0gdExzdztcbiAgICAgICAgfVxuICAgICAgfSAvLyBSaG8gUGlcblxuXG4gICAgICBmb3IgKGxldCBsYW5lSW5kZXggPSAxOyBsYW5lSW5kZXggPCAyNTsgbGFuZUluZGV4ICs9IDEpIHtcbiAgICAgICAgbGV0IHRNc3c7XG4gICAgICAgIGxldCB0THN3OyAvLyBTaG9ydGN1dHNcblxuICAgICAgICBjb25zdCBsYW5lID0gc3RhdGVbbGFuZUluZGV4XTtcbiAgICAgICAgY29uc3QgbGFuZU1zdyA9IGxhbmUuaGlnaDtcbiAgICAgICAgY29uc3QgbGFuZUxzdyA9IGxhbmUubG93O1xuICAgICAgICBjb25zdCByaG9PZmZzZXQgPSBSSE9fT0ZGU0VUU1tsYW5lSW5kZXhdOyAvLyBSb3RhdGUgbGFuZXNcblxuICAgICAgICBpZiAocmhvT2Zmc2V0IDwgMzIpIHtcbiAgICAgICAgICB0TXN3ID0gbGFuZU1zdyA8PCByaG9PZmZzZXQgfCBsYW5lTHN3ID4+PiAzMiAtIHJob09mZnNldDtcbiAgICAgICAgICB0THN3ID0gbGFuZUxzdyA8PCByaG9PZmZzZXQgfCBsYW5lTXN3ID4+PiAzMiAtIHJob09mZnNldDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgLyogaWYgKHJob09mZnNldCA+PSAzMikgKi9cbiAgICAgICAgICB7XG4gICAgICAgICAgICB0TXN3ID0gbGFuZUxzdyA8PCByaG9PZmZzZXQgLSAzMiB8IGxhbmVNc3cgPj4+IDY0IC0gcmhvT2Zmc2V0O1xuICAgICAgICAgICAgdExzdyA9IGxhbmVNc3cgPDwgcmhvT2Zmc2V0IC0gMzIgfCBsYW5lTHN3ID4+PiA2NCAtIHJob09mZnNldDtcbiAgICAgICAgICB9IC8vIFRyYW5zcG9zZSBsYW5lc1xuXG5cbiAgICAgICAgY29uc3QgVFBpTGFuZSA9IFQkMVtQSV9JTkRFWEVTW2xhbmVJbmRleF1dO1xuICAgICAgICBUUGlMYW5lLmhpZ2ggPSB0TXN3O1xuICAgICAgICBUUGlMYW5lLmxvdyA9IHRMc3c7XG4gICAgICB9IC8vIFJobyBwaSBhdCB4ID0geSA9IDBcblxuXG4gICAgICBjb25zdCBUMCA9IFQkMVswXTtcbiAgICAgIGNvbnN0IHN0YXRlMCA9IHN0YXRlWzBdO1xuICAgICAgVDAuaGlnaCA9IHN0YXRlMC5oaWdoO1xuICAgICAgVDAubG93ID0gc3RhdGUwLmxvdzsgLy8gQ2hpXG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNTsgeCArPSAxKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSArPSAxKSB7XG4gICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgY29uc3QgbGFuZUluZGV4ID0geCArIDUgKiB5O1xuICAgICAgICAgIGNvbnN0IGxhbmUgPSBzdGF0ZVtsYW5lSW5kZXhdO1xuICAgICAgICAgIGNvbnN0IFRMYW5lID0gVCQxW2xhbmVJbmRleF07XG4gICAgICAgICAgY29uc3QgVHgxTGFuZSA9IFQkMVsoeCArIDEpICUgNSArIDUgKiB5XTtcbiAgICAgICAgICBjb25zdCBUeDJMYW5lID0gVCQxWyh4ICsgMikgJSA1ICsgNSAqIHldOyAvLyBNaXggcm93c1xuXG4gICAgICAgICAgbGFuZS5oaWdoID0gVExhbmUuaGlnaCBeIH5UeDFMYW5lLmhpZ2ggJiBUeDJMYW5lLmhpZ2g7XG4gICAgICAgICAgbGFuZS5sb3cgPSBUTGFuZS5sb3cgXiB+VHgxTGFuZS5sb3cgJiBUeDJMYW5lLmxvdztcbiAgICAgICAgfVxuICAgICAgfSAvLyBJb3RhXG5cblxuICAgICAgY29uc3QgbGFuZSA9IHN0YXRlWzBdO1xuICAgICAgY29uc3Qgcm91bmRDb25zdGFudCA9IFJPVU5EX0NPTlNUQU5UU1tyb3VuZF07XG4gICAgICBsYW5lLmhpZ2ggXj0gcm91bmRDb25zdGFudC5oaWdoO1xuICAgICAgbGFuZS5sb3cgXj0gcm91bmRDb25zdGFudC5sb3c7XG4gICAgfVxuICB9XG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcbiAgICBjb25zdCBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcbiAgICBjb25zdCBibG9ja1NpemVCaXRzID0gdGhpcy5ibG9ja1NpemUgKiAzMjsgLy8gQWRkIHBhZGRpbmdcblxuICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4MSA8PCAyNCAtIG5CaXRzTGVmdCAlIDMyO1xuICAgIGRhdGFXb3Jkc1soTWF0aC5jZWlsKChuQml0c0xlZnQgKyAxKSAvIGJsb2NrU2l6ZUJpdHMpICogYmxvY2tTaXplQml0cyA+Pj4gNSkgLSAxXSB8PSAweDgwO1xuICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDsgLy8gSGFzaCBmaW5hbCBibG9ja3NcblxuICAgIHRoaXMuX3Byb2Nlc3MoKTsgLy8gU2hvcnRjdXRzXG5cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgY29uc3Qgb3V0cHV0TGVuZ3RoQnl0ZXMgPSB0aGlzLmNmZy5vdXRwdXRMZW5ndGggLyA4O1xuICAgIGNvbnN0IG91dHB1dExlbmd0aExhbmVzID0gb3V0cHV0TGVuZ3RoQnl0ZXMgLyA4OyAvLyBTcXVlZXplXG5cbiAgICBjb25zdCBoYXNoV29yZHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoTGFuZXM7IGkgKz0gMSkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBsYW5lID0gc3RhdGVbaV07XG4gICAgICBsZXQgbGFuZU1zdyA9IGxhbmUuaGlnaDtcbiAgICAgIGxldCBsYW5lTHN3ID0gbGFuZS5sb3c7IC8vIFN3YXAgZW5kaWFuXG5cbiAgICAgIGxhbmVNc3cgPSAobGFuZU1zdyA8PCA4IHwgbGFuZU1zdyA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChsYW5lTXN3IDw8IDI0IHwgbGFuZU1zdyA+Pj4gOCkgJiAweGZmMDBmZjAwO1xuICAgICAgbGFuZUxzdyA9IChsYW5lTHN3IDw8IDggfCBsYW5lTHN3ID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKGxhbmVMc3cgPDwgMjQgfCBsYW5lTHN3ID4+PiA4KSAmIDB4ZmYwMGZmMDA7IC8vIFNxdWVlemUgc3RhdGUgdG8gcmV0cmlldmUgaGFzaFxuXG4gICAgICBoYXNoV29yZHMucHVzaChsYW5lTHN3KTtcbiAgICAgIGhhc2hXb3Jkcy5wdXNoKGxhbmVNc3cpO1xuICAgIH0gLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblxuXG4gICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkoaGFzaFdvcmRzLCBvdXRwdXRMZW5ndGhCeXRlcyk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX3N0YXRlID0gdGhpcy5fc3RhdGUuc2xpY2UoMCk7XG4gICAgY29uc3Qgc3RhdGUgPSBjbG9uZS5fc3RhdGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpICs9IDEpIHtcbiAgICAgIHN0YXRlW2ldID0gc3RhdGVbaV0uY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxufVxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTMoJ21lc3NhZ2UnKTtcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTMod29yZEFycmF5KTtcbiAqL1xuXG5cbmNvbnN0IFNIQTMgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEzQWxnbyk7XG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTMobWVzc2FnZSwga2V5KTtcbiAqL1xuXG5cbmNvbnN0IEhtYWNTSEEzID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTNBbGdvKTtcbi8qKiBAcHJlc2VydmVcbihjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkXG5wcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gICAgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcbiAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTU1xuT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1JcbkNPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbkRBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbkRBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLFxuV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWVxuV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuLy8gQ29uc3RhbnRzIHRhYmxlXG5cblxuY29uc3QgX3psID0gV29yZEFycmF5LmNyZWF0ZShbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCwgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMiwgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMiwgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM10pO1xuXG5jb25zdCBfenIgPSBXb3JkQXJyYXkuY3JlYXRlKFs1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLCA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLCAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLCA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LCAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXSk7XG5cbmNvbnN0IF9zbCA9IFdvcmRBcnJheS5jcmVhdGUoWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCwgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLCAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMiwgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XSk7XG5cbmNvbnN0IF9zciA9IFdvcmRBcnJheS5jcmVhdGUoWzgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNiwgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLCA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCwgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXSk7XG5cbmNvbnN0IF9obCA9IFdvcmRBcnJheS5jcmVhdGUoWzB4MDAwMDAwMDAsIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsIDB4OEYxQkJDREMsIDB4QTk1M0ZENEVdKTtcblxuY29uc3QgX2hyID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MEEyOEJFNiwgMHg1QzRERDEyNCwgMHg2RDcwM0VGMywgMHg3QTZENzZFOSwgMHgwMDAwMDAwMF0pO1xuXG5jb25zdCBmMSA9ICh4LCB5LCB6KSA9PiB4IF4geSBeIHo7XG5cbmNvbnN0IGYyID0gKHgsIHksIHopID0+IHggJiB5IHwgfnggJiB6O1xuXG5jb25zdCBmMyA9ICh4LCB5LCB6KSA9PiAoeCB8IH55KSBeIHo7XG5cbmNvbnN0IGY0ID0gKHgsIHksIHopID0+IHggJiB6IHwgeSAmIH56O1xuXG5jb25zdCBmNSA9ICh4LCB5LCB6KSA9PiB4IF4gKHkgfCB+eik7XG5cbmNvbnN0IHJvdGwgPSAoeCwgbikgPT4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xuLyoqXG4gKiBSSVBFTUQxNjAgaGFzaCBhbGdvcml0aG0uXG4gKi9cblxuXG5jbGFzcyBSSVBFTUQxNjBBbGdvIGV4dGVuZHMgSGFzaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IFdvcmRBcnJheS5jcmVhdGUoWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdKTtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfTSA9IE07IC8vIFN3YXAgZW5kaWFuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3Qgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuICAgICAgY29uc3QgTV9vZmZzZXRfaSA9IF9NW29mZnNldF9pXTsgLy8gU3dhcFxuXG4gICAgICBfTVtvZmZzZXRfaV0gPSAoTV9vZmZzZXRfaSA8PCA4IHwgTV9vZmZzZXRfaSA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChNX29mZnNldF9pIDw8IDI0IHwgTV9vZmZzZXRfaSA+Pj4gOCkgJiAweGZmMDBmZjAwO1xuICAgIH0gLy8gU2hvcnRjdXRcblxuXG4gICAgY29uc3QgSCA9IHRoaXMuX2hhc2gud29yZHM7XG4gICAgY29uc3QgaGwgPSBfaGwud29yZHM7XG4gICAgY29uc3QgaHIgPSBfaHIud29yZHM7XG4gICAgY29uc3QgemwgPSBfemwud29yZHM7XG4gICAgY29uc3QgenIgPSBfenIud29yZHM7XG4gICAgY29uc3Qgc2wgPSBfc2wud29yZHM7XG4gICAgY29uc3Qgc3IgPSBfc3Iud29yZHM7IC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cbiAgICBsZXQgYWwgPSBIWzBdO1xuICAgIGxldCBibCA9IEhbMV07XG4gICAgbGV0IGNsID0gSFsyXTtcbiAgICBsZXQgZGwgPSBIWzNdO1xuICAgIGxldCBlbCA9IEhbNF07XG4gICAgbGV0IGFyID0gSFswXTtcbiAgICBsZXQgYnIgPSBIWzFdO1xuICAgIGxldCBjciA9IEhbMl07XG4gICAgbGV0IGRyID0gSFszXTtcbiAgICBsZXQgZXIgPSBIWzRdOyAvLyBDb21wdXRhdGlvblxuXG4gICAgbGV0IHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICAgIHQgPSBhbCArIF9NW29mZnNldCArIHpsW2ldXSB8IDA7XG5cbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgdCArPSBmMShibCwgY2wsIGRsKSArIGhsWzBdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgICAgdCArPSBmMihibCwgY2wsIGRsKSArIGhsWzFdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgICAgdCArPSBmMyhibCwgY2wsIGRsKSArIGhsWzJdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgICAgdCArPSBmNChibCwgY2wsIGRsKSArIGhsWzNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgKGk8ODApIHtcbiAgICAgICAgdCArPSBmNShibCwgY2wsIGRsKSArIGhsWzRdO1xuICAgICAgfVxuXG4gICAgICB0IHw9IDA7XG4gICAgICB0ID0gcm90bCh0LCBzbFtpXSk7XG4gICAgICB0ID0gdCArIGVsIHwgMDtcbiAgICAgIGFsID0gZWw7XG4gICAgICBlbCA9IGRsO1xuICAgICAgZGwgPSByb3RsKGNsLCAxMCk7XG4gICAgICBjbCA9IGJsO1xuICAgICAgYmwgPSB0O1xuICAgICAgdCA9IGFyICsgX01bb2Zmc2V0ICsgenJbaV1dIHwgMDtcblxuICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICB0ICs9IGY1KGJyLCBjciwgZHIpICsgaHJbMF07XG4gICAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICB0ICs9IGY0KGJyLCBjciwgZHIpICsgaHJbMV07XG4gICAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgICB0ICs9IGYzKGJyLCBjciwgZHIpICsgaHJbMl07XG4gICAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgICB0ICs9IGYyKGJyLCBjciwgZHIpICsgaHJbM107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiAoaTw4MCkge1xuICAgICAgICB0ICs9IGYxKGJyLCBjciwgZHIpICsgaHJbNF07XG4gICAgICB9XG5cbiAgICAgIHQgfD0gMDtcbiAgICAgIHQgPSByb3RsKHQsIHNyW2ldKTtcbiAgICAgIHQgPSB0ICsgZXIgfCAwO1xuICAgICAgYXIgPSBlcjtcbiAgICAgIGVyID0gZHI7XG4gICAgICBkciA9IHJvdGwoY3IsIDEwKTtcbiAgICAgIGNyID0gYnI7XG4gICAgICBiciA9IHQ7XG4gICAgfSAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXG5cbiAgICB0ID0gSFsxXSArIGNsICsgZHIgfCAwO1xuICAgIEhbMV0gPSBIWzJdICsgZGwgKyBlciB8IDA7XG4gICAgSFsyXSA9IEhbM10gKyBlbCArIGFyIHwgMDtcbiAgICBIWzNdID0gSFs0XSArIGFsICsgYnIgfCAwO1xuICAgIEhbNF0gPSBIWzBdICsgYmwgKyBjciB8IDA7XG4gICAgSFswXSA9IHQ7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuICAgIGNvbnN0IG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICBjb25zdCBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODsgLy8gQWRkIHBhZGRpbmdcblxuICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgMjQgLSBuQml0c0xlZnQgJSAzMjtcbiAgICBkYXRhV29yZHNbKG5CaXRzTGVmdCArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gKG5CaXRzVG90YWwgPDwgOCB8IG5CaXRzVG90YWwgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAobkJpdHNUb3RhbCA8PCAyNCB8IG5CaXRzVG90YWwgPj4+IDgpICYgMHhmZjAwZmYwMDtcbiAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7IC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cbiAgICB0aGlzLl9wcm9jZXNzKCk7IC8vIFNob3J0Y3V0c1xuXG5cbiAgICBjb25zdCBoYXNoID0gdGhpcy5faGFzaDtcbiAgICBjb25zdCBIID0gaGFzaC53b3JkczsgLy8gU3dhcCBlbmRpYW5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSArPSAxKSB7XG4gICAgICAvLyBTaG9ydGN1dFxuICAgICAgY29uc3QgSF9pID0gSFtpXTsgLy8gU3dhcFxuXG4gICAgICBIW2ldID0gKEhfaSA8PCA4IHwgSF9pID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKEhfaSA8PCAyNCB8IEhfaSA+Pj4gOCkgJiAweGZmMDBmZjAwO1xuICAgIH0gLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbn1cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5SSVBFTUQxNjAoJ21lc3NhZ2UnKTtcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlJJUEVNRDE2MCh3b3JkQXJyYXkpO1xuICovXG5cblxuY29uc3QgUklQRU1EMTYwID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoUklQRU1EMTYwQWxnbyk7XG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1JJUEVNRDE2MChtZXNzYWdlLCBrZXkpO1xuICovXG5cblxuY29uc3QgSG1hY1JJUEVNRDE2MCA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihSSVBFTUQxNjBBbGdvKTtcbi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMiBhbGdvcml0aG0uXG4gKi9cblxuXG5jbGFzcyBQQktERjJBbGdvIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoKTtcbiAgICogICAgIGNvbnN0IGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG4gICAqICAgICBjb25zdCBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UuIERlZmF1bHQ6IFNIQTFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuICAgICAqL1xuXG4gICAgdGhpcy5jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHtcbiAgICAgIGtleVNpemU6IDEyOCAvIDMyLFxuICAgICAgaGFzaGVyOiBTSEExQWxnbyxcbiAgICAgIGl0ZXJhdGlvbnM6IDFcbiAgICB9LCBjZmcpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMi5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuICAgKi9cblxuXG4gIGNvbXB1dGUocGFzc3dvcmQsIHNhbHQpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IHtcbiAgICAgIGNmZ1xuICAgIH0gPSB0aGlzOyAvLyBJbml0IEhNQUNcblxuICAgIGNvbnN0IGhtYWMgPSBITUFDLmNyZWF0ZShjZmcuaGFzaGVyLCBwYXNzd29yZCk7IC8vIEluaXRpYWwgdmFsdWVzXG5cbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuICAgIGNvbnN0IGJsb2NrSW5kZXggPSBXb3JkQXJyYXkuY3JlYXRlKFsweDAwMDAwMDAxXSk7IC8vIFNob3J0Y3V0c1xuXG4gICAgY29uc3QgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3JkcztcbiAgICBjb25zdCBibG9ja0luZGV4V29yZHMgPSBibG9ja0luZGV4LndvcmRzO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleVNpemUsXG4gICAgICBpdGVyYXRpb25zXG4gICAgfSA9IGNmZzsgLy8gR2VuZXJhdGUga2V5XG5cbiAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gaG1hYy51cGRhdGUoc2FsdCkuZmluYWxpemUoYmxvY2tJbmRleCk7XG4gICAgICBobWFjLnJlc2V0KCk7IC8vIFNob3J0Y3V0c1xuXG4gICAgICBjb25zdCBibG9ja1dvcmRzID0gYmxvY2sud29yZHM7XG4gICAgICBjb25zdCBibG9ja1dvcmRzTGVuZ3RoID0gYmxvY2tXb3Jkcy5sZW5ndGg7IC8vIEl0ZXJhdGlvbnNcblxuICAgICAgbGV0IGludGVybWVkaWF0ZSA9IGJsb2NrO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkgKz0gMSkge1xuICAgICAgICBpbnRlcm1lZGlhdGUgPSBobWFjLmZpbmFsaXplKGludGVybWVkaWF0ZSk7XG4gICAgICAgIGhtYWMucmVzZXQoKTsgLy8gU2hvcnRjdXRcblxuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVXb3JkcyA9IGludGVybWVkaWF0ZS53b3JkczsgLy8gWE9SIGludGVybWVkaWF0ZSB3aXRoIGJsb2NrXG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9ja1dvcmRzTGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICBibG9ja1dvcmRzW2pdIF49IGludGVybWVkaWF0ZVdvcmRzW2pdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcbiAgICAgIGJsb2NrSW5kZXhXb3Jkc1swXSArPSAxO1xuICAgIH1cblxuICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcbiAgICByZXR1cm4gZGVyaXZlZEtleTtcbiAgfVxuXG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCk7XG4gKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcbiAqL1xuXG5cbmNvbnN0IFBCS0RGMiA9IChwYXNzd29yZCwgc2FsdCwgY2ZnKSA9PiBQQktERjJBbGdvLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpOyAvLyBMb29rdXAgdGFibGVzXG5cblxuY29uc3QgX1NCT1ggPSBbXTtcbmNvbnN0IElOVl9TQk9YID0gW107XG5jb25zdCBfU1VCX01JWF8wID0gW107XG5jb25zdCBfU1VCX01JWF8xID0gW107XG5jb25zdCBfU1VCX01JWF8yID0gW107XG5jb25zdCBfU1VCX01JWF8zID0gW107XG5jb25zdCBJTlZfU1VCX01JWF8wID0gW107XG5jb25zdCBJTlZfU1VCX01JWF8xID0gW107XG5jb25zdCBJTlZfU1VCX01JWF8yID0gW107XG5jb25zdCBJTlZfU1VCX01JWF8zID0gW107IC8vIENvbXB1dGUgbG9va3VwIHRhYmxlc1xuLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcblxuY29uc3QgZCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gIGlmIChpIDwgMTI4KSB7XG4gICAgZFtpXSA9IGkgPDwgMTtcbiAgfSBlbHNlIHtcbiAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gIH1cbn0gLy8gV2FsayBHRigyXjgpXG5cblxubGV0IHggPSAwO1xubGV0IHhpID0gMDtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkgKz0gMSkge1xuICAvLyBDb21wdXRlIHNib3hcbiAgbGV0IHN4ID0geGkgXiB4aSA8PCAxIF4geGkgPDwgMiBeIHhpIDw8IDMgXiB4aSA8PCA0O1xuICBzeCA9IHN4ID4+PiA4IF4gc3ggJiAweGZmIF4gMHg2MztcbiAgX1NCT1hbeF0gPSBzeDtcbiAgSU5WX1NCT1hbc3hdID0geDsgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXG4gIGNvbnN0IHgyID0gZFt4XTtcbiAgY29uc3QgeDQgPSBkW3gyXTtcbiAgY29uc3QgeDggPSBkW3g0XTsgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXG4gIGxldCB0ID0gZFtzeF0gKiAweDEwMSBeIHN4ICogMHgxMDEwMTAwO1xuICBfU1VCX01JWF8wW3hdID0gdCA8PCAyNCB8IHQgPj4+IDg7XG4gIF9TVUJfTUlYXzFbeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gIF9TVUJfTUlYXzJbeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgX1NVQl9NSVhfM1t4XSA9IHQ7IC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXG4gIHQgPSB4OCAqIDB4MTAxMDEwMSBeIHg0ICogMHgxMDAwMSBeIHgyICogMHgxMDEgXiB4ICogMHgxMDEwMTAwO1xuICBJTlZfU1VCX01JWF8wW3N4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICBJTlZfU1VCX01JWF8xW3N4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgSU5WX1NVQl9NSVhfMltzeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0OyAvLyBDb21wdXRlIG5leHQgY291bnRlclxuXG4gIGlmICgheCkge1xuICAgIHhpID0gMTtcbiAgICB4ID0geGk7XG4gIH0gZWxzZSB7XG4gICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICB4aSBePSBkW2RbeGldXTtcbiAgfVxufSAvLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxuXG5cbmNvbnN0IFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4vKipcbiAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5cbmNsYXNzIEFFU0FsZ28gZXh0ZW5kcyBCbG9ja0NpcGhlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmtleVNpemUgPSAyNTYgLyAzMjtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIGxldCB0OyAvLyBTa2lwIHJlc2V0IG9mIG5Sb3VuZHMgaGFzIGJlZW4gc2V0IGJlZm9yZSBhbmQga2V5IGRpZCBub3QgY2hhbmdlXG5cbiAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFNob3J0Y3V0c1xuXG5cbiAgICB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQ7XG4gICAgY29uc3Qga2V5V29yZHMgPSBrZXkud29yZHM7XG4gICAgY29uc3Qga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7IC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuXG4gICAgdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuICAgIGNvbnN0IG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzOyAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXG4gICAgY29uc3Qga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7IC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG5cbiAgICB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuICAgIGNvbnN0IGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGU7XG5cbiAgICBmb3IgKGxldCBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdyArPSAxKSB7XG4gICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG4gICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcbiAgICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICAgIHQgPSB0IDw8IDggfCB0ID4+PiAyNDsgLy8gU3ViIHdvcmRcblxuICAgICAgICAgIHQgPSBfU0JPWFt0ID4+PiAyNF0gPDwgMjQgfCBfU0JPWFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgX1NCT1hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBfU0JPWFt0ICYgMHhmZl07IC8vIE1peCBSY29uXG5cbiAgICAgICAgICB0IF49IFJDT05ba3NSb3cgLyBrZXlTaXplIHwgMF0gPDwgMjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICB0ID0gX1NCT1hbdCA+Pj4gMjRdIDw8IDI0IHwgX1NCT1hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IF9TQk9YW3QgPj4+IDggJiAweGZmXSA8PCA4IHwgX1NCT1hbdCAmIDB4ZmZdO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG4gICAgICB9XG4gICAgfSAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcblxuXG4gICAgdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcbiAgICBjb25zdCBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlO1xuXG4gICAgZm9yIChsZXQgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3cgKz0gMSkge1xuICAgICAgY29uc3Qga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuICAgICAgaWYgKGludktzUm93ICUgNCkge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtfU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtfU0JPWFt0ID4+PiAxNiAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzJbX1NCT1hbdCA+Pj4gOCAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbX1NCT1hbdCAmIDB4ZmZdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbmNyeXB0QmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIF9TVUJfTUlYXzAsIF9TVUJfTUlYXzEsIF9TVUJfTUlYXzIsIF9TVUJfTUlYXzMsIF9TQk9YKTtcbiAgfVxuXG4gIGRlY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfTSA9IE07IC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xuXG4gICAgbGV0IHQgPSBfTVtvZmZzZXQgKyAxXTtcbiAgICBfTVtvZmZzZXQgKyAxXSA9IF9NW29mZnNldCArIDNdO1xuICAgIF9NW29mZnNldCArIDNdID0gdDtcblxuICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhfTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpOyAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG5cblxuICAgIHQgPSBfTVtvZmZzZXQgKyAxXTtcbiAgICBfTVtvZmZzZXQgKyAxXSA9IF9NW29mZnNldCArIDNdO1xuICAgIF9NW29mZnNldCArIDNdID0gdDtcbiAgfVxuXG4gIF9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG4gICAgY29uc3QgX00gPSBNOyAvLyBTaG9ydGN1dFxuXG4gICAgY29uc3QgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7IC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuXG4gICAgbGV0IHMwID0gX01bb2Zmc2V0XSBeIGtleVNjaGVkdWxlWzBdO1xuICAgIGxldCBzMSA9IF9NW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG4gICAgbGV0IHMyID0gX01bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcbiAgICBsZXQgczMgPSBfTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdOyAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcblxuICAgIGxldCBrc1JvdyA9IDQ7IC8vIFJvdW5kc1xuXG4gICAgZm9yIChsZXQgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kICs9IDEpIHtcbiAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcbiAgICAgIGNvbnN0IHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbczEgPj4+IDE2ICYgMHhmZl0gXiBTVUJfTUlYXzJbczIgPj4+IDggJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAga3NSb3cgKz0gMTtcbiAgICAgIGNvbnN0IHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbczIgPj4+IDE2ICYgMHhmZl0gXiBTVUJfTUlYXzJbczMgPj4+IDggJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAga3NSb3cgKz0gMTtcbiAgICAgIGNvbnN0IHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbczMgPj4+IDE2ICYgMHhmZl0gXiBTVUJfTUlYXzJbczAgPj4+IDggJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAga3NSb3cgKz0gMTtcbiAgICAgIGNvbnN0IHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbczAgPj4+IDE2ICYgMHhmZl0gXiBTVUJfTUlYXzJbczEgPj4+IDggJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAga3NSb3cgKz0gMTsgLy8gVXBkYXRlIHN0YXRlXG5cbiAgICAgIHMwID0gdDA7XG4gICAgICBzMSA9IHQxO1xuICAgICAgczIgPSB0MjtcbiAgICAgIHMzID0gdDM7XG4gICAgfSAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblxuXG4gICAgY29uc3QgdDAgPSAoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0IHwgU0JPWFtzMSA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IFNCT1hbczIgPj4+IDggJiAweGZmXSA8PCA4IHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICBrc1JvdyArPSAxO1xuICAgIGNvbnN0IHQxID0gKFNCT1hbczEgPj4+IDI0XSA8PCAyNCB8IFNCT1hbczIgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBTQk9YW3MzID4+PiA4ICYgMHhmZl0gPDwgOCB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAga3NSb3cgKz0gMTtcbiAgICBjb25zdCB0MiA9IChTQk9YW3MyID4+PiAyNF0gPDwgMjQgfCBTQk9YW3MzID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgU0JPWFtzMCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgIGtzUm93ICs9IDE7XG4gICAgY29uc3QgdDMgPSAoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0IHwgU0JPWFtzMCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IFNCT1hbczEgPj4+IDggJiAweGZmXSA8PCA4IHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICBrc1JvdyArPSAxOyAvLyBTZXQgb3V0cHV0XG5cbiAgICBfTVtvZmZzZXRdID0gdDA7XG4gICAgX01bb2Zmc2V0ICsgMV0gPSB0MTtcbiAgICBfTVtvZmZzZXQgKyAyXSA9IHQyO1xuICAgIF9NW29mZnNldCArIDNdID0gdDM7XG4gIH1cblxufVxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gKi9cblxuXG5jb25zdCBBRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFU0FsZ28pOyAvLyBQZXJtdXRlZCBDaG9pY2UgMSBjb25zdGFudHNcblxuXG5jb25zdCBQQzEgPSBbNTcsIDQ5LCA0MSwgMzMsIDI1LCAxNywgOSwgMSwgNTgsIDUwLCA0MiwgMzQsIDI2LCAxOCwgMTAsIDIsIDU5LCA1MSwgNDMsIDM1LCAyNywgMTksIDExLCAzLCA2MCwgNTIsIDQ0LCAzNiwgNjMsIDU1LCA0NywgMzksIDMxLCAyMywgMTUsIDcsIDYyLCA1NCwgNDYsIDM4LCAzMCwgMjIsIDE0LCA2LCA2MSwgNTMsIDQ1LCAzNywgMjksIDIxLCAxMywgNSwgMjgsIDIwLCAxMiwgNF07IC8vIFBlcm11dGVkIENob2ljZSAyIGNvbnN0YW50c1xuXG5jb25zdCBQQzIgPSBbMTQsIDE3LCAxMSwgMjQsIDEsIDUsIDMsIDI4LCAxNSwgNiwgMjEsIDEwLCAyMywgMTksIDEyLCA0LCAyNiwgOCwgMTYsIDcsIDI3LCAyMCwgMTMsIDIsIDQxLCA1MiwgMzEsIDM3LCA0NywgNTUsIDMwLCA0MCwgNTEsIDQ1LCAzMywgNDgsIDQ0LCA0OSwgMzksIDU2LCAzNCwgNTMsIDQ2LCA0MiwgNTAsIDM2LCAyOSwgMzJdOyAvLyBDdW11bGF0aXZlIGJpdCBzaGlmdCBjb25zdGFudHNcblxuY29uc3QgQklUX1NISUZUUyA9IFsxLCAyLCA0LCA2LCA4LCAxMCwgMTIsIDE0LCAxNSwgMTcsIDE5LCAyMSwgMjMsIDI1LCAyNywgMjhdOyAvLyBTQk9YZXMgYW5kIHJvdW5kIHBlcm11dGF0aW9uIGNvbnN0YW50c1xuXG5jb25zdCBTQk9YX1AgPSBbe1xuICAweDA6IDB4ODA4MjAwLFxuICAweDEwMDAwMDAwOiAweDgwMDAsXG4gIDB4MjAwMDAwMDA6IDB4ODA4MDAyLFxuICAweDMwMDAwMDAwOiAweDIsXG4gIDB4NDAwMDAwMDA6IDB4MjAwLFxuICAweDUwMDAwMDAwOiAweDgwODIwMixcbiAgMHg2MDAwMDAwMDogMHg4MDAyMDIsXG4gIDB4NzAwMDAwMDA6IDB4ODAwMDAwLFxuICAweDgwMDAwMDAwOiAweDIwMixcbiAgMHg5MDAwMDAwMDogMHg4MDAyMDAsXG4gIDB4YTAwMDAwMDA6IDB4ODIwMCxcbiAgMHhiMDAwMDAwMDogMHg4MDgwMDAsXG4gIDB4YzAwMDAwMDA6IDB4ODAwMixcbiAgMHhkMDAwMDAwMDogMHg4MDAwMDIsXG4gIDB4ZTAwMDAwMDA6IDB4MCxcbiAgMHhmMDAwMDAwMDogMHg4MjAyLFxuICAweDgwMDAwMDA6IDB4MCxcbiAgMHgxODAwMDAwMDogMHg4MDgyMDIsXG4gIDB4MjgwMDAwMDA6IDB4ODIwMixcbiAgMHgzODAwMDAwMDogMHg4MDAwLFxuICAweDQ4MDAwMDAwOiAweDgwODIwMCxcbiAgMHg1ODAwMDAwMDogMHgyMDAsXG4gIDB4NjgwMDAwMDA6IDB4ODA4MDAyLFxuICAweDc4MDAwMDAwOiAweDIsXG4gIDB4ODgwMDAwMDA6IDB4ODAwMjAwLFxuICAweDk4MDAwMDAwOiAweDgyMDAsXG4gIDB4YTgwMDAwMDA6IDB4ODA4MDAwLFxuICAweGI4MDAwMDAwOiAweDgwMDIwMixcbiAgMHhjODAwMDAwMDogMHg4MDAwMDIsXG4gIDB4ZDgwMDAwMDA6IDB4ODAwMixcbiAgMHhlODAwMDAwMDogMHgyMDIsXG4gIDB4ZjgwMDAwMDA6IDB4ODAwMDAwLFxuICAweDE6IDB4ODAwMCxcbiAgMHgxMDAwMDAwMTogMHgyLFxuICAweDIwMDAwMDAxOiAweDgwODIwMCxcbiAgMHgzMDAwMDAwMTogMHg4MDAwMDAsXG4gIDB4NDAwMDAwMDE6IDB4ODA4MDAyLFxuICAweDUwMDAwMDAxOiAweDgyMDAsXG4gIDB4NjAwMDAwMDE6IDB4MjAwLFxuICAweDcwMDAwMDAxOiAweDgwMDIwMixcbiAgMHg4MDAwMDAwMTogMHg4MDgyMDIsXG4gIDB4OTAwMDAwMDE6IDB4ODA4MDAwLFxuICAweGEwMDAwMDAxOiAweDgwMDAwMixcbiAgMHhiMDAwMDAwMTogMHg4MjAyLFxuICAweGMwMDAwMDAxOiAweDIwMixcbiAgMHhkMDAwMDAwMTogMHg4MDAyMDAsXG4gIDB4ZTAwMDAwMDE6IDB4ODAwMixcbiAgMHhmMDAwMDAwMTogMHgwLFxuICAweDgwMDAwMDE6IDB4ODA4MjAyLFxuICAweDE4MDAwMDAxOiAweDgwODAwMCxcbiAgMHgyODAwMDAwMTogMHg4MDAwMDAsXG4gIDB4MzgwMDAwMDE6IDB4MjAwLFxuICAweDQ4MDAwMDAxOiAweDgwMDAsXG4gIDB4NTgwMDAwMDE6IDB4ODAwMDAyLFxuICAweDY4MDAwMDAxOiAweDIsXG4gIDB4NzgwMDAwMDE6IDB4ODIwMixcbiAgMHg4ODAwMDAwMTogMHg4MDAyLFxuICAweDk4MDAwMDAxOiAweDgwMDIwMixcbiAgMHhhODAwMDAwMTogMHgyMDIsXG4gIDB4YjgwMDAwMDE6IDB4ODA4MjAwLFxuICAweGM4MDAwMDAxOiAweDgwMDIwMCxcbiAgMHhkODAwMDAwMTogMHgwLFxuICAweGU4MDAwMDAxOiAweDgyMDAsXG4gIDB4ZjgwMDAwMDE6IDB4ODA4MDAyXG59LCB7XG4gIDB4MDogMHg0MDA4NDAxMCxcbiAgMHgxMDAwMDAwOiAweDQwMDAsXG4gIDB4MjAwMDAwMDogMHg4MDAwMCxcbiAgMHgzMDAwMDAwOiAweDQwMDgwMDEwLFxuICAweDQwMDAwMDA6IDB4NDAwMDAwMTAsXG4gIDB4NTAwMDAwMDogMHg0MDA4NDAwMCxcbiAgMHg2MDAwMDAwOiAweDQwMDA0MDAwLFxuICAweDcwMDAwMDA6IDB4MTAsXG4gIDB4ODAwMDAwMDogMHg4NDAwMCxcbiAgMHg5MDAwMDAwOiAweDQwMDA0MDEwLFxuICAweGEwMDAwMDA6IDB4NDAwMDAwMDAsXG4gIDB4YjAwMDAwMDogMHg4NDAxMCxcbiAgMHhjMDAwMDAwOiAweDgwMDEwLFxuICAweGQwMDAwMDA6IDB4MCxcbiAgMHhlMDAwMDAwOiAweDQwMTAsXG4gIDB4ZjAwMDAwMDogMHg0MDA4MDAwMCxcbiAgMHg4MDAwMDA6IDB4NDAwMDQwMDAsXG4gIDB4MTgwMDAwMDogMHg4NDAxMCxcbiAgMHgyODAwMDAwOiAweDEwLFxuICAweDM4MDAwMDA6IDB4NDAwMDQwMTAsXG4gIDB4NDgwMDAwMDogMHg0MDA4NDAxMCxcbiAgMHg1ODAwMDAwOiAweDQwMDAwMDAwLFxuICAweDY4MDAwMDA6IDB4ODAwMDAsXG4gIDB4NzgwMDAwMDogMHg0MDA4MDAxMCxcbiAgMHg4ODAwMDAwOiAweDgwMDEwLFxuICAweDk4MDAwMDA6IDB4MCxcbiAgMHhhODAwMDAwOiAweDQwMDAsXG4gIDB4YjgwMDAwMDogMHg0MDA4MDAwMCxcbiAgMHhjODAwMDAwOiAweDQwMDAwMDEwLFxuICAweGQ4MDAwMDA6IDB4ODQwMDAsXG4gIDB4ZTgwMDAwMDogMHg0MDA4NDAwMCxcbiAgMHhmODAwMDAwOiAweDQwMTAsXG4gIDB4MTAwMDAwMDA6IDB4MCxcbiAgMHgxMTAwMDAwMDogMHg0MDA4MDAxMCxcbiAgMHgxMjAwMDAwMDogMHg0MDAwNDAxMCxcbiAgMHgxMzAwMDAwMDogMHg0MDA4NDAwMCxcbiAgMHgxNDAwMDAwMDogMHg0MDA4MDAwMCxcbiAgMHgxNTAwMDAwMDogMHgxMCxcbiAgMHgxNjAwMDAwMDogMHg4NDAxMCxcbiAgMHgxNzAwMDAwMDogMHg0MDAwLFxuICAweDE4MDAwMDAwOiAweDQwMTAsXG4gIDB4MTkwMDAwMDA6IDB4ODAwMDAsXG4gIDB4MWEwMDAwMDA6IDB4ODAwMTAsXG4gIDB4MWIwMDAwMDA6IDB4NDAwMDAwMTAsXG4gIDB4MWMwMDAwMDA6IDB4ODQwMDAsXG4gIDB4MWQwMDAwMDA6IDB4NDAwMDQwMDAsXG4gIDB4MWUwMDAwMDA6IDB4NDAwMDAwMDAsXG4gIDB4MWYwMDAwMDA6IDB4NDAwODQwMTAsXG4gIDB4MTA4MDAwMDA6IDB4ODQwMTAsXG4gIDB4MTE4MDAwMDA6IDB4ODAwMDAsXG4gIDB4MTI4MDAwMDA6IDB4NDAwODAwMDAsXG4gIDB4MTM4MDAwMDA6IDB4NDAwMCxcbiAgMHgxNDgwMDAwMDogMHg0MDAwNDAwMCxcbiAgMHgxNTgwMDAwMDogMHg0MDA4NDAxMCxcbiAgMHgxNjgwMDAwMDogMHgxMCxcbiAgMHgxNzgwMDAwMDogMHg0MDAwMDAwMCxcbiAgMHgxODgwMDAwMDogMHg0MDA4NDAwMCxcbiAgMHgxOTgwMDAwMDogMHg0MDAwMDAxMCxcbiAgMHgxYTgwMDAwMDogMHg0MDAwNDAxMCxcbiAgMHgxYjgwMDAwMDogMHg4MDAxMCxcbiAgMHgxYzgwMDAwMDogMHgwLFxuICAweDFkODAwMDAwOiAweDQwMTAsXG4gIDB4MWU4MDAwMDA6IDB4NDAwODAwMTAsXG4gIDB4MWY4MDAwMDA6IDB4ODQwMDBcbn0sIHtcbiAgMHgwOiAweDEwNCxcbiAgMHgxMDAwMDA6IDB4MCxcbiAgMHgyMDAwMDA6IDB4NDAwMDEwMCxcbiAgMHgzMDAwMDA6IDB4MTAxMDQsXG4gIDB4NDAwMDAwOiAweDEwMDA0LFxuICAweDUwMDAwMDogMHg0MDAwMDA0LFxuICAweDYwMDAwMDogMHg0MDEwMTA0LFxuICAweDcwMDAwMDogMHg0MDEwMDAwLFxuICAweDgwMDAwMDogMHg0MDAwMDAwLFxuICAweDkwMDAwMDogMHg0MDEwMTAwLFxuICAweGEwMDAwMDogMHgxMDEwMCxcbiAgMHhiMDAwMDA6IDB4NDAxMDAwNCxcbiAgMHhjMDAwMDA6IDB4NDAwMDEwNCxcbiAgMHhkMDAwMDA6IDB4MTAwMDAsXG4gIDB4ZTAwMDAwOiAweDQsXG4gIDB4ZjAwMDAwOiAweDEwMCxcbiAgMHg4MDAwMDogMHg0MDEwMTAwLFxuICAweDE4MDAwMDogMHg0MDEwMDA0LFxuICAweDI4MDAwMDogMHgwLFxuICAweDM4MDAwMDogMHg0MDAwMTAwLFxuICAweDQ4MDAwMDogMHg0MDAwMDA0LFxuICAweDU4MDAwMDogMHgxMDAwMCxcbiAgMHg2ODAwMDA6IDB4MTAwMDQsXG4gIDB4NzgwMDAwOiAweDEwNCxcbiAgMHg4ODAwMDA6IDB4NCxcbiAgMHg5ODAwMDA6IDB4MTAwLFxuICAweGE4MDAwMDogMHg0MDEwMDAwLFxuICAweGI4MDAwMDogMHgxMDEwNCxcbiAgMHhjODAwMDA6IDB4MTAxMDAsXG4gIDB4ZDgwMDAwOiAweDQwMDAxMDQsXG4gIDB4ZTgwMDAwOiAweDQwMTAxMDQsXG4gIDB4ZjgwMDAwOiAweDQwMDAwMDAsXG4gIDB4MTAwMDAwMDogMHg0MDEwMTAwLFxuICAweDExMDAwMDA6IDB4MTAwMDQsXG4gIDB4MTIwMDAwMDogMHgxMDAwMCxcbiAgMHgxMzAwMDAwOiAweDQwMDAxMDAsXG4gIDB4MTQwMDAwMDogMHgxMDAsXG4gIDB4MTUwMDAwMDogMHg0MDEwMTA0LFxuICAweDE2MDAwMDA6IDB4NDAwMDAwNCxcbiAgMHgxNzAwMDAwOiAweDAsXG4gIDB4MTgwMDAwMDogMHg0MDAwMTA0LFxuICAweDE5MDAwMDA6IDB4NDAwMDAwMCxcbiAgMHgxYTAwMDAwOiAweDQsXG4gIDB4MWIwMDAwMDogMHgxMDEwMCxcbiAgMHgxYzAwMDAwOiAweDQwMTAwMDAsXG4gIDB4MWQwMDAwMDogMHgxMDQsXG4gIDB4MWUwMDAwMDogMHgxMDEwNCxcbiAgMHgxZjAwMDAwOiAweDQwMTAwMDQsXG4gIDB4MTA4MDAwMDogMHg0MDAwMDAwLFxuICAweDExODAwMDA6IDB4MTA0LFxuICAweDEyODAwMDA6IDB4NDAxMDEwMCxcbiAgMHgxMzgwMDAwOiAweDAsXG4gIDB4MTQ4MDAwMDogMHgxMDAwNCxcbiAgMHgxNTgwMDAwOiAweDQwMDAxMDAsXG4gIDB4MTY4MDAwMDogMHgxMDAsXG4gIDB4MTc4MDAwMDogMHg0MDEwMDA0LFxuICAweDE4ODAwMDA6IDB4MTAwMDAsXG4gIDB4MTk4MDAwMDogMHg0MDEwMTA0LFxuICAweDFhODAwMDA6IDB4MTAxMDQsXG4gIDB4MWI4MDAwMDogMHg0MDAwMDA0LFxuICAweDFjODAwMDA6IDB4NDAwMDEwNCxcbiAgMHgxZDgwMDAwOiAweDQwMTAwMDAsXG4gIDB4MWU4MDAwMDogMHg0LFxuICAweDFmODAwMDA6IDB4MTAxMDBcbn0sIHtcbiAgMHgwOiAweDgwNDAxMDAwLFxuICAweDEwMDAwOiAweDgwMDAxMDQwLFxuICAweDIwMDAwOiAweDQwMTA0MCxcbiAgMHgzMDAwMDogMHg4MDQwMDAwMCxcbiAgMHg0MDAwMDogMHgwLFxuICAweDUwMDAwOiAweDQwMTAwMCxcbiAgMHg2MDAwMDogMHg4MDAwMDA0MCxcbiAgMHg3MDAwMDogMHg0MDAwNDAsXG4gIDB4ODAwMDA6IDB4ODAwMDAwMDAsXG4gIDB4OTAwMDA6IDB4NDAwMDAwLFxuICAweGEwMDAwOiAweDQwLFxuICAweGIwMDAwOiAweDgwMDAxMDAwLFxuICAweGMwMDAwOiAweDgwNDAwMDQwLFxuICAweGQwMDAwOiAweDEwNDAsXG4gIDB4ZTAwMDA6IDB4MTAwMCxcbiAgMHhmMDAwMDogMHg4MDQwMTA0MCxcbiAgMHg4MDAwOiAweDgwMDAxMDQwLFxuICAweDE4MDAwOiAweDQwLFxuICAweDI4MDAwOiAweDgwNDAwMDQwLFxuICAweDM4MDAwOiAweDgwMDAxMDAwLFxuICAweDQ4MDAwOiAweDQwMTAwMCxcbiAgMHg1ODAwMDogMHg4MDQwMTA0MCxcbiAgMHg2ODAwMDogMHgwLFxuICAweDc4MDAwOiAweDgwNDAwMDAwLFxuICAweDg4MDAwOiAweDEwMDAsXG4gIDB4OTgwMDA6IDB4ODA0MDEwMDAsXG4gIDB4YTgwMDA6IDB4NDAwMDAwLFxuICAweGI4MDAwOiAweDEwNDAsXG4gIDB4YzgwMDA6IDB4ODAwMDAwMDAsXG4gIDB4ZDgwMDA6IDB4NDAwMDQwLFxuICAweGU4MDAwOiAweDQwMTA0MCxcbiAgMHhmODAwMDogMHg4MDAwMDA0MCxcbiAgMHgxMDAwMDA6IDB4NDAwMDQwLFxuICAweDExMDAwMDogMHg0MDEwMDAsXG4gIDB4MTIwMDAwOiAweDgwMDAwMDQwLFxuICAweDEzMDAwMDogMHgwLFxuICAweDE0MDAwMDogMHgxMDQwLFxuICAweDE1MDAwMDogMHg4MDQwMDA0MCxcbiAgMHgxNjAwMDA6IDB4ODA0MDEwMDAsXG4gIDB4MTcwMDAwOiAweDgwMDAxMDQwLFxuICAweDE4MDAwMDogMHg4MDQwMTA0MCxcbiAgMHgxOTAwMDA6IDB4ODAwMDAwMDAsXG4gIDB4MWEwMDAwOiAweDgwNDAwMDAwLFxuICAweDFiMDAwMDogMHg0MDEwNDAsXG4gIDB4MWMwMDAwOiAweDgwMDAxMDAwLFxuICAweDFkMDAwMDogMHg0MDAwMDAsXG4gIDB4MWUwMDAwOiAweDQwLFxuICAweDFmMDAwMDogMHgxMDAwLFxuICAweDEwODAwMDogMHg4MDQwMDAwMCxcbiAgMHgxMTgwMDA6IDB4ODA0MDEwNDAsXG4gIDB4MTI4MDAwOiAweDAsXG4gIDB4MTM4MDAwOiAweDQwMTAwMCxcbiAgMHgxNDgwMDA6IDB4NDAwMDQwLFxuICAweDE1ODAwMDogMHg4MDAwMDAwMCxcbiAgMHgxNjgwMDA6IDB4ODAwMDEwNDAsXG4gIDB4MTc4MDAwOiAweDQwLFxuICAweDE4ODAwMDogMHg4MDAwMDA0MCxcbiAgMHgxOTgwMDA6IDB4MTAwMCxcbiAgMHgxYTgwMDA6IDB4ODAwMDEwMDAsXG4gIDB4MWI4MDAwOiAweDgwNDAwMDQwLFxuICAweDFjODAwMDogMHgxMDQwLFxuICAweDFkODAwMDogMHg4MDQwMTAwMCxcbiAgMHgxZTgwMDA6IDB4NDAwMDAwLFxuICAweDFmODAwMDogMHg0MDEwNDBcbn0sIHtcbiAgMHgwOiAweDgwLFxuICAweDEwMDA6IDB4MTA0MDAwMCxcbiAgMHgyMDAwOiAweDQwMDAwLFxuICAweDMwMDA6IDB4MjAwMDAwMDAsXG4gIDB4NDAwMDogMHgyMDA0MDA4MCxcbiAgMHg1MDAwOiAweDEwMDAwODAsXG4gIDB4NjAwMDogMHgyMTAwMDA4MCxcbiAgMHg3MDAwOiAweDQwMDgwLFxuICAweDgwMDA6IDB4MTAwMDAwMCxcbiAgMHg5MDAwOiAweDIwMDQwMDAwLFxuICAweGEwMDA6IDB4MjAwMDAwODAsXG4gIDB4YjAwMDogMHgyMTA0MDA4MCxcbiAgMHhjMDAwOiAweDIxMDQwMDAwLFxuICAweGQwMDA6IDB4MCxcbiAgMHhlMDAwOiAweDEwNDAwODAsXG4gIDB4ZjAwMDogMHgyMTAwMDAwMCxcbiAgMHg4MDA6IDB4MTA0MDA4MCxcbiAgMHgxODAwOiAweDIxMDAwMDgwLFxuICAweDI4MDA6IDB4ODAsXG4gIDB4MzgwMDogMHgxMDQwMDAwLFxuICAweDQ4MDA6IDB4NDAwMDAsXG4gIDB4NTgwMDogMHgyMDA0MDA4MCxcbiAgMHg2ODAwOiAweDIxMDQwMDAwLFxuICAweDc4MDA6IDB4MjAwMDAwMDAsXG4gIDB4ODgwMDogMHgyMDA0MDAwMCxcbiAgMHg5ODAwOiAweDAsXG4gIDB4YTgwMDogMHgyMTA0MDA4MCxcbiAgMHhiODAwOiAweDEwMDAwODAsXG4gIDB4YzgwMDogMHgyMDAwMDA4MCxcbiAgMHhkODAwOiAweDIxMDAwMDAwLFxuICAweGU4MDA6IDB4MTAwMDAwMCxcbiAgMHhmODAwOiAweDQwMDgwLFxuICAweDEwMDAwOiAweDQwMDAwLFxuICAweDExMDAwOiAweDgwLFxuICAweDEyMDAwOiAweDIwMDAwMDAwLFxuICAweDEzMDAwOiAweDIxMDAwMDgwLFxuICAweDE0MDAwOiAweDEwMDAwODAsXG4gIDB4MTUwMDA6IDB4MjEwNDAwMDAsXG4gIDB4MTYwMDA6IDB4MjAwNDAwODAsXG4gIDB4MTcwMDA6IDB4MTAwMDAwMCxcbiAgMHgxODAwMDogMHgyMTA0MDA4MCxcbiAgMHgxOTAwMDogMHgyMTAwMDAwMCxcbiAgMHgxYTAwMDogMHgxMDQwMDAwLFxuICAweDFiMDAwOiAweDIwMDQwMDAwLFxuICAweDFjMDAwOiAweDQwMDgwLFxuICAweDFkMDAwOiAweDIwMDAwMDgwLFxuICAweDFlMDAwOiAweDAsXG4gIDB4MWYwMDA6IDB4MTA0MDA4MCxcbiAgMHgxMDgwMDogMHgyMTAwMDA4MCxcbiAgMHgxMTgwMDogMHgxMDAwMDAwLFxuICAweDEyODAwOiAweDEwNDAwMDAsXG4gIDB4MTM4MDA6IDB4MjAwNDAwODAsXG4gIDB4MTQ4MDA6IDB4MjAwMDAwMDAsXG4gIDB4MTU4MDA6IDB4MTA0MDA4MCxcbiAgMHgxNjgwMDogMHg4MCxcbiAgMHgxNzgwMDogMHgyMTA0MDAwMCxcbiAgMHgxODgwMDogMHg0MDA4MCxcbiAgMHgxOTgwMDogMHgyMTA0MDA4MCxcbiAgMHgxYTgwMDogMHgwLFxuICAweDFiODAwOiAweDIxMDAwMDAwLFxuICAweDFjODAwOiAweDEwMDAwODAsXG4gIDB4MWQ4MDA6IDB4NDAwMDAsXG4gIDB4MWU4MDA6IDB4MjAwNDAwMDAsXG4gIDB4MWY4MDA6IDB4MjAwMDAwODBcbn0sIHtcbiAgMHgwOiAweDEwMDAwMDA4LFxuICAweDEwMDogMHgyMDAwLFxuICAweDIwMDogMHgxMDIwMDAwMCxcbiAgMHgzMDA6IDB4MTAyMDIwMDgsXG4gIDB4NDAwOiAweDEwMDAyMDAwLFxuICAweDUwMDogMHgyMDAwMDAsXG4gIDB4NjAwOiAweDIwMDAwOCxcbiAgMHg3MDA6IDB4MTAwMDAwMDAsXG4gIDB4ODAwOiAweDAsXG4gIDB4OTAwOiAweDEwMDAyMDA4LFxuICAweGEwMDogMHgyMDIwMDAsXG4gIDB4YjAwOiAweDgsXG4gIDB4YzAwOiAweDEwMjAwMDA4LFxuICAweGQwMDogMHgyMDIwMDgsXG4gIDB4ZTAwOiAweDIwMDgsXG4gIDB4ZjAwOiAweDEwMjAyMDAwLFxuICAweDgwOiAweDEwMjAwMDAwLFxuICAweDE4MDogMHgxMDIwMjAwOCxcbiAgMHgyODA6IDB4OCxcbiAgMHgzODA6IDB4MjAwMDAwLFxuICAweDQ4MDogMHgyMDIwMDgsXG4gIDB4NTgwOiAweDEwMDAwMDA4LFxuICAweDY4MDogMHgxMDAwMjAwMCxcbiAgMHg3ODA6IDB4MjAwOCxcbiAgMHg4ODA6IDB4MjAwMDA4LFxuICAweDk4MDogMHgyMDAwLFxuICAweGE4MDogMHgxMDAwMjAwOCxcbiAgMHhiODA6IDB4MTAyMDAwMDgsXG4gIDB4YzgwOiAweDAsXG4gIDB4ZDgwOiAweDEwMjAyMDAwLFxuICAweGU4MDogMHgyMDIwMDAsXG4gIDB4ZjgwOiAweDEwMDAwMDAwLFxuICAweDEwMDA6IDB4MTAwMDIwMDAsXG4gIDB4MTEwMDogMHgxMDIwMDAwOCxcbiAgMHgxMjAwOiAweDEwMjAyMDA4LFxuICAweDEzMDA6IDB4MjAwOCxcbiAgMHgxNDAwOiAweDIwMDAwMCxcbiAgMHgxNTAwOiAweDEwMDAwMDAwLFxuICAweDE2MDA6IDB4MTAwMDAwMDgsXG4gIDB4MTcwMDogMHgyMDIwMDAsXG4gIDB4MTgwMDogMHgyMDIwMDgsXG4gIDB4MTkwMDogMHgwLFxuICAweDFhMDA6IDB4OCxcbiAgMHgxYjAwOiAweDEwMjAwMDAwLFxuICAweDFjMDA6IDB4MjAwMCxcbiAgMHgxZDAwOiAweDEwMDAyMDA4LFxuICAweDFlMDA6IDB4MTAyMDIwMDAsXG4gIDB4MWYwMDogMHgyMDAwMDgsXG4gIDB4MTA4MDogMHg4LFxuICAweDExODA6IDB4MjAyMDAwLFxuICAweDEyODA6IDB4MjAwMDAwLFxuICAweDEzODA6IDB4MTAwMDAwMDgsXG4gIDB4MTQ4MDogMHgxMDAwMjAwMCxcbiAgMHgxNTgwOiAweDIwMDgsXG4gIDB4MTY4MDogMHgxMDIwMjAwOCxcbiAgMHgxNzgwOiAweDEwMjAwMDAwLFxuICAweDE4ODA6IDB4MTAyMDIwMDAsXG4gIDB4MTk4MDogMHgxMDIwMDAwOCxcbiAgMHgxYTgwOiAweDIwMDAsXG4gIDB4MWI4MDogMHgyMDIwMDgsXG4gIDB4MWM4MDogMHgyMDAwMDgsXG4gIDB4MWQ4MDogMHgwLFxuICAweDFlODA6IDB4MTAwMDAwMDAsXG4gIDB4MWY4MDogMHgxMDAwMjAwOFxufSwge1xuICAweDA6IDB4MTAwMDAwLFxuICAweDEwOiAweDIwMDA0MDEsXG4gIDB4MjA6IDB4NDAwLFxuICAweDMwOiAweDEwMDQwMSxcbiAgMHg0MDogMHgyMTAwNDAxLFxuICAweDUwOiAweDAsXG4gIDB4NjA6IDB4MSxcbiAgMHg3MDogMHgyMTAwMDAxLFxuICAweDgwOiAweDIwMDA0MDAsXG4gIDB4OTA6IDB4MTAwMDAxLFxuICAweGEwOiAweDIwMDAwMDEsXG4gIDB4YjA6IDB4MjEwMDQwMCxcbiAgMHhjMDogMHgyMTAwMDAwLFxuICAweGQwOiAweDQwMSxcbiAgMHhlMDogMHgxMDA0MDAsXG4gIDB4ZjA6IDB4MjAwMDAwMCxcbiAgMHg4OiAweDIxMDAwMDEsXG4gIDB4MTg6IDB4MCxcbiAgMHgyODogMHgyMDAwNDAxLFxuICAweDM4OiAweDIxMDA0MDAsXG4gIDB4NDg6IDB4MTAwMDAwLFxuICAweDU4OiAweDIwMDAwMDEsXG4gIDB4Njg6IDB4MjAwMDAwMCxcbiAgMHg3ODogMHg0MDEsXG4gIDB4ODg6IDB4MTAwNDAxLFxuICAweDk4OiAweDIwMDA0MDAsXG4gIDB4YTg6IDB4MjEwMDAwMCxcbiAgMHhiODogMHgxMDAwMDEsXG4gIDB4Yzg6IDB4NDAwLFxuICAweGQ4OiAweDIxMDA0MDEsXG4gIDB4ZTg6IDB4MSxcbiAgMHhmODogMHgxMDA0MDAsXG4gIDB4MTAwOiAweDIwMDAwMDAsXG4gIDB4MTEwOiAweDEwMDAwMCxcbiAgMHgxMjA6IDB4MjAwMDQwMSxcbiAgMHgxMzA6IDB4MjEwMDAwMSxcbiAgMHgxNDA6IDB4MTAwMDAxLFxuICAweDE1MDogMHgyMDAwNDAwLFxuICAweDE2MDogMHgyMTAwNDAwLFxuICAweDE3MDogMHgxMDA0MDEsXG4gIDB4MTgwOiAweDQwMSxcbiAgMHgxOTA6IDB4MjEwMDQwMSxcbiAgMHgxYTA6IDB4MTAwNDAwLFxuICAweDFiMDogMHgxLFxuICAweDFjMDogMHgwLFxuICAweDFkMDogMHgyMTAwMDAwLFxuICAweDFlMDogMHgyMDAwMDAxLFxuICAweDFmMDogMHg0MDAsXG4gIDB4MTA4OiAweDEwMDQwMCxcbiAgMHgxMTg6IDB4MjAwMDQwMSxcbiAgMHgxMjg6IDB4MjEwMDAwMSxcbiAgMHgxMzg6IDB4MSxcbiAgMHgxNDg6IDB4MjAwMDAwMCxcbiAgMHgxNTg6IDB4MTAwMDAwLFxuICAweDE2ODogMHg0MDEsXG4gIDB4MTc4OiAweDIxMDA0MDAsXG4gIDB4MTg4OiAweDIwMDAwMDEsXG4gIDB4MTk4OiAweDIxMDAwMDAsXG4gIDB4MWE4OiAweDAsXG4gIDB4MWI4OiAweDIxMDA0MDEsXG4gIDB4MWM4OiAweDEwMDQwMSxcbiAgMHgxZDg6IDB4NDAwLFxuICAweDFlODogMHgyMDAwNDAwLFxuICAweDFmODogMHgxMDAwMDFcbn0sIHtcbiAgMHgwOiAweDgwMDA4MjAsXG4gIDB4MTogMHgyMDAwMCxcbiAgMHgyOiAweDgwMDAwMDAsXG4gIDB4MzogMHgyMCxcbiAgMHg0OiAweDIwMDIwLFxuICAweDU6IDB4ODAyMDgyMCxcbiAgMHg2OiAweDgwMjA4MDAsXG4gIDB4NzogMHg4MDAsXG4gIDB4ODogMHg4MDIwMDAwLFxuICAweDk6IDB4ODAwMDgwMCxcbiAgMHhhOiAweDIwODAwLFxuICAweGI6IDB4ODAyMDAyMCxcbiAgMHhjOiAweDgyMCxcbiAgMHhkOiAweDAsXG4gIDB4ZTogMHg4MDAwMDIwLFxuICAweGY6IDB4MjA4MjAsXG4gIDB4ODAwMDAwMDA6IDB4ODAwLFxuICAweDgwMDAwMDAxOiAweDgwMjA4MjAsXG4gIDB4ODAwMDAwMDI6IDB4ODAwMDgyMCxcbiAgMHg4MDAwMDAwMzogMHg4MDAwMDAwLFxuICAweDgwMDAwMDA0OiAweDgwMjAwMDAsXG4gIDB4ODAwMDAwMDU6IDB4MjA4MDAsXG4gIDB4ODAwMDAwMDY6IDB4MjA4MjAsXG4gIDB4ODAwMDAwMDc6IDB4MjAsXG4gIDB4ODAwMDAwMDg6IDB4ODAwMDAyMCxcbiAgMHg4MDAwMDAwOTogMHg4MjAsXG4gIDB4ODAwMDAwMGE6IDB4MjAwMjAsXG4gIDB4ODAwMDAwMGI6IDB4ODAyMDgwMCxcbiAgMHg4MDAwMDAwYzogMHgwLFxuICAweDgwMDAwMDBkOiAweDgwMjAwMjAsXG4gIDB4ODAwMDAwMGU6IDB4ODAwMDgwMCxcbiAgMHg4MDAwMDAwZjogMHgyMDAwMCxcbiAgMHgxMDogMHgyMDgyMCxcbiAgMHgxMTogMHg4MDIwODAwLFxuICAweDEyOiAweDIwLFxuICAweDEzOiAweDgwMCxcbiAgMHgxNDogMHg4MDAwODAwLFxuICAweDE1OiAweDgwMDAwMjAsXG4gIDB4MTY6IDB4ODAyMDAyMCxcbiAgMHgxNzogMHgyMDAwMCxcbiAgMHgxODogMHgwLFxuICAweDE5OiAweDIwMDIwLFxuICAweDFhOiAweDgwMjAwMDAsXG4gIDB4MWI6IDB4ODAwMDgyMCxcbiAgMHgxYzogMHg4MDIwODIwLFxuICAweDFkOiAweDIwODAwLFxuICAweDFlOiAweDgyMCxcbiAgMHgxZjogMHg4MDAwMDAwLFxuICAweDgwMDAwMDEwOiAweDIwMDAwLFxuICAweDgwMDAwMDExOiAweDgwMCxcbiAgMHg4MDAwMDAxMjogMHg4MDIwMDIwLFxuICAweDgwMDAwMDEzOiAweDIwODIwLFxuICAweDgwMDAwMDE0OiAweDIwLFxuICAweDgwMDAwMDE1OiAweDgwMjAwMDAsXG4gIDB4ODAwMDAwMTY6IDB4ODAwMDAwMCxcbiAgMHg4MDAwMDAxNzogMHg4MDAwODIwLFxuICAweDgwMDAwMDE4OiAweDgwMjA4MjAsXG4gIDB4ODAwMDAwMTk6IDB4ODAwMDAyMCxcbiAgMHg4MDAwMDAxYTogMHg4MDAwODAwLFxuICAweDgwMDAwMDFiOiAweDAsXG4gIDB4ODAwMDAwMWM6IDB4MjA4MDAsXG4gIDB4ODAwMDAwMWQ6IDB4ODIwLFxuICAweDgwMDAwMDFlOiAweDIwMDIwLFxuICAweDgwMDAwMDFmOiAweDgwMjA4MDBcbn1dOyAvLyBNYXNrcyB0aGF0IHNlbGVjdCB0aGUgU0JPWCBpbnB1dFxuXG5jb25zdCBTQk9YX01BU0sgPSBbMHhmODAwMDAwMSwgMHgxZjgwMDAwMCwgMHgwMWY4MDAwMCwgMHgwMDFmODAwMCwgMHgwMDAxZjgwMCwgMHgwMDAwMWY4MCwgMHgwMDAwMDFmOCwgMHg4MDAwMDAxZl07IC8vIFN3YXAgYml0cyBhY3Jvc3MgdGhlIGxlZnQgYW5kIHJpZ2h0IHdvcmRzXG5cbmZ1bmN0aW9uIGV4Y2hhbmdlTFIob2Zmc2V0LCBtYXNrKSB7XG4gIGNvbnN0IHQgPSAodGhpcy5fbEJsb2NrID4+PiBvZmZzZXQgXiB0aGlzLl9yQmxvY2spICYgbWFzaztcbiAgdGhpcy5fckJsb2NrIF49IHQ7XG4gIHRoaXMuX2xCbG9jayBePSB0IDw8IG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZXhjaGFuZ2VSTChvZmZzZXQsIG1hc2spIHtcbiAgY29uc3QgdCA9ICh0aGlzLl9yQmxvY2sgPj4+IG9mZnNldCBeIHRoaXMuX2xCbG9jaykgJiBtYXNrO1xuICB0aGlzLl9sQmxvY2sgXj0gdDtcbiAgdGhpcy5fckJsb2NrIF49IHQgPDwgb2Zmc2V0O1xufVxuLyoqXG4gKiBERVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cbiAqL1xuXG5cbmNsYXNzIERFU0FsZ28gZXh0ZW5kcyBCbG9ja0NpcGhlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmtleVNpemUgPSA2NCAvIDMyO1xuICAgIHRoaXMuaXZTaXplID0gNjQgLyAzMjtcbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDY0IC8gMzI7XG4gIH1cblxuICBfZG9SZXNldCgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBrZXkgPSB0aGlzLl9rZXk7XG4gICAgY29uc3Qga2V5V29yZHMgPSBrZXkud29yZHM7IC8vIFNlbGVjdCA1NiBiaXRzIGFjY29yZGluZyB0byBQQzFcblxuICAgIGNvbnN0IGtleUJpdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTY7IGkgKz0gMSkge1xuICAgICAgY29uc3Qga2V5Qml0UG9zID0gUEMxW2ldIC0gMTtcbiAgICAgIGtleUJpdHNbaV0gPSBrZXlXb3Jkc1trZXlCaXRQb3MgPj4+IDVdID4+PiAzMSAtIGtleUJpdFBvcyAlIDMyICYgMTtcbiAgICB9IC8vIEFzc2VtYmxlIDE2IHN1YmtleXNcblxuXG4gICAgdGhpcy5fc3ViS2V5cyA9IFtdO1xuICAgIGNvbnN0IHN1YktleXMgPSB0aGlzLl9zdWJLZXlzO1xuXG4gICAgZm9yIChsZXQgblN1YktleSA9IDA7IG5TdWJLZXkgPCAxNjsgblN1YktleSArPSAxKSB7XG4gICAgICAvLyBDcmVhdGUgc3Via2V5XG4gICAgICBzdWJLZXlzW25TdWJLZXldID0gW107XG4gICAgICBjb25zdCBzdWJLZXkgPSBzdWJLZXlzW25TdWJLZXldOyAvLyBTaG9ydGN1dFxuXG4gICAgICBjb25zdCBiaXRTaGlmdCA9IEJJVF9TSElGVFNbblN1YktleV07IC8vIFNlbGVjdCA0OCBiaXRzIGFjY29yZGluZyB0byBQQzJcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNDsgaSArPSAxKSB7XG4gICAgICAgIC8vIFNlbGVjdCBmcm9tIHRoZSBsZWZ0IDI4IGtleSBiaXRzXG4gICAgICAgIHN1YktleVtpIC8gNiB8IDBdIHw9IGtleUJpdHNbKFBDMltpXSAtIDEgKyBiaXRTaGlmdCkgJSAyOF0gPDwgMzEgLSBpICUgNjsgLy8gU2VsZWN0IGZyb20gdGhlIHJpZ2h0IDI4IGtleSBiaXRzXG5cbiAgICAgICAgc3ViS2V5WzQgKyAoaSAvIDYgfCAwKV0gfD0ga2V5Qml0c1syOCArIChQQzJbaSArIDI0XSAtIDEgKyBiaXRTaGlmdCkgJSAyOF0gPDwgMzEgLSBpICUgNjtcbiAgICAgIH0gLy8gU2luY2UgZWFjaCBzdWJrZXkgaXMgYXBwbGllZCB0byBhbiBleHBhbmRlZCAzMi1iaXQgaW5wdXQsXG4gICAgICAvLyB0aGUgc3Via2V5IGNhbiBiZSBicm9rZW4gaW50byA4IHZhbHVlcyBzY2FsZWQgdG8gMzItYml0cyxcbiAgICAgIC8vIHdoaWNoIGFsbG93cyB0aGUga2V5IHRvIGJlIHVzZWQgd2l0aG91dCBleHBhbnNpb25cblxuXG4gICAgICBzdWJLZXlbMF0gPSBzdWJLZXlbMF0gPDwgMSB8IHN1YktleVswXSA+Pj4gMzE7XG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgIHN1YktleVtpXSA+Pj49IChpIC0gMSkgKiA0ICsgMztcbiAgICAgIH1cblxuICAgICAgc3ViS2V5WzddID0gc3ViS2V5WzddIDw8IDUgfCBzdWJLZXlbN10gPj4+IDI3O1xuICAgIH0gLy8gQ29tcHV0ZSBpbnZlcnNlIHN1YmtleXNcblxuXG4gICAgdGhpcy5faW52U3ViS2V5cyA9IFtdO1xuICAgIGNvbnN0IGludlN1YktleXMgPSB0aGlzLl9pbnZTdWJLZXlzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICBpbnZTdWJLZXlzW2ldID0gc3ViS2V5c1sxNSAtIGldO1xuICAgIH1cbiAgfVxuXG4gIGVuY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9zdWJLZXlzKTtcbiAgfVxuXG4gIGRlY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZTdWJLZXlzKTtcbiAgfVxuXG4gIF9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCBzdWJLZXlzKSB7XG4gICAgY29uc3QgX00gPSBNOyAvLyBHZXQgaW5wdXRcblxuICAgIHRoaXMuX2xCbG9jayA9IE1bb2Zmc2V0XTtcbiAgICB0aGlzLl9yQmxvY2sgPSBNW29mZnNldCArIDFdOyAvLyBJbml0aWFsIHBlcm11dGF0aW9uXG5cbiAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgMHgwZjBmMGYwZik7XG4gICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcbiAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgMHgzMzMzMzMzMyk7XG4gICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsIDB4MDBmZjAwZmYpO1xuICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAweDU1NTU1NTU1KTsgLy8gUm91bmRzXG5cbiAgICBmb3IgKGxldCByb3VuZCA9IDA7IHJvdW5kIDwgMTY7IHJvdW5kICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3Qgc3ViS2V5ID0gc3ViS2V5c1tyb3VuZF07XG4gICAgICBjb25zdCBsQmxvY2sgPSB0aGlzLl9sQmxvY2s7XG4gICAgICBjb25zdCByQmxvY2sgPSB0aGlzLl9yQmxvY2s7IC8vIEZlaXN0ZWwgZnVuY3Rpb25cblxuICAgICAgbGV0IGYgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgICAgICBmIHw9IFNCT1hfUFtpXVsoKHJCbG9jayBeIHN1YktleVtpXSkgJiBTQk9YX01BU0tbaV0pID4+PiAwXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbEJsb2NrID0gckJsb2NrO1xuICAgICAgdGhpcy5fckJsb2NrID0gbEJsb2NrIF4gZjtcbiAgICB9IC8vIFVuZG8gc3dhcCBmcm9tIGxhc3Qgcm91bmRcblxuXG4gICAgY29uc3QgdCA9IHRoaXMuX2xCbG9jaztcbiAgICB0aGlzLl9sQmxvY2sgPSB0aGlzLl9yQmxvY2s7XG4gICAgdGhpcy5fckJsb2NrID0gdDsgLy8gRmluYWwgcGVybXV0YXRpb25cblxuICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAweDU1NTU1NTU1KTtcbiAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgOCwgMHgwMGZmMDBmZik7XG4gICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDIsIDB4MzMzMzMzMzMpO1xuICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxNiwgMHgwMDAwZmZmZik7XG4gICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDQsIDB4MGYwZjBmMGYpOyAvLyBTZXQgb3V0cHV0XG5cbiAgICBfTVtvZmZzZXRdID0gdGhpcy5fbEJsb2NrO1xuICAgIF9NW29mZnNldCArIDFdID0gdGhpcy5fckJsb2NrO1xuICB9XG5cbn1cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5cblxuY29uc3QgREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihERVNBbGdvKTtcbi8qKlxuICogVHJpcGxlLURFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5cblxuY2xhc3MgVHJpcGxlREVTQWxnbyBleHRlbmRzIEJsb2NrQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMua2V5U2l6ZSA9IDE5MiAvIDMyO1xuICAgIHRoaXMuaXZTaXplID0gNjQgLyAzMjtcbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDY0IC8gMzI7XG4gIH1cblxuICBfZG9SZXNldCgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBrZXkgPSB0aGlzLl9rZXk7XG4gICAgY29uc3Qga2V5V29yZHMgPSBrZXkud29yZHM7IC8vIENyZWF0ZSBERVMgaW5zdGFuY2VzXG5cbiAgICB0aGlzLl9kZXMxID0gREVTQWxnby5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgwLCAyKSkpO1xuICAgIHRoaXMuX2RlczIgPSBERVNBbGdvLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDIsIDQpKSk7XG4gICAgdGhpcy5fZGVzMyA9IERFU0FsZ28uY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoNCwgNikpKTtcbiAgfVxuXG4gIGVuY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9kZXMxLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXG4gICAgdGhpcy5fZGVzMi5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblxuICAgIHRoaXMuX2RlczMuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG4gIH1cblxuICBkZWNyeXB0QmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5fZGVzMy5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblxuICAgIHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cbiAgICB0aGlzLl9kZXMxLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuICB9XG5cbn1cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuVHJpcGxlREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuVHJpcGxlREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5cblxuY29uc3QgVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihUcmlwbGVERVNBbGdvKTsgLy8gUmV1c2FibGUgb2JqZWN0c1xuXG5cbmNvbnN0IFMgPSBbXTtcbmNvbnN0IENfID0gW107XG5jb25zdCBHID0gW107XG5cbmZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIGNvbnN0IFggPSB0aGlzLl9YO1xuICBjb25zdCBDID0gdGhpcy5fQzsgLy8gU2F2ZSBvbGQgY291bnRlciB2YWx1ZXNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIENfW2ldID0gQ1tpXTtcbiAgfSAvLyBDYWxjdWxhdGUgbmV3IGNvdW50ZXIgdmFsdWVzXG5cblxuICBDWzBdID0gQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iIHwgMDtcbiAgQ1sxXSA9IENbMV0gKyAweGQzNGQzNGQzICsgKENbMF0gPj4+IDAgPCBDX1swXSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbMl0gPSBDWzJdICsgMHgzNGQzNGQzNCArIChDWzFdID4+PiAwIDwgQ19bMV0gPj4+IDAgPyAxIDogMCkgfCAwO1xuICBDWzNdID0gQ1szXSArIDB4NGQzNGQzNGQgKyAoQ1syXSA+Pj4gMCA8IENfWzJdID4+PiAwID8gMSA6IDApIHwgMDtcbiAgQ1s0XSA9IENbNF0gKyAweGQzNGQzNGQzICsgKENbM10gPj4+IDAgPCBDX1szXSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbNV0gPSBDWzVdICsgMHgzNGQzNGQzNCArIChDWzRdID4+PiAwIDwgQ19bNF0gPj4+IDAgPyAxIDogMCkgfCAwO1xuICBDWzZdID0gQ1s2XSArIDB4NGQzNGQzNGQgKyAoQ1s1XSA+Pj4gMCA8IENfWzVdID4+PiAwID8gMSA6IDApIHwgMDtcbiAgQ1s3XSA9IENbN10gKyAweGQzNGQzNGQzICsgKENbNl0gPj4+IDAgPCBDX1s2XSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIHRoaXMuX2IgPSBDWzddID4+PiAwIDwgQ19bN10gPj4+IDAgPyAxIDogMDsgLy8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgY29uc3QgZ3ggPSBYW2ldICsgQ1tpXTsgLy8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcblxuICAgIGNvbnN0IGdhID0gZ3ggJiAweGZmZmY7XG4gICAgY29uc3QgZ2IgPSBneCA+Pj4gMTY7IC8vIENhbGN1bGF0ZSBoaWdoIGFuZCBsb3cgcmVzdWx0IG9mIHNxdWFyaW5nXG5cbiAgICBjb25zdCBnaCA9ICgoZ2EgKiBnYSA+Pj4gMTcpICsgZ2EgKiBnYiA+Pj4gMTUpICsgZ2IgKiBnYjtcbiAgICBjb25zdCBnbCA9ICgoZ3ggJiAweGZmZmYwMDAwKSAqIGd4IHwgMCkgKyAoKGd4ICYgMHgwMDAwZmZmZikgKiBneCB8IDApOyAvLyBIaWdoIFhPUiBsb3dcblxuICAgIEdbaV0gPSBnaCBeIGdsO1xuICB9IC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXG5cblxuICBYWzBdID0gR1swXSArIChHWzddIDw8IDE2IHwgR1s3XSA+Pj4gMTYpICsgKEdbNl0gPDwgMTYgfCBHWzZdID4+PiAxNikgfCAwO1xuICBYWzFdID0gR1sxXSArIChHWzBdIDw8IDggfCBHWzBdID4+PiAyNCkgKyBHWzddIHwgMDtcbiAgWFsyXSA9IEdbMl0gKyAoR1sxXSA8PCAxNiB8IEdbMV0gPj4+IDE2KSArIChHWzBdIDw8IDE2IHwgR1swXSA+Pj4gMTYpIHwgMDtcbiAgWFszXSA9IEdbM10gKyAoR1syXSA8PCA4IHwgR1syXSA+Pj4gMjQpICsgR1sxXSB8IDA7XG4gIFhbNF0gPSBHWzRdICsgKEdbM10gPDwgMTYgfCBHWzNdID4+PiAxNikgKyAoR1syXSA8PCAxNiB8IEdbMl0gPj4+IDE2KSB8IDA7XG4gIFhbNV0gPSBHWzVdICsgKEdbNF0gPDwgOCB8IEdbNF0gPj4+IDI0KSArIEdbM10gfCAwO1xuICBYWzZdID0gR1s2XSArIChHWzVdIDw8IDE2IHwgR1s1XSA+Pj4gMTYpICsgKEdbNF0gPDwgMTYgfCBHWzRdID4+PiAxNikgfCAwO1xuICBYWzddID0gR1s3XSArIChHWzZdIDw8IDggfCBHWzZdID4+PiAyNCkgKyBHWzVdIHwgMDtcbn1cbi8qKlxuICogUmFiYml0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtXG4gKi9cblxuXG5jbGFzcyBSYWJiaXRBbGdvIGV4dGVuZHMgU3RyZWFtQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuYmxvY2tTaXplID0gMTI4IC8gMzI7XG4gICAgdGhpcy5pdlNpemUgPSA2NCAvIDMyO1xuICB9XG5cbiAgX2RvUmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgSyA9IHRoaXMuX2tleS53b3JkcztcbiAgICBjb25zdCB7XG4gICAgICBpdlxuICAgIH0gPSB0aGlzLmNmZzsgLy8gU3dhcCBlbmRpYW5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICBLW2ldID0gKEtbaV0gPDwgOCB8IEtbaV0gPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoS1tpXSA8PCAyNCB8IEtbaV0gPj4+IDgpICYgMHhmZjAwZmYwMDtcbiAgICB9IC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXG5cblxuICAgIHRoaXMuX1ggPSBbS1swXSwgS1szXSA8PCAxNiB8IEtbMl0gPj4+IDE2LCBLWzFdLCBLWzBdIDw8IDE2IHwgS1szXSA+Pj4gMTYsIEtbMl0sIEtbMV0gPDwgMTYgfCBLWzBdID4+PiAxNiwgS1szXSwgS1syXSA8PCAxNiB8IEtbMV0gPj4+IDE2XTtcbiAgICBjb25zdCBYID0gdGhpcy5fWDsgLy8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xuXG4gICAgdGhpcy5fQyA9IFtLWzJdIDw8IDE2IHwgS1syXSA+Pj4gMTYsIEtbMF0gJiAweGZmZmYwMDAwIHwgS1sxXSAmIDB4MDAwMGZmZmYsIEtbM10gPDwgMTYgfCBLWzNdID4+PiAxNiwgS1sxXSAmIDB4ZmZmZjAwMDAgfCBLWzJdICYgMHgwMDAwZmZmZiwgS1swXSA8PCAxNiB8IEtbMF0gPj4+IDE2LCBLWzJdICYgMHhmZmZmMDAwMCB8IEtbM10gJiAweDAwMDBmZmZmLCBLWzFdIDw8IDE2IHwgS1sxXSA+Pj4gMTYsIEtbM10gJiAweGZmZmYwMDAwIHwgS1swXSAmIDB4MDAwMGZmZmZdO1xuICAgIGNvbnN0IEMgPSB0aGlzLl9DOyAvLyBDYXJyeSBiaXRcblxuICAgIHRoaXMuX2IgPSAwOyAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuICAgIH0gLy8gTW9kaWZ5IHRoZSBjb3VudGVyc1xuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgICAgQ1tpXSBePSBYW2kgKyA0ICYgN107XG4gICAgfSAvLyBJViBzZXR1cFxuXG5cbiAgICBpZiAoaXYpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3QgSVYgPSBpdi53b3JkcztcbiAgICAgIGNvbnN0IElWXzAgPSBJVlswXTtcbiAgICAgIGNvbnN0IElWXzEgPSBJVlsxXTsgLy8gR2VuZXJhdGUgZm91ciBzdWJ2ZWN0b3JzXG5cbiAgICAgIGNvbnN0IGkwID0gKElWXzAgPDwgOCB8IElWXzAgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoSVZfMCA8PCAyNCB8IElWXzAgPj4+IDgpICYgMHhmZjAwZmYwMDtcbiAgICAgIGNvbnN0IGkyID0gKElWXzEgPDwgOCB8IElWXzEgPj4+IDI0KSAmIDB4MDBmZjAwZmYgfCAoSVZfMSA8PCAyNCB8IElWXzEgPj4+IDgpICYgMHhmZjAwZmYwMDtcbiAgICAgIGNvbnN0IGkxID0gaTAgPj4+IDE2IHwgaTIgJiAweGZmZmYwMDAwO1xuICAgICAgY29uc3QgaTMgPSBpMiA8PCAxNiB8IGkwICYgMHgwMDAwZmZmZjsgLy8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXG5cbiAgICAgIENbMF0gXj0gaTA7XG4gICAgICBDWzFdIF49IGkxO1xuICAgICAgQ1syXSBePSBpMjtcbiAgICAgIENbM10gXj0gaTM7XG4gICAgICBDWzRdIF49IGkwO1xuICAgICAgQ1s1XSBePSBpMTtcbiAgICAgIENbNl0gXj0gaTI7XG4gICAgICBDWzddIF49IGkzOyAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNOyAvLyBTaG9ydGN1dFxuXG4gICAgY29uc3QgWCA9IHRoaXMuX1g7IC8vIEl0ZXJhdGUgdGhlIHN5c3RlbVxuXG4gICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7IC8vIEdlbmVyYXRlIGZvdXIga2V5c3RyZWFtIHdvcmRzXG5cbiAgICBTWzBdID0gWFswXSBeIFhbNV0gPj4+IDE2IF4gWFszXSA8PCAxNjtcbiAgICBTWzFdID0gWFsyXSBeIFhbN10gPj4+IDE2IF4gWFs1XSA8PCAxNjtcbiAgICBTWzJdID0gWFs0XSBeIFhbMV0gPj4+IDE2IF4gWFs3XSA8PCAxNjtcbiAgICBTWzNdID0gWFs2XSBeIFhbM10gPj4+IDE2IF4gWFsxXSA8PCAxNjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAvLyBTd2FwIGVuZGlhblxuICAgICAgU1tpXSA9IChTW2ldIDw8IDggfCBTW2ldID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKFNbaV0gPDwgMjQgfCBTW2ldID4+PiA4KSAmIDB4ZmYwMGZmMDA7IC8vIEVuY3J5cHRcblxuICAgICAgX01bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcbiAgICB9XG4gIH1cblxufVxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gKi9cblxuXG5jb25zdCBSYWJiaXQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXRBbGdvKTsgLy8gUmV1c2FibGUgb2JqZWN0c1xuXG5cbmNvbnN0IFMkMSA9IFtdO1xuY29uc3QgQ18kMSA9IFtdO1xuY29uc3QgRyQxID0gW107XG5cbmZ1bmN0aW9uIG5leHRTdGF0ZSQxKCkge1xuICAvLyBTaG9ydGN1dHNcbiAgY29uc3QgWCA9IHRoaXMuX1g7XG4gIGNvbnN0IEMgPSB0aGlzLl9DOyAvLyBTYXZlIG9sZCBjb3VudGVyIHZhbHVlc1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgQ18kMVtpXSA9IENbaV07XG4gIH0gLy8gQ2FsY3VsYXRlIG5ldyBjb3VudGVyIHZhbHVlc1xuXG5cbiAgQ1swXSA9IENbMF0gKyAweDRkMzRkMzRkICsgdGhpcy5fYiB8IDA7XG4gIENbMV0gPSBDWzFdICsgMHhkMzRkMzRkMyArIChDWzBdID4+PiAwIDwgQ18kMVswXSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbMl0gPSBDWzJdICsgMHgzNGQzNGQzNCArIChDWzFdID4+PiAwIDwgQ18kMVsxXSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbM10gPSBDWzNdICsgMHg0ZDM0ZDM0ZCArIChDWzJdID4+PiAwIDwgQ18kMVsyXSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbNF0gPSBDWzRdICsgMHhkMzRkMzRkMyArIChDWzNdID4+PiAwIDwgQ18kMVszXSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbNV0gPSBDWzVdICsgMHgzNGQzNGQzNCArIChDWzRdID4+PiAwIDwgQ18kMVs0XSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbNl0gPSBDWzZdICsgMHg0ZDM0ZDM0ZCArIChDWzVdID4+PiAwIDwgQ18kMVs1XSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIENbN10gPSBDWzddICsgMHhkMzRkMzRkMyArIChDWzZdID4+PiAwIDwgQ18kMVs2XSA+Pj4gMCA/IDEgOiAwKSB8IDA7XG4gIHRoaXMuX2IgPSBDWzddID4+PiAwIDwgQ18kMVs3XSA+Pj4gMCA/IDEgOiAwOyAvLyBDYWxjdWxhdGUgdGhlIGctdmFsdWVzXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBjb25zdCBneCA9IFhbaV0gKyBDW2ldOyAvLyBDb25zdHJ1Y3QgaGlnaCBhbmQgbG93IGFyZ3VtZW50IGZvciBzcXVhcmluZ1xuXG4gICAgY29uc3QgZ2EgPSBneCAmIDB4ZmZmZjtcbiAgICBjb25zdCBnYiA9IGd4ID4+PiAxNjsgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcblxuICAgIGNvbnN0IGdoID0gKChnYSAqIGdhID4+PiAxNykgKyBnYSAqIGdiID4+PiAxNSkgKyBnYiAqIGdiO1xuICAgIGNvbnN0IGdsID0gKChneCAmIDB4ZmZmZjAwMDApICogZ3ggfCAwKSArICgoZ3ggJiAweDAwMDBmZmZmKSAqIGd4IHwgMCk7IC8vIEhpZ2ggWE9SIGxvd1xuXG4gICAgRyQxW2ldID0gZ2ggXiBnbDtcbiAgfSAvLyBDYWxjdWxhdGUgbmV3IHN0YXRlIHZhbHVlc1xuXG5cbiAgWFswXSA9IEckMVswXSArIChHJDFbN10gPDwgMTYgfCBHJDFbN10gPj4+IDE2KSArIChHJDFbNl0gPDwgMTYgfCBHJDFbNl0gPj4+IDE2KSB8IDA7XG4gIFhbMV0gPSBHJDFbMV0gKyAoRyQxWzBdIDw8IDggfCBHJDFbMF0gPj4+IDI0KSArIEckMVs3XSB8IDA7XG4gIFhbMl0gPSBHJDFbMl0gKyAoRyQxWzFdIDw8IDE2IHwgRyQxWzFdID4+PiAxNikgKyAoRyQxWzBdIDw8IDE2IHwgRyQxWzBdID4+PiAxNikgfCAwO1xuICBYWzNdID0gRyQxWzNdICsgKEckMVsyXSA8PCA4IHwgRyQxWzJdID4+PiAyNCkgKyBHJDFbMV0gfCAwO1xuICBYWzRdID0gRyQxWzRdICsgKEckMVszXSA8PCAxNiB8IEckMVszXSA+Pj4gMTYpICsgKEckMVsyXSA8PCAxNiB8IEckMVsyXSA+Pj4gMTYpIHwgMDtcbiAgWFs1XSA9IEckMVs1XSArIChHJDFbNF0gPDwgOCB8IEckMVs0XSA+Pj4gMjQpICsgRyQxWzNdIHwgMDtcbiAgWFs2XSA9IEckMVs2XSArIChHJDFbNV0gPDwgMTYgfCBHJDFbNV0gPj4+IDE2KSArIChHJDFbNF0gPDwgMTYgfCBHJDFbNF0gPj4+IDE2KSB8IDA7XG4gIFhbN10gPSBHJDFbN10gKyAoRyQxWzZdIDw8IDggfCBHJDFbNl0gPj4+IDI0KSArIEckMVs1XSB8IDA7XG59XG4vKipcbiAqIFJhYmJpdCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cbiAqXG4gKiBUaGlzIGlzIGEgbGVnYWN5IHZlcnNpb24gdGhhdCBuZWdsZWN0ZWQgdG8gY29udmVydCB0aGUga2V5IHRvIGxpdHRsZS1lbmRpYW4uXG4gKiBUaGlzIGVycm9yIGRvZXNuJ3QgYWZmZWN0IHRoZSBjaXBoZXIncyBzZWN1cml0eSxcbiAqIGJ1dCBpdCBkb2VzIGFmZmVjdCBpdHMgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucy5cbiAqL1xuXG5cbmNsYXNzIFJhYmJpdExlZ2FjeUFsZ28gZXh0ZW5kcyBTdHJlYW1DaXBoZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5ibG9ja1NpemUgPSAxMjggLyAzMjtcbiAgICB0aGlzLml2U2l6ZSA9IDY0IC8gMzI7XG4gIH1cblxuICBfZG9SZXNldCgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBLID0gdGhpcy5fa2V5LndvcmRzO1xuICAgIGNvbnN0IHtcbiAgICAgIGl2XG4gICAgfSA9IHRoaXMuY2ZnOyAvLyBHZW5lcmF0ZSBpbml0aWFsIHN0YXRlIHZhbHVlc1xuXG4gICAgdGhpcy5fWCA9IFtLWzBdLCBLWzNdIDw8IDE2IHwgS1syXSA+Pj4gMTYsIEtbMV0sIEtbMF0gPDwgMTYgfCBLWzNdID4+PiAxNiwgS1syXSwgS1sxXSA8PCAxNiB8IEtbMF0gPj4+IDE2LCBLWzNdLCBLWzJdIDw8IDE2IHwgS1sxXSA+Pj4gMTZdO1xuICAgIGNvbnN0IFggPSB0aGlzLl9YOyAvLyBHZW5lcmF0ZSBpbml0aWFsIGNvdW50ZXIgdmFsdWVzXG5cbiAgICB0aGlzLl9DID0gW0tbMl0gPDwgMTYgfCBLWzJdID4+PiAxNiwgS1swXSAmIDB4ZmZmZjAwMDAgfCBLWzFdICYgMHgwMDAwZmZmZiwgS1szXSA8PCAxNiB8IEtbM10gPj4+IDE2LCBLWzFdICYgMHhmZmZmMDAwMCB8IEtbMl0gJiAweDAwMDBmZmZmLCBLWzBdIDw8IDE2IHwgS1swXSA+Pj4gMTYsIEtbMl0gJiAweGZmZmYwMDAwIHwgS1szXSAmIDB4MDAwMGZmZmYsIEtbMV0gPDwgMTYgfCBLWzFdID4+PiAxNiwgS1szXSAmIDB4ZmZmZjAwMDAgfCBLWzBdICYgMHgwMDAwZmZmZl07XG4gICAgY29uc3QgQyA9IHRoaXMuX0M7IC8vIENhcnJ5IGJpdFxuXG4gICAgdGhpcy5fYiA9IDA7IC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgbmV4dFN0YXRlJDEuY2FsbCh0aGlzKTtcbiAgICB9IC8vIE1vZGlmeSB0aGUgY291bnRlcnNcblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgIENbaV0gXj0gWFtpICsgNCAmIDddO1xuICAgIH0gLy8gSVYgc2V0dXBcblxuXG4gICAgaWYgKGl2KSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIGNvbnN0IElWID0gaXYud29yZHM7XG4gICAgICBjb25zdCBJVl8wID0gSVZbMF07XG4gICAgICBjb25zdCBJVl8xID0gSVZbMV07IC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xuXG4gICAgICBjb25zdCBpMCA9IChJVl8wIDw8IDggfCBJVl8wID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKElWXzAgPDwgMjQgfCBJVl8wID4+PiA4KSAmIDB4ZmYwMGZmMDA7XG4gICAgICBjb25zdCBpMiA9IChJVl8xIDw8IDggfCBJVl8xID4+PiAyNCkgJiAweDAwZmYwMGZmIHwgKElWXzEgPDwgMjQgfCBJVl8xID4+PiA4KSAmIDB4ZmYwMGZmMDA7XG4gICAgICBjb25zdCBpMSA9IGkwID4+PiAxNiB8IGkyICYgMHhmZmZmMDAwMDtcbiAgICAgIGNvbnN0IGkzID0gaTIgPDwgMTYgfCBpMCAmIDB4MDAwMGZmZmY7IC8vIE1vZGlmeSBjb3VudGVyIHZhbHVlc1xuXG4gICAgICBDWzBdIF49IGkwO1xuICAgICAgQ1sxXSBePSBpMTtcbiAgICAgIENbMl0gXj0gaTI7XG4gICAgICBDWzNdIF49IGkzO1xuICAgICAgQ1s0XSBePSBpMDtcbiAgICAgIENbNV0gXj0gaTE7XG4gICAgICBDWzZdIF49IGkyO1xuICAgICAgQ1s3XSBePSBpMzsgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgbmV4dFN0YXRlJDEuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNOyAvLyBTaG9ydGN1dFxuXG4gICAgY29uc3QgWCA9IHRoaXMuX1g7IC8vIEl0ZXJhdGUgdGhlIHN5c3RlbVxuXG4gICAgbmV4dFN0YXRlJDEuY2FsbCh0aGlzKTsgLy8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcblxuICAgIFMkMVswXSA9IFhbMF0gXiBYWzVdID4+PiAxNiBeIFhbM10gPDwgMTY7XG4gICAgUyQxWzFdID0gWFsyXSBeIFhbN10gPj4+IDE2IF4gWFs1XSA8PCAxNjtcbiAgICBTJDFbMl0gPSBYWzRdIF4gWFsxXSA+Pj4gMTYgXiBYWzddIDw8IDE2O1xuICAgIFMkMVszXSA9IFhbNl0gXiBYWzNdID4+PiAxNiBeIFhbMV0gPDwgMTY7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgLy8gU3dhcCBlbmRpYW5cbiAgICAgIFMkMVtpXSA9IChTJDFbaV0gPDwgOCB8IFMkMVtpXSA+Pj4gMjQpICYgMHgwMGZmMDBmZiB8IChTJDFbaV0gPDwgMjQgfCBTJDFbaV0gPj4+IDgpICYgMHhmZjAwZmYwMDsgLy8gRW5jcnlwdFxuXG4gICAgICBfTVtvZmZzZXQgKyBpXSBePSBTJDFbaV07XG4gICAgfVxuICB9XG5cbn1cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5cblxuY29uc3QgUmFiYml0TGVnYWN5ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0TGVnYWN5QWxnbyk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtV29yZCgpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIGNvbnN0IFMgPSB0aGlzLl9TO1xuICBsZXQgaSA9IHRoaXMuX2k7XG4gIGxldCBqID0gdGhpcy5fajsgLy8gR2VuZXJhdGUga2V5c3RyZWFtIHdvcmRcblxuICBsZXQga2V5c3RyZWFtV29yZCA9IDA7XG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCA0OyBuICs9IDEpIHtcbiAgICBpID0gKGkgKyAxKSAlIDI1NjtcbiAgICBqID0gKGogKyBTW2ldKSAlIDI1NjsgLy8gU3dhcFxuXG4gICAgY29uc3QgdCA9IFNbaV07XG4gICAgU1tpXSA9IFNbal07XG4gICAgU1tqXSA9IHQ7XG4gICAga2V5c3RyZWFtV29yZCB8PSBTWyhTW2ldICsgU1tqXSkgJSAyNTZdIDw8IDI0IC0gbiAqIDg7XG4gIH0gLy8gVXBkYXRlIGNvdW50ZXJzXG5cblxuICB0aGlzLl9pID0gaTtcbiAgdGhpcy5faiA9IGo7XG4gIHJldHVybiBrZXlzdHJlYW1Xb3JkO1xufVxuLyoqXG4gKiBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG4gKi9cblxuXG5jbGFzcyBSQzRBbGdvIGV4dGVuZHMgU3RyZWFtQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMua2V5U2l6ZSA9IDI1NiAvIDMyO1xuICAgIHRoaXMuaXZTaXplID0gMDtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX2tleTtcbiAgICBjb25zdCBrZXlXb3JkcyA9IGtleS53b3JkcztcbiAgICBjb25zdCBrZXlTaWdCeXRlcyA9IGtleS5zaWdCeXRlczsgLy8gSW5pdCBzYm94XG5cbiAgICB0aGlzLl9TID0gW107XG4gICAgY29uc3QgUyA9IHRoaXMuX1M7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gICAgICBTW2ldID0gaTtcbiAgICB9IC8vIEtleSBzZXR1cFxuXG5cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCAyNTY7IGkgKz0gMSkge1xuICAgICAgY29uc3Qga2V5Qnl0ZUluZGV4ID0gaSAlIGtleVNpZ0J5dGVzO1xuICAgICAgY29uc3Qga2V5Qnl0ZSA9IGtleVdvcmRzW2tleUJ5dGVJbmRleCA+Pj4gMl0gPj4+IDI0IC0ga2V5Qnl0ZUluZGV4ICUgNCAqIDggJiAweGZmO1xuICAgICAgaiA9IChqICsgU1tpXSArIGtleUJ5dGUpICUgMjU2OyAvLyBTd2FwXG5cbiAgICAgIGNvbnN0IHQgPSBTW2ldO1xuICAgICAgU1tpXSA9IFNbal07XG4gICAgICBTW2pdID0gdDtcbiAgICB9IC8vIENvdW50ZXJzXG5cblxuICAgIHRoaXMuX2ogPSAwO1xuICAgIHRoaXMuX2kgPSB0aGlzLl9qO1xuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKE0sIG9mZnNldCkge1xuICAgIGNvbnN0IF9NID0gTTtcbiAgICBfTVtvZmZzZXRdIF49IGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xuICB9XG5cbn1cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5cblxuY29uc3QgUkM0ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0QWxnbyk7XG4vKipcbiAqIE1vZGlmaWVkIFJDNCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cbiAqL1xuXG5cbmNsYXNzIFJDNERyb3BBbGdvIGV4dGVuZHMgUkM0QWxnbyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJvcCBUaGUgbnVtYmVyIG9mIGtleXN0cmVhbSB3b3JkcyB0byBkcm9wLiBEZWZhdWx0IDE5MlxuICAgICAqL1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmNmZywge1xuICAgICAgZHJvcDogMTkyXG4gICAgfSk7XG4gIH1cblxuICBfZG9SZXNldCgpIHtcbiAgICBzdXBlci5fZG9SZXNldC5jYWxsKHRoaXMpOyAvLyBEcm9wXG5cblxuICAgIGZvciAobGV0IGkgPSB0aGlzLmNmZy5kcm9wOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICBnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxufVxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SQzREcm9wLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0RHJvcC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAqL1xuXG5cbmNvbnN0IFJDNERyb3AgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzREcm9wQWxnbyk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdCh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcikge1xuICBjb25zdCBfd29yZHMgPSB3b3JkcztcbiAgbGV0IGtleXN0cmVhbTsgLy8gU2hvcnRjdXRcblxuICBjb25zdCBpdiA9IHRoaXMuX2l2OyAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblxuICBpZiAoaXYpIHtcbiAgICBrZXlzdHJlYW0gPSBpdi5zbGljZSgwKTsgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXG4gICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAga2V5c3RyZWFtID0gdGhpcy5fcHJldkJsb2NrO1xuICB9XG5cbiAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApOyAvLyBFbmNyeXB0XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkgKz0gMSkge1xuICAgIF93b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG4gIH1cbn1cbi8qKlxuICogQ2lwaGVyIEZlZWRiYWNrIGJsb2NrIG1vZGUuXG4gKi9cblxuXG5jbGFzcyBDRkIgZXh0ZW5kcyBCbG9ja0NpcGhlck1vZGUge31cblxuQ0ZCLkVuY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgQ0ZCIHtcbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tTaXplXG4gICAgfSA9IGNpcGhlcjtcbiAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7IC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXG4gICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuICB9XG5cbn07XG5DRkIuRGVjcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBDRkIge1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja1NpemVcbiAgICB9ID0gY2lwaGVyOyAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblxuICAgIGNvbnN0IHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcbiAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7IC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblxuICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcbiAgfVxuXG59O1xuLyoqXG4gKiBDb3VudGVyIGJsb2NrIG1vZGUuXG4gKi9cblxuY2xhc3MgQ1RSIGV4dGVuZHMgQmxvY2tDaXBoZXJNb2RlIHt9XG5cbkNUUi5FbmNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIENUUiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgY29uc3QgX3dvcmRzID0gd29yZHM7IC8vIFNob3J0Y3V0c1xuXG4gICAgY29uc3QgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrU2l6ZVxuICAgIH0gPSBjaXBoZXI7XG4gICAgY29uc3QgaXYgPSB0aGlzLl9pdjtcbiAgICBsZXQgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7IC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXG4gICAgaWYgKGl2KSB7XG4gICAgICB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XG4gICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcjsgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXG4gICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xuICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTsgLy8gSW5jcmVtZW50IGNvdW50ZXJcblxuICAgIGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gPSBjb3VudGVyW2Jsb2NrU2l6ZSAtIDFdICsgMSB8IDA7IC8vIEVuY3J5cHRcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpICs9IDEpIHtcbiAgICAgIF93b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG4gICAgfVxuICB9XG5cbn07XG5DVFIuRGVjcnlwdG9yID0gQ1RSLkVuY3J5cHRvcjtcblxuY29uc3QgaW5jV29yZCA9IHdvcmQgPT4ge1xuICBsZXQgX3dvcmQgPSB3b3JkO1xuXG4gIGlmICgod29yZCA+PiAyNCAmIDB4ZmYpID09PSAweGZmKSB7XG4gICAgLy8gb3ZlcmZsb3dcbiAgICBsZXQgYjEgPSB3b3JkID4+IDE2ICYgMHhmZjtcbiAgICBsZXQgYjIgPSB3b3JkID4+IDggJiAweGZmO1xuICAgIGxldCBiMyA9IHdvcmQgJiAweGZmO1xuXG4gICAgaWYgKGIxID09PSAweGZmKSB7XG4gICAgICAvLyBvdmVyZmxvdyBiMVxuICAgICAgYjEgPSAwO1xuXG4gICAgICBpZiAoYjIgPT09IDB4ZmYpIHtcbiAgICAgICAgYjIgPSAwO1xuXG4gICAgICAgIGlmIChiMyA9PT0gMHhmZikge1xuICAgICAgICAgIGIzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiMyArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiMiArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiMSArPSAxO1xuICAgIH1cblxuICAgIF93b3JkID0gMDtcbiAgICBfd29yZCArPSBiMSA8PCAxNjtcbiAgICBfd29yZCArPSBiMiA8PCA4O1xuICAgIF93b3JkICs9IGIzO1xuICB9IGVsc2Uge1xuICAgIF93b3JkICs9IDB4MDEgPDwgMjQ7XG4gIH1cblxuICByZXR1cm4gX3dvcmQ7XG59O1xuXG5jb25zdCBpbmNDb3VudGVyID0gY291bnRlciA9PiB7XG4gIGNvbnN0IF9jb3VudGVyID0gY291bnRlcjtcbiAgX2NvdW50ZXJbMF0gPSBpbmNXb3JkKF9jb3VudGVyWzBdKTtcblxuICBpZiAoX2NvdW50ZXJbMF0gPT09IDApIHtcbiAgICAvLyBlbmNyX2RhdGEgaW4gZmlsZWVuYy5jIGZyb20gIERyIEJyaWFuIEdsYWRtYW4ncyBjb3VudHMgb25seSB3aXRoIERXT1JEIGogPCA4XG4gICAgX2NvdW50ZXJbMV0gPSBpbmNXb3JkKF9jb3VudGVyWzFdKTtcbiAgfVxuXG4gIHJldHVybiBfY291bnRlcjtcbn07XG4vKiogQHByZXNlcnZlXG4gKiBDb3VudGVyIGJsb2NrIG1vZGUgY29tcGF0aWJsZSB3aXRoICBEciBCcmlhbiBHbGFkbWFuIGZpbGVlbmMuY1xuICogZGVyaXZlZCBmcm9tIENyeXB0b0pTLm1vZGUuQ1RSXG4gKiBKYW4gSHJ1YnkgamhydWJ5LndlYkBnbWFpbC5jb21cbiAqL1xuXG5cbmNsYXNzIENUUkdsYWRtYW4gZXh0ZW5kcyBCbG9ja0NpcGhlck1vZGUge31cblxuQ1RSR2xhZG1hbi5FbmNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIENUUkdsYWRtYW4ge1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIGNvbnN0IF93b3JkcyA9IHdvcmRzOyAvLyBTaG9ydGN1dHNcblxuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7XG4gICAgICBibG9ja1NpemVcbiAgICB9ID0gY2lwaGVyO1xuICAgIGNvbnN0IGl2ID0gdGhpcy5faXY7XG4gICAgbGV0IGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyOyAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblxuICAgIGlmIChpdikge1xuICAgICAgdGhpcy5fY291bnRlciA9IGl2LnNsaWNlKDApO1xuICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7IC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcblxuICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaW5jQ291bnRlcihjb3VudGVyKTtcbiAgICBjb25zdCBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xuICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTsgLy8gRW5jcnlwdFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkgKz0gMSkge1xuICAgICAgX3dvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcbiAgICB9XG4gIH1cblxufTtcbkNUUkdsYWRtYW4uRGVjcnlwdG9yID0gQ1RSR2xhZG1hbi5FbmNyeXB0b3I7XG4vKipcbiAqIEVsZWN0cm9uaWMgQ29kZWJvb2sgYmxvY2sgbW9kZS5cbiAqL1xuXG5jbGFzcyBFQ0IgZXh0ZW5kcyBCbG9ja0NpcGhlck1vZGUge31cblxuRUNCLkVuY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgRUNCIHtcbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuICB9XG5cbn07XG5FQ0IuRGVjcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBFQ0Ige1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG4gIH1cblxufTtcbi8qKlxuICogT3V0cHV0IEZlZWRiYWNrIGJsb2NrIG1vZGUuXG4gKi9cblxuY2xhc3MgT0ZCIGV4dGVuZHMgQmxvY2tDaXBoZXJNb2RlIHt9XG5cbk9GQi5FbmNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIE9GQiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgY29uc3QgX3dvcmRzID0gd29yZHM7IC8vIFNob3J0Y3V0c1xuXG4gICAgY29uc3QgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrU2l6ZVxuICAgIH0gPSBjaXBoZXI7XG4gICAgY29uc3QgaXYgPSB0aGlzLl9pdjtcbiAgICBsZXQga2V5c3RyZWFtID0gdGhpcy5fa2V5c3RyZWFtOyAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblxuICAgIGlmIChpdikge1xuICAgICAgdGhpcy5fa2V5c3RyZWFtID0gaXYuc2xpY2UoMCk7XG4gICAgICBrZXlzdHJlYW0gPSB0aGlzLl9rZXlzdHJlYW07IC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcblxuICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApOyAvLyBFbmNyeXB0XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSArPSAxKSB7XG4gICAgICBfd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuICAgIH1cbiAgfVxuXG59O1xuT0ZCLkRlY3J5cHRvciA9IE9GQi5FbmNyeXB0b3I7XG4vKipcbiAqIEFOU0kgWC45MjMgcGFkZGluZyBzdHJhdGVneS5cbiAqL1xuXG5jb25zdCBBbnNpWDkyMyA9IHtcbiAgcGFkKGRhdGEsIGJsb2NrU2l6ZSkge1xuICAgIGNvbnN0IF9kYXRhID0gZGF0YTsgLy8gU2hvcnRjdXRzXG5cbiAgICBjb25zdCBkYXRhU2lnQnl0ZXMgPSBfZGF0YS5zaWdCeXRlcztcbiAgICBjb25zdCBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7IC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblxuICAgIGNvbnN0IG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGFTaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzOyAvLyBDb21wdXRlIGxhc3QgYnl0ZSBwb3NpdGlvblxuXG4gICAgY29uc3QgbGFzdEJ5dGVQb3MgPSBkYXRhU2lnQnl0ZXMgKyBuUGFkZGluZ0J5dGVzIC0gMTsgLy8gUGFkXG5cbiAgICBfZGF0YS5jbGFtcCgpO1xuXG4gICAgX2RhdGEud29yZHNbbGFzdEJ5dGVQb3MgPj4+IDJdIHw9IG5QYWRkaW5nQnl0ZXMgPDwgMjQgLSBsYXN0Qnl0ZVBvcyAlIDQgKiA4O1xuICAgIF9kYXRhLnNpZ0J5dGVzICs9IG5QYWRkaW5nQnl0ZXM7XG4gIH0sXG5cbiAgdW5wYWQoZGF0YSkge1xuICAgIGNvbnN0IF9kYXRhID0gZGF0YTsgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gX2RhdGEud29yZHNbX2RhdGEuc2lnQnl0ZXMgLSAxID4+PiAyXSAmIDB4ZmY7IC8vIFJlbW92ZSBwYWRkaW5nXG5cbiAgICBfZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuICB9XG5cbn07XG4vKipcbiAqIElTTyAxMDEyNiBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5cbmNvbnN0IElzbzEwMTI2ID0ge1xuICBwYWQoZGF0YSwgYmxvY2tTaXplKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7IC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblxuICAgIGNvbnN0IG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlczsgLy8gUGFkXG5cbiAgICBkYXRhLmNvbmNhdChXb3JkQXJyYXkucmFuZG9tKG5QYWRkaW5nQnl0ZXMgLSAxKSkuY29uY2F0KFdvcmRBcnJheS5jcmVhdGUoW25QYWRkaW5nQnl0ZXMgPDwgMjRdLCAxKSk7XG4gIH0sXG5cbiAgdW5wYWQoZGF0YSkge1xuICAgIGNvbnN0IF9kYXRhID0gZGF0YTsgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gX2RhdGEud29yZHNbX2RhdGEuc2lnQnl0ZXMgLSAxID4+PiAyXSAmIDB4ZmY7IC8vIFJlbW92ZSBwYWRkaW5nXG5cbiAgICBfZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuICB9XG5cbn07XG4vKipcbiAqIFplcm8gcGFkZGluZyBzdHJhdGVneS5cbiAqL1xuXG5jb25zdCBaZXJvUGFkZGluZyA9IHtcbiAgcGFkKGRhdGEsIGJsb2NrU2l6ZSkge1xuICAgIGNvbnN0IF9kYXRhID0gZGF0YTsgLy8gU2hvcnRjdXRcblxuICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDsgLy8gUGFkXG5cbiAgICBfZGF0YS5jbGFtcCgpO1xuXG4gICAgX2RhdGEuc2lnQnl0ZXMgKz0gYmxvY2tTaXplQnl0ZXMgLSAoZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzIHx8IGJsb2NrU2l6ZUJ5dGVzKTtcbiAgfSxcblxuICB1bnBhZChkYXRhKSB7XG4gICAgY29uc3QgX2RhdGEgPSBkYXRhOyAvLyBTaG9ydGN1dFxuXG4gICAgY29uc3QgZGF0YVdvcmRzID0gX2RhdGEud29yZHM7IC8vIFVucGFkXG5cbiAgICBmb3IgKGxldCBpID0gX2RhdGEuc2lnQnl0ZXMgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGRhdGFXb3Jkc1tpID4+PiAyXSA+Pj4gMjQgLSBpICUgNCAqIDggJiAweGZmKSB7XG4gICAgICAgIF9kYXRhLnNpZ0J5dGVzID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuLyoqXG4gKiBJU08vSUVDIDk3OTctMSBQYWRkaW5nIE1ldGhvZCAyLlxuICovXG5cbmNvbnN0IElzbzk3OTcxID0ge1xuICBwYWQoZGF0YSwgYmxvY2tTaXplKSB7XG4gICAgLy8gQWRkIDB4ODAgYnl0ZVxuICAgIGRhdGEuY29uY2F0KFdvcmRBcnJheS5jcmVhdGUoWzB4ODAwMDAwMDBdLCAxKSk7IC8vIFplcm8gcGFkIHRoZSByZXN0XG5cbiAgICBaZXJvUGFkZGluZy5wYWQoZGF0YSwgYmxvY2tTaXplKTtcbiAgfSxcblxuICB1bnBhZChkYXRhKSB7XG4gICAgY29uc3QgX2RhdGEgPSBkYXRhOyAvLyBSZW1vdmUgemVybyBwYWRkaW5nXG5cbiAgICBaZXJvUGFkZGluZy51bnBhZChfZGF0YSk7IC8vIFJlbW92ZSBvbmUgbW9yZSBieXRlIC0tIHRoZSAweDgwIGJ5dGVcblxuICAgIF9kYXRhLnNpZ0J5dGVzIC09IDE7XG4gIH1cblxufTtcbi8qKlxuICogQSBub29wIHBhZGRpbmcgc3RyYXRlZ3kuXG4gKi9cblxuY29uc3QgTm9QYWRkaW5nID0ge1xuICBwYWQoKSB7fSxcblxuICB1bnBhZCgpIHt9XG5cbn07XG5jb25zdCBIZXhGb3JtYXR0ZXIgPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgY2lwaGVydGV4dCBvZiBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuICAgKi9cbiAgc3RyaW5naWZ5KGNpcGhlclBhcmFtcykge1xuICAgIHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gSGV4LnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG4gICAgICBjaXBoZXJ0ZXh0XG4gICAgfSk7XG4gIH1cblxufTtcbnZhciBDcnlwdG9FcyA9IHtcbiAgbGliOiB7XG4gICAgQmFzZSxcbiAgICBXb3JkQXJyYXksXG4gICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSxcbiAgICBIYXNoZXIsXG4gICAgQ2lwaGVyLFxuICAgIFN0cmVhbUNpcGhlcixcbiAgICBCbG9ja0NpcGhlck1vZGUsXG4gICAgQmxvY2tDaXBoZXIsXG4gICAgQ2lwaGVyUGFyYW1zLFxuICAgIFNlcmlhbGl6YWJsZUNpcGhlcixcbiAgICBQYXNzd29yZEJhc2VkQ2lwaGVyXG4gIH0sXG4gIHg2NDoge1xuICAgIFdvcmQ6IFg2NFdvcmQsXG4gICAgV29yZEFycmF5OiBYNjRXb3JkQXJyYXlcbiAgfSxcbiAgZW5jOiB7XG4gICAgSGV4LFxuICAgIExhdGluMSxcbiAgICBVdGY4LFxuICAgIFV0ZjE2LFxuICAgIFV0ZjE2QkUsXG4gICAgVXRmMTZMRSxcbiAgICBCYXNlNjRcbiAgfSxcbiAgYWxnbzoge1xuICAgIEhNQUMsXG4gICAgTUQ1OiBNRDVBbGdvLFxuICAgIFNIQTE6IFNIQTFBbGdvLFxuICAgIFNIQTIyNDogU0hBMjI0QWxnbyxcbiAgICBTSEEyNTY6IFNIQTI1NkFsZ28sXG4gICAgU0hBMzg0OiBTSEEzODRBbGdvLFxuICAgIFNIQTUxMjogU0hBNTEyQWxnbyxcbiAgICBTSEEzOiBTSEEzQWxnbyxcbiAgICBSSVBFTUQxNjA6IFJJUEVNRDE2MEFsZ28sXG4gICAgUEJLREYyOiBQQktERjJBbGdvLFxuICAgIEV2cEtERjogRXZwS0RGQWxnbyxcbiAgICBBRVM6IEFFU0FsZ28sXG4gICAgREVTOiBERVNBbGdvLFxuICAgIFRyaXBsZURFUzogVHJpcGxlREVTQWxnbyxcbiAgICBSYWJiaXQ6IFJhYmJpdEFsZ28sXG4gICAgUmFiYml0TGVnYWN5OiBSYWJiaXRMZWdhY3lBbGdvLFxuICAgIFJDNDogUkM0QWxnbyxcbiAgICBSQzREcm9wOiBSQzREcm9wQWxnb1xuICB9LFxuICBtb2RlOiB7XG4gICAgQ0JDLFxuICAgIENGQixcbiAgICBDVFIsXG4gICAgQ1RSR2xhZG1hbixcbiAgICBFQ0IsXG4gICAgT0ZCXG4gIH0sXG4gIHBhZDoge1xuICAgIFBrY3M3LFxuICAgIEFuc2lYOTIzLFxuICAgIElzbzEwMTI2LFxuICAgIElzbzk3OTcxLFxuICAgIE5vUGFkZGluZyxcbiAgICBaZXJvUGFkZGluZ1xuICB9LFxuICBmb3JtYXQ6IHtcbiAgICBPcGVuU1NMOiBPcGVuU1NMRm9ybWF0dGVyLFxuICAgIEhleDogSGV4Rm9ybWF0dGVyXG4gIH0sXG4gIGtkZjoge1xuICAgIE9wZW5TU0w6IE9wZW5TU0xLZGZcbiAgfSxcbiAgTUQ1LFxuICBIbWFjTUQ1LFxuICBTSEExLFxuICBIbWFjU0hBMSxcbiAgU0hBMjI0LFxuICBIbWFjU0hBMjI0LFxuICBTSEEyNTYsXG4gIEhtYWNTSEEyNTYsXG4gIFNIQTM4NCxcbiAgSG1hY1NIQTM4NCxcbiAgU0hBNTEyLFxuICBIbWFjU0hBNTEyLFxuICBTSEEzLFxuICBIbWFjU0hBMyxcbiAgUklQRU1EMTYwLFxuICBIbWFjUklQRU1EMTYwLFxuICBQQktERjIsXG4gIEV2cEtERixcbiAgQUVTLFxuICBERVMsXG4gIFRyaXBsZURFUyxcbiAgUmFiYml0LFxuICBSYWJiaXRMZWdhY3ksXG4gIFJDNCxcbiAgUkM0RHJvcFxufTtcblxuZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBsaXN0ZW5lcnM6IHt9LFxuICAgIG9uOiBmdW5jdGlvbiAoZXZlbnRDb2RlLCBsaXN0ZW5lcikge1xuICAgICAgLy8gY2hlY2sgaWYgdmFsaWQgZXZlbnRDb2RlXG4gICAgICBzd2l0Y2ggKGV2ZW50Q29kZSkge1xuICAgICAgICBjYXNlICd0eFNlbnQnOlxuICAgICAgICBjYXNlICd0eFBvb2wnOlxuICAgICAgICBjYXNlICd0eENvbmZpcm1lZCc6XG4gICAgICAgIGNhc2UgJ3R4U3BlZWRVcCc6XG4gICAgICAgIGNhc2UgJ3R4Q2FuY2VsJzpcbiAgICAgICAgY2FzZSAndHhGYWlsZWQnOlxuICAgICAgICBjYXNlICd0eERyb3BwZWQnOlxuICAgICAgICBjYXNlICd0eFJlcXVlc3QnOlxuICAgICAgICBjYXNlICduc2ZGYWlsJzpcbiAgICAgICAgY2FzZSAndHhSZXBlYXQnOlxuICAgICAgICBjYXNlICd0eEF3YWl0aW5nQXBwcm92YWwnOlxuICAgICAgICBjYXNlICd0eENvbmZpcm1SZW1pbmRlcic6XG4gICAgICAgIGNhc2UgJ3R4U2VuZEZhaWwnOlxuICAgICAgICBjYXNlICd0eEVycm9yJzpcbiAgICAgICAgY2FzZSAndHhVbmRlclByaWNlZCc6XG4gICAgICAgIGNhc2UgJ3R4UG9vbFNpbXVsYXRpb24nOlxuICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2V2ZW50Q29kZX0gaXMgbm90IGEgdmFsaWQgZXZlbnQgY29kZSwgZm9yIGEgbGlzdCBvZiB2YWxpZCBldmVudCBjb2RlcyBzZWU6IGh0dHBzOi8vZG9jcy5ibG9ja25hdGl2ZS5jb20vbm90aWZ5LXNkayNldmVudC1jb2Rlc2ApO1xuICAgICAgfSAvLyBjaGVjayB0aGF0IGxpc3RlbmVyIGlzIGEgZnVuY3Rpb25cblxuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB9IC8vIGFkZCBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50Q29kZVxuXG5cbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50Q29kZV0gPSBsaXN0ZW5lcjtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50Q29kZSkge1xuICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2V2ZW50Q29kZV07XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1tzdGF0ZS5ldmVudENvZGVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyc1tzdGF0ZS5ldmVudENvZGVdKHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmFsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuYWxsKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtOYW1lKGJsb2NrY2hhaW4sIGlkKSB7XG4gIHJldHVybiBuZXR3b3Jrc1tibG9ja2NoYWluXVtpZF07XG59XG5cbmZ1bmN0aW9uIHNlcnZlckVjaG8oZXZlbnRDb2RlKSB7XG4gIHN3aXRjaCAoZXZlbnRDb2RlKSB7XG4gICAgY2FzZSAndHhSZXF1ZXN0JzpcbiAgICBjYXNlICduc2ZGYWlsJzpcbiAgICBjYXNlICd0eFJlcGVhdCc6XG4gICAgY2FzZSAndHhBd2FpdGluZ0FwcHJvdmFsJzpcbiAgICBjYXNlICd0eENvbmZpcm1SZW1pbmRlcic6XG4gICAgY2FzZSAndHhTZW5kRmFpbCc6XG4gICAgY2FzZSAndHhFcnJvcic6XG4gICAgY2FzZSAndHhVbmRlclByaWNlZCc6XG4gICAgY2FzZSAndHhTZW50JzpcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXN0KGFycikge1xuICByZXR1cm4gYXJyLnJldmVyc2UoKVswXTtcbn0gLy8gaXNBZGRyZXNzIGFuZCBpc1R4aWQgYXJlIG5vdCBtZWFudCB0byBwZXJmb3JtIHJlYWwgdmFsaWRhdGlvbixcbi8vIGp1c3QgbmVlZHMgdG8gd29yayBvdXQgaWYgaXQgaXMgYW4gYWRkcmVzcyBvciBhIHRyYW5zYWN0aW9uIGlkXG4vLyB0aGUgc2VydmVyIHdpbGwgZG8gbW9yZSB0aG9yb3VnaCB2YWxpZGF0aW9uXG5cblxuZnVuY3Rpb24gaXNBZGRyZXNzKGJsb2NrY2hhaW4sIGFkZHJlc3NPckhhc2gpIHtcbiAgc3dpdGNoIChibG9ja2NoYWluKSB7XG4gICAgY2FzZSAnZXRoZXJldW0nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoID09PSA0MjtcblxuICAgIGNhc2UgJ2JpdGNvaW4nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoICE9PSA2NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUeGlkKGJsb2NrY2hhaW4sIGFkZHJlc3NPckhhc2gpIHtcbiAgc3dpdGNoIChibG9ja2NoYWluKSB7XG4gICAgY2FzZSAnZXRoZXJldW0nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoID09PSA2NjtcblxuICAgIGNhc2UgJ2JpdGNvaW4nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoID09PSA2NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FpdCh0aW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpO1xuICB9KTtcbn1cblxuY29uc3QganNvblByZXNlcnZlVW5kZWZpbmVkID0gKGssIHYpID0+IHYgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogdjtcbi8qKlxyXG4gKiBUZXN0cyBpZiBMb2NhbFN0b3JhZ2UgbWF5IGJlIHVzZWQuIEFjY291bnRzIGZvciBlbnZpcm9ubWVudHMgd2hlcmVcclxuICogTG9jYWxTdG9yYWdlIGlzIG5vdCBzdXBwb3J0ZWQsIGFzIHdlbGwgYXMgdGhvc2Ugd2hlcmUgaXQgaXMgYmxvY2tlZC5cclxuICpcclxuICogQHJldHVybnMgYHRydWVgIGlmIExvY2FsU3RvcmFnZSBpcyBzdXBwb3J0ZWQgYW5kIGFjY2Vzc2libGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpIHtcbiAgY29uc3QgaXNTdXBwb3J0ZWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3c7XG5cbiAgaWYgKGlzU3VwcG9ydGVkKSB7XG4gICAgY29uc3QgdGVzdEtleSA9ICdfX3Rlc3RMb2NhbFN0b3JhZ2UnO1xuXG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0S2V5LCAnMScpO1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cmFuc2FjdGlvbihoYXNoLCBpZCkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTsgLy8gY3JlYXRlIHN0YXJ0VGltZSBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpOyAvLyBjcmVhdGUgZW1pdHRlciBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBlbWl0dGVyID0gY3JlYXRlRW1pdHRlcigpOyAvLyBjcmVhdGUgZXZlbnRDb2RlIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IGV2ZW50Q29kZSA9ICd0eFNlbnQnOyAvLyBwdXQgaW4gcXVldWVcblxuICB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMucHVzaCh7XG4gICAgaGFzaCxcbiAgICBlbWl0dGVyXG4gIH0pO1xuICBjb25zdCB0cmFuc2FjdGlvbklkID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8ge1xuICAgIGhhc2hcbiAgfSA6IHtcbiAgICB0eGlkOiBoYXNoXG4gIH07XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0geyAuLi50cmFuc2FjdGlvbklkLFxuICAgIGlkOiBpZCB8fCBoYXNoLFxuICAgIHN0YXJ0VGltZSxcbiAgICBzdGF0dXM6ICdzZW50J1xuICB9O1xuICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4udHJhbnNhY3Rpb24sXG4gICAgZXZlbnRDb2RlXG4gIH07IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG4gIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICBldmVudENvZGUsXG4gICAgY2F0ZWdvcnlDb2RlOiAnYWN0aXZlVHJhbnNhY3Rpb24nLFxuICAgIHRyYW5zYWN0aW9uXG4gIH0pO1xuXG4gIGNvbnN0IHRyYW5zYWN0aW9uT2JqID0ge1xuICAgIGRldGFpbHM6IG5ld1N0YXRlLFxuICAgIGVtaXR0ZXJcbiAgfTtcblxuICBmdW5jdGlvbiBlbWl0U3RhdGUoKSB7XG4gICAgY29uc3QgZW1pdHRlclJlc3VsdCA9IGVtaXR0ZXIuZW1pdChuZXdTdGF0ZSk7XG5cbiAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKHtcbiAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgIGVtaXR0ZXJSZXN1bHRcbiAgICB9KSk7XG4gIH0gLy8gZW1pdCBhZnRlciBkZWxheSB0byBhbGxvdyBmb3IgbGlzdGVuZXIgdG8gYmUgcmVnaXN0ZXJlZFxuXG5cbiAgc2V0VGltZW91dChlbWl0U3RhdGUuYmluZCh0aGlzKSwgNSk7XG4gIHJldHVybiB0cmFuc2FjdGlvbk9iajtcbn1cblxuZnVuY3Rpb24gYWNjb3VudChhZGRyZXNzKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpOyAvLyBsb3dlcmNhc2UgdGhlIGFkZHJlc3MgaWYgRXRoZXJldW1cblxuICBhZGRyZXNzID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gYWRkcmVzcy50b0xvd2VyQ2FzZSgpIDogYWRkcmVzczsgLy8gY3JlYXRlIGVtaXR0ZXIgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZW1pdHRlciA9IGNyZWF0ZUVtaXR0ZXIoKTsgLy8gY3JlYXRlIGV2ZW50Q29kZSBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBldmVudENvZGUgPSAnd2F0Y2gnO1xuICBjb25zdCBleGlzdGluZ0FkZHJlc3NXYXRjaGVyID0gdGhpcy53YXRjaGVkQWNjb3VudHMuZmluZChhYyA9PiBhYy5hZGRyZXNzID09PSBhZGRyZXNzKTtcblxuICBpZiAoZXhpc3RpbmdBZGRyZXNzV2F0Y2hlcikge1xuICAgIC8vIGFkZCB0byBleGlzdGluZyBlbWl0dGVycyBhcnJheVxuICAgIGV4aXN0aW5nQWRkcmVzc1dhdGNoZXIuZW1pdHRlcnMucHVzaChlbWl0dGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwdXQgaW4gYWNjb3VudHMgcXVldWVcbiAgICB0aGlzLndhdGNoZWRBY2NvdW50cy5wdXNoKHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBlbWl0dGVyczogW2VtaXR0ZXJdXG4gICAgfSk7XG4gIH0gLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cblxuICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgZXZlbnRDb2RlLFxuICAgIGNhdGVnb3J5Q29kZTogJ2FjY291bnRBZGRyZXNzJyxcbiAgICBhY2NvdW50OiB7XG4gICAgICBhZGRyZXNzXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGVtaXR0ZXIsXG4gICAgZGV0YWlsczoge1xuICAgICAgYWRkcmVzc1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZlbnQoZXZlbnRPYmopIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgV2ViU29ja2V0IGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCwgcmUtaW5pdGlhbGl6ZSB0byBjb250aW51ZSBtYWtpbmcgcmVxdWVzdHMuJyk7XG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2UoZXZlbnRPYmopO1xufVxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cblxuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24kMSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzID0gZmFsc2U7XG52YXIgY29uZmlnID0ge1xuICBQcm9taXNlOiB1bmRlZmluZWQsXG5cbiAgc2V0IHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhciBlcnJvciA9IC8qQF9fUFVSRV9fKi9uZXcgRXJyb3IoKTtcbiAgICAgIC8qQF9fUFVSRV9fKi9cblxuICAgICAgY29uc29sZS53YXJuKCdERVBSRUNBVEVEISBSeEpTIHdhcyBzZXQgdG8gdXNlIGRlcHJlY2F0ZWQgc3luY2hyb25vdXMgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IgYnkgY29kZSBhdDogXFxuJyArIGVycm9yLnN0YWNrKTtcbiAgICB9XG5cbiAgICBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3MgPSB2YWx1ZTtcbiAgfSxcblxuICBnZXQgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZygpIHtcbiAgICByZXR1cm4gX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzO1xuICB9XG5cbn07XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cbmZ1bmN0aW9uIGhvc3RSZXBvcnRFcnJvcihlcnIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9LCAwKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX2NvbmZpZyxfdXRpbF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBlbXB0eSA9IHtcbiAgY2xvc2VkOiB0cnVlLFxuICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHt9LFxuICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICB9XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fVxufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIGlzQXJyYXkkMSA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJztcbiAgfTtcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCQxKHgpIHtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbCA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsKGVycm9ycykge1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3JzID8gZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuXCIgKyBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHtcbiAgICAgIHJldHVybiBpICsgMSArIFwiKSBcIiArIGVyci50b1N0cmluZygpO1xuICAgIH0pLmpvaW4oJ1xcbiAgJykgOiAnJztcbiAgICB0aGlzLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICByZXR1cm4gVW5zdWJzY3JpcHRpb25FcnJvckltcGw7XG59KCk7XG5cbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yID0gVW5zdWJzY3JpcHRpb25FcnJvckltcGw7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF91dGlsX2lzQXJyYXksX3V0aWxfaXNPYmplY3QsX3V0aWxfaXNGdW5jdGlvbixfdXRpbF9VbnN1YnNjcmlwdGlvbkVycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIFN1YnNjcmlwdGlvbiA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkge1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyZW50T3JQYXJlbnRzID0gbnVsbDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcblxuICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy5fY3RvclVuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG4gICAgfVxuICB9XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXJyb3JzO1xuXG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hID0gdGhpcyxcbiAgICAgICAgX3BhcmVudE9yUGFyZW50cyA9IF9hLl9wYXJlbnRPclBhcmVudHMsXG4gICAgICAgIF9jdG9yVW5zdWJzY3JpYmUgPSBfYS5fY3RvclVuc3Vic2NyaWJlLFxuICAgICAgICBfdW5zdWJzY3JpYmUgPSBfYS5fdW5zdWJzY3JpYmUsXG4gICAgICAgIF9zdWJzY3JpcHRpb25zID0gX2EuX3N1YnNjcmlwdGlvbnM7XG5cbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5fcGFyZW50T3JQYXJlbnRzID0gbnVsbDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcblxuICAgIGlmIChfcGFyZW50T3JQYXJlbnRzIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XG4gICAgICBfcGFyZW50T3JQYXJlbnRzLnJlbW92ZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKF9wYXJlbnRPclBhcmVudHMgIT09IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBfcGFyZW50T3JQYXJlbnRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICB2YXIgcGFyZW50XzEgPSBfcGFyZW50T3JQYXJlbnRzW2luZGV4XTtcbiAgICAgICAgcGFyZW50XzEucmVtb3ZlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uJDEoX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgaWYgKF9jdG9yVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIF91bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcnMgPSBlIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/IGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlLmVycm9ycykgOiBbZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcblxuICAgICAgICBpZiAoaXNPYmplY3QkMShzdWIpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGUuZXJyb3JzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXJyb3JzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0ZWFyZG93bjtcblxuICAgIGlmICghdGVhcmRvd24pIHtcbiAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YgdGVhcmRvd24pIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gPT09IHRoaXMgfHwgc3Vic2NyaXB0aW9uLmNsb3NlZCB8fCB0eXBlb2Ygc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIShzdWJzY3JpcHRpb24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgdmFyIHRtcCA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLl9zdWJzY3JpcHRpb25zID0gW3RtcF07XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHRlYXJkb3duICcgKyB0ZWFyZG93biArICcgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9wYXJlbnRPclBhcmVudHMgPSBzdWJzY3JpcHRpb24uX3BhcmVudE9yUGFyZW50cztcblxuICAgIGlmIChfcGFyZW50T3JQYXJlbnRzID09PSBudWxsKSB7XG4gICAgICBzdWJzY3JpcHRpb24uX3BhcmVudE9yUGFyZW50cyA9IHRoaXM7XG4gICAgfSBlbHNlIGlmIChfcGFyZW50T3JQYXJlbnRzIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XG4gICAgICBpZiAoX3BhcmVudE9yUGFyZW50cyA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgfVxuXG4gICAgICBzdWJzY3JpcHRpb24uX3BhcmVudE9yUGFyZW50cyA9IFtfcGFyZW50T3JQYXJlbnRzLCB0aGlzXTtcbiAgICB9IGVsc2UgaWYgKF9wYXJlbnRPclBhcmVudHMuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgICAgIF9wYXJlbnRPclBhcmVudHMucHVzaCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG5cbiAgICBpZiAoc3Vic2NyaXB0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtzdWJzY3JpcHRpb25dO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcblxuICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcblxuICAgICAgaWYgKHN1YnNjcmlwdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5FTVBUWSA9IGZ1bmN0aW9uIChlbXB0eSkge1xuICAgIGVtcHR5LmNsb3NlZCA9IHRydWU7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9KG5ldyBTdWJzY3JpcHRpb24oKSk7XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKTtcblxuZnVuY3Rpb24gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9ycykge1xuICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7XG4gICAgcmV0dXJuIGVycnMuY29uY2F0KGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3IgPyBlcnIuZXJyb3JzIDogZXJyKTtcbiAgfSwgW10pO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciByeFN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyA/IC8qQF9fUFVSRV9fKi9TeW1ib2woJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyXycgKyAvKkBfX1BVUkVfXyovTWF0aC5yYW5kb20oKTtcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX3V0aWxfaXNGdW5jdGlvbixfT2JzZXJ2ZXIsX1N1YnNjcmlwdGlvbixfaW50ZXJuYWxfc3ltYm9sX3J4U3Vic2NyaWJlcixfY29uZmlnLF91dGlsX2hvc3RSZXBvcnRFcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgIF90aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgIF90aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZW1wdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmICghZGVzdGluYXRpb25Pck5leHQpIHtcbiAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGVtcHR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck5leHQgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBkZXN0aW5hdGlvbk9yTmV4dC5zeW5jRXJyb3JUaHJvd2FibGU7XG4gICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgZGVzdGluYXRpb25Pck5leHQuYWRkKF90aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKF90aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIoX3RoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHZhciBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXIobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblxuICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3BhcmVudE9yUGFyZW50cyA9IHRoaXMuX3BhcmVudE9yUGFyZW50cztcbiAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyZW50T3JQYXJlbnRzID0gX3BhcmVudE9yUGFyZW50cztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uKTtcblxudmFyIFNhZmVTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnRTdWJzY3JpYmVyLCBvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gX3BhcmVudFN1YnNjcmliZXI7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIGNvbnRleHQgPSBfdGhpcztcblxuICAgIGlmIChpc0Z1bmN0aW9uJDEob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgfSBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcblxuICAgICAgaWYgKG9ic2VydmVyT3JOZXh0ICE9PSBlbXB0eSkge1xuICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24kMShjb250ZXh0LnVuc3Vic2NyaWJlKSkge1xuICAgICAgICAgIF90aGlzLmFkZChjb250ZXh0LnVuc3Vic2NyaWJlLmJpbmQoY29udGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC51bnN1YnNjcmliZSA9IF90aGlzLnVuc3Vic2NyaWJlLmJpbmQoX3RoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICBfdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgX3RoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgX3RoaXMuX2NvbXBsZXRlID0gY29tcGxldGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG5cbiAgICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgIHZhciB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nID0gY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmc7XG5cbiAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICBpZiAoIXVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuXG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9lcnJvciwgZXJyKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcblxuICAgICAgICBpZiAodXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICBfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICBfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG5cbiAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICB2YXIgd3JhcHBlZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGxldGUuY2FsbChfdGhpcy5fY29udGV4dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyB8fCAhX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIod3JhcHBlZENvbXBsZXRlKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgd3JhcHBlZENvbXBsZXRlKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclVuc3ViID0gZnVuY3Rpb24gKGZuLCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcblxuICAgICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgaWYgKCFjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY2FsbCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICBwYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvc3RSZXBvcnRFcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuXG4gICAgX3BhcmVudFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gY2FuUmVwb3J0RXJyb3Iob2JzZXJ2ZXIpIHtcbiAgd2hpbGUgKG9ic2VydmVyKSB7XG4gICAgdmFyIF9hID0gb2JzZXJ2ZXIsXG4gICAgICAgIGNsb3NlZF8xID0gX2EuY2xvc2VkLFxuICAgICAgICBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uLFxuICAgICAgICBpc1N0b3BwZWQgPSBfYS5pc1N0b3BwZWQ7XG5cbiAgICBpZiAoY2xvc2VkXzEgfHwgaXNTdG9wcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgIG9ic2VydmVyID0gZGVzdGluYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX1N1YnNjcmliZXIsX3N5bWJvbF9yeFN1YnNjcmliZXIsX09ic2VydmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl0pIHtcbiAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJdKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFuZXh0T3JPYnNlcnZlciAmJiAhZXJyb3IgJiYgIWNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyKGVtcHR5KTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgb2JzZXJ2YWJsZSA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSgpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9pZGVudGl0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gcGlwZUZyb21BcnJheShmbnMpIHtcbiAgaWYgKGZucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cblxuICBpZiAoZm5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmbnNbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGlwZWQoaW5wdXQpIHtcbiAgICByZXR1cm4gZm5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZm4pIHtcbiAgICAgIHJldHVybiBmbihwcmV2KTtcbiAgICB9LCBpbnB1dCk7XG4gIH07XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF91dGlsX2NhblJlcG9ydEVycm9yLF91dGlsX3RvU3Vic2NyaWJlcixfc3ltYm9sX29ic2VydmFibGUsX3V0aWxfcGlwZSxfY29uZmlnIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgT2JzZXJ2YWJsZSA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcblxuICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICB9XG4gIH1cblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgIHZhciBzaW5rID0gdG9TdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuXG4gICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICBzaW5rLmFkZChvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpbmsuYWRkKHRoaXMuc291cmNlIHx8IGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nICYmICFzaW5rLnN5bmNFcnJvclRocm93YWJsZSA/IHRoaXMuX3N1YnNjcmliZShzaW5rKSA6IHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbms7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoc2luayk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuUmVwb3J0RXJyb3Ioc2luaykpIHtcbiAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgcHJvbWlzZUN0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcHJvbWlzZUN0b3IgPSBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcik7XG4gICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcblxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlW29ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBvcGVyYXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gcGlwZUZyb21BcnJheShvcGVyYXRpb25zKSh0aGlzKTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS50b1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZUN0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcHJvbWlzZUN0b3IgPSBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcik7XG4gICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPSB4O1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlO1xufSgpO1xuXG5mdW5jdGlvbiBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcikge1xuICBpZiAoIXByb21pc2VDdG9yKSB7XG4gICAgcHJvbWlzZUN0b3IgPSBQcm9taXNlO1xuICB9XG5cbiAgaWYgKCFwcm9taXNlQ3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZUN0b3I7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIHN1YnNjcmliZVRvQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbiAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2ldKTtcbiAgICB9XG5cbiAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfaG9zdFJlcG9ydEVycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgc3Vic2NyaWJlVG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICB9KS50aGVuKG51bGwsIGhvc3RSZXBvcnRFcnJvcik7XG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCAhU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgfVxuXG4gIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG59XG5cbnZhciBpdGVyYXRvciA9IC8qQF9fUFVSRV9fKi9nZXRTeW1ib2xJdGVyYXRvcigpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX2l0ZXJhdG9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIHN1YnNjcmliZVRvSXRlcmFibGUgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIGl0ZXJhdG9yJDEgPSBpdGVyYWJsZVtpdGVyYXRvcl0oKTtcblxuICAgIGRvIHtcbiAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpdGVtID0gaXRlcmF0b3IkMS5uZXh0KCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW0uZG9uZSkge1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdWJzY3JpYmVyLm5leHQoaXRlbS52YWx1ZSk7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3IkMS5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN1YnNjcmliZXIuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yJDEucmV0dXJuKSB7XG4gICAgICAgICAgaXRlcmF0b3IkMS5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX29ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBzdWJzY3JpYmVUb09ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHZhciBvYnMgPSBvYmpbb2JzZXJ2YWJsZV0oKTtcblxuICAgIGlmICh0eXBlb2Ygb2JzLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfVxuICB9O1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgaXNBcnJheUxpa2UkMSA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHggIT09ICdmdW5jdGlvbic7XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3Vic2NyaWJlVG9BcnJheSxfc3Vic2NyaWJlVG9Qcm9taXNlLF9zdWJzY3JpYmVUb0l0ZXJhYmxlLF9zdWJzY3JpYmVUb09ic2VydmFibGUsX2lzQXJyYXlMaWtlLF9pc1Byb21pc2UsX2lzT2JqZWN0LF9zeW1ib2xfaXRlcmF0b3IsX3N5bWJvbF9vYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgc3Vic2NyaWJlVG8gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIGlmICghIXJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W29ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN1YnNjcmliZVRvT2JzZXJ2YWJsZShyZXN1bHQpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlMaWtlJDEocmVzdWx0KSkge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb0FycmF5KHJlc3VsdCk7XG4gIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlVG9Qcm9taXNlKHJlc3VsdCk7XG4gIH0gZWxzZSBpZiAoISFyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlVG9JdGVyYWJsZShyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciB2YWx1ZSA9IGlzT2JqZWN0JDEocmVzdWx0KSA/ICdhbiBpbnZhbGlkIG9iamVjdCcgOiBcIidcIiArIHJlc3VsdCArIFwiJ1wiO1xuICAgIHZhciBtc2cgPSBcIllvdSBwcm92aWRlZCBcIiArIHZhbHVlICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLlwiICsgJyBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgQXJyYXksIG9yIEl0ZXJhYmxlLic7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfT2JzZXJ2YWJsZSxfdXRpbF9zdWJzY3JpYmVUbyBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFNpbXBsZUlubmVyU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW1wbGVJbm5lclN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2ltcGxlSW5uZXJTdWJzY3JpYmVyKHBhcmVudCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2ltcGxlSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodmFsdWUpO1xuICB9O1xuXG4gIFNpbXBsZUlubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTaW1wbGVJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcmVudC5ub3RpZnlDb21wbGV0ZSgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcblxudmFyIFNpbXBsZU91dGVyU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW1wbGVPdXRlclN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2ltcGxlT3V0ZXJTdWJzY3JpYmVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChpbm5lclZhbHVlKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICB9O1xuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICB9O1xuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuXG5mdW5jdGlvbiBpbm5lclN1YnNjcmliZShyZXN1bHQsIGlubmVyU3Vic2NyaWJlcikge1xuICBpZiAoaW5uZXJTdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiByZXN1bHQuc3Vic2NyaWJlKGlubmVyU3Vic2NyaWJlcik7XG4gIH1cblxuICByZXR1cm4gc3Vic2NyaWJlVG8ocmVzdWx0KShpbm5lclN1YnNjcmliZXIpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaXB0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgQWN0aW9uID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gIH1cblxuICBBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBBY3Rpb247XG59KFN1YnNjcmlwdGlvbik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9BY3Rpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBBc3luY0FjdGlvbiA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgX3RoaXMud29yayA9IHdvcms7XG4gICAgX3RoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuXG4gICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCB0aGlzLnJlcXVlc3RBc3luY0lkKHNjaGVkdWxlciwgdGhpcy5pZCwgZGVsYXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldEludGVydmFsKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgdGhpcyksIGRlbGF5KTtcbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBkZWxheSAmJiB0aGlzLnBlbmRpbmcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcblxuICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgIGVycm9yVmFsdWUgPSAhIWUgJiYgZSB8fCBuZXcgRXJyb3IoZSk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yZWQpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHJldHVybiBlcnJvclZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgIHZhciBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgdmFyIGluZGV4ID0gYWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gQXN5bmNBY3Rpb247XG59KEFjdGlvbik7XG5cbnZhciBTY2hlZHVsZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBub3cpIHtcbiAgICBpZiAobm93ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdyA9IFNjaGVkdWxlci5ub3c7XG4gICAgfVxuXG4gICAgdGhpcy5TY2hlZHVsZXJBY3Rpb24gPSBTY2hlZHVsZXJBY3Rpb247XG4gICAgdGhpcy5ub3cgPSBub3c7XG4gIH1cblxuICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzLlNjaGVkdWxlckFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICB9O1xuXG4gIFNjaGVkdWxlci5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG5cbiAgcmV0dXJuIFNjaGVkdWxlcjtcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIEFzeW5jU2NoZWR1bGVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7XG4gICAgICBub3cgPSBTY2hlZHVsZXIubm93O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNjaGVkdWxlckFjdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICYmIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICE9PSBfdGhpcykge1xuICAgICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUubm93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm93KCk7XG4gICAgICB9XG4gICAgfSkgfHwgdGhpcztcblxuICAgIF90aGlzLmFjdGlvbnMgPSBbXTtcbiAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICBfdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICYmIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICE9PSB0aGlzKSB7XG4gICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUuc2NoZWR1bGUod29yaywgZGVsYXksIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCB3b3JrLCBkZWxheSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG5cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTtcblxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQXN5bmNTY2hlZHVsZXI7XG59KFNjaGVkdWxlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9Bc3luY0FjdGlvbixfQXN5bmNTY2hlZHVsZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBhc3luY1NjaGVkdWxlciA9IC8qQF9fUFVSRV9fKi9uZXcgQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb24pO1xudmFyIGFzeW5jID0gYXN5bmNTY2hlZHVsZXI7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9pc0FycmF5IFBVUkVfSU1QT1JUU19FTkQgKi9cblxuZnVuY3Rpb24gaXNOdW1lcmljKHZhbCkge1xuICByZXR1cm4gIWlzQXJyYXkkMSh2YWwpICYmIHZhbCAtIHBhcnNlRmxvYXQodmFsKSArIDEgPj0gMDtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpc1NjaGVkdWxlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnNjaGVkdWxlID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfc2NoZWR1bGVyX2FzeW5jLF91dGlsX2lzTnVtZXJpYyxfdXRpbF9pc1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGltZXIoZHVlVGltZSwgcGVyaW9kT3JTY2hlZHVsZXIsIHNjaGVkdWxlcikge1xuICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgZHVlVGltZSA9IDA7XG4gIH1cblxuICB2YXIgcGVyaW9kID0gLTE7XG5cbiAgaWYgKGlzTnVtZXJpYyhwZXJpb2RPclNjaGVkdWxlcikpIHtcbiAgICBwZXJpb2QgPSBOdW1iZXIocGVyaW9kT3JTY2hlZHVsZXIpIDwgMSAmJiAxIHx8IE51bWJlcihwZXJpb2RPclNjaGVkdWxlcik7XG4gIH0gZWxzZSBpZiAoaXNTY2hlZHVsZXIocGVyaW9kT3JTY2hlZHVsZXIpKSB7XG4gICAgc2NoZWR1bGVyID0gcGVyaW9kT3JTY2hlZHVsZXI7XG4gIH1cblxuICBpZiAoIWlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICBzY2hlZHVsZXIgPSBhc3luYztcbiAgfVxuXG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHZhciBkdWUgPSBpc051bWVyaWMoZHVlVGltZSkgPyBkdWVUaW1lIDogK2R1ZVRpbWUgLSBzY2hlZHVsZXIubm93KCk7XG4gICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaCwgZHVlLCB7XG4gICAgICBpbmRleDogMCxcbiAgICAgIHBlcmlvZDogcGVyaW9kLFxuICAgICAgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2goc3RhdGUpIHtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsXG4gICAgICBwZXJpb2QgPSBzdGF0ZS5wZXJpb2QsXG4gICAgICBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgc3Vic2NyaWJlci5uZXh0KGluZGV4KTtcblxuICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocGVyaW9kID09PSAtMSkge1xuICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gIH1cblxuICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUsX1N1YnNjcmlwdGlvbiBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gc2NoZWR1bGVBcnJheShpbnB1dCwgc2NoZWR1bGVyKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHZhciBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN1YnNjcmliZXIubmV4dChpbnB1dFtpKytdKTtcblxuICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWIuYWRkKHRoaXMuc2NoZWR1bGUoKSk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiBzdWI7XG4gIH0pO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfdXRpbF9zdWJzY3JpYmVUb0FycmF5LF9zY2hlZHVsZWRfc2NoZWR1bGVBcnJheSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gZnJvbUFycmF5KGlucHV0LCBzY2hlZHVsZXIpIHtcbiAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlVG9BcnJheShpbnB1dCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2hlZHVsZUFycmF5KGlucHV0LCBzY2hlZHVsZXIpO1xuICB9XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF9TdWJzY3JpcHRpb24sX3N5bWJvbF9vYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBzY2hlZHVsZU9ic2VydmFibGUoaW5wdXQsIHNjaGVkdWxlcikge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB2YXIgc3ViID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlJDEgPSBpbnB1dFtvYnNlcnZhYmxlXSgpO1xuICAgICAgc3ViLmFkZChvYnNlcnZhYmxlJDEuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgc3ViLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBzdWI7XG4gIH0pO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfU3Vic2NyaXB0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBzY2hlZHVsZVByb21pc2UoaW5wdXQsIHNjaGVkdWxlcikge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB2YXIgc3ViID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnB1dC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzdWIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBzdWI7XG4gIH0pO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfU3Vic2NyaXB0aW9uLF9zeW1ib2xfaXRlcmF0b3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIHNjaGVkdWxlSXRlcmFibGUoaW5wdXQsIHNjaGVkdWxlcikge1xuICBpZiAoIWlucHV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdGVyYWJsZSBjYW5ub3QgYmUgbnVsbCcpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB2YXIgaXRlcmF0b3IkMTtcbiAgICBzdWIuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyYXRvciQxICYmIHR5cGVvZiBpdGVyYXRvciQxLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpdGVyYXRvciQxLnJldHVybigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGl0ZXJhdG9yJDEgPSBpbnB1dFtpdGVyYXRvcl0oKTtcbiAgICAgIHN1Yi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgZG9uZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvciQxLm5leHQoKTtcbiAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICBkb25lID0gcmVzdWx0LmRvbmU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gc3ViO1xuICB9KTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3N5bWJvbF9vYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpc0ludGVyb3BPYnNlcnZhYmxlKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCAmJiB0eXBlb2YgaW5wdXRbb2JzZXJ2YWJsZV0gPT09ICdmdW5jdGlvbic7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9zeW1ib2xfaXRlcmF0b3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGlzSXRlcmFibGUoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0ICYmIHR5cGVvZiBpbnB1dFtpdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9zY2hlZHVsZU9ic2VydmFibGUsX3NjaGVkdWxlUHJvbWlzZSxfc2NoZWR1bGVBcnJheSxfc2NoZWR1bGVJdGVyYWJsZSxfdXRpbF9pc0ludGVyb3BPYnNlcnZhYmxlLF91dGlsX2lzUHJvbWlzZSxfdXRpbF9pc0FycmF5TGlrZSxfdXRpbF9pc0l0ZXJhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBzY2hlZHVsZWQoaW5wdXQsIHNjaGVkdWxlcikge1xuICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgIGlmIChpc0ludGVyb3BPYnNlcnZhYmxlKGlucHV0KSkge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlT2JzZXJ2YWJsZShpbnB1dCwgc2NoZWR1bGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShpbnB1dCkpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZVByb21pc2UoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZSQxKGlucHV0KSkge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlQXJyYXkoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgfSBlbHNlIGlmIChpc0l0ZXJhYmxlKGlucHV0KSB8fCB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc2NoZWR1bGVJdGVyYWJsZShpbnB1dCwgc2NoZWR1bGVyKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKChpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgfHwgaW5wdXQpICsgJyBpcyBub3Qgb2JzZXJ2YWJsZScpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfdXRpbF9zdWJzY3JpYmVUbyxfc2NoZWR1bGVkX3NjaGVkdWxlZCBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gZnJvbShpbnB1dCwgc2NoZWR1bGVyKSB7XG4gIGlmICghc2NoZWR1bGVyKSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVUbyhpbnB1dCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2hlZHVsZWQoaW5wdXQsIHNjaGVkdWxlcik7XG4gIH1cbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmliZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtYXBPcGVyYXRpb24oc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbi4gQXJlIHlvdSBsb29raW5nIGZvciBgbWFwVG8oKWA/Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSk7XG4gIH07XG59XG5cbnZhciBNYXBPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gIH1cblxuICBNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMudGhpc0FyZykpO1xuICB9O1xuXG4gIHJldHVybiBNYXBPcGVyYXRvcjtcbn0oKTtcblxudmFyIE1hcFN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgX3RoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgX3RoaXM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gIH07XG5cbiAgcmV0dXJuIE1hcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfbWFwLF9vYnNlcnZhYmxlX2Zyb20sX2lubmVyU3Vic2NyaWJlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBtZXJnZU1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7XG4gICAgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVzdWx0U2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZS5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uIChhLCBpKSB7XG4gICAgICAgIHJldHVybiBmcm9tKHByb2plY3QoYSwgaSkpLnBpcGUobWFwKGZ1bmN0aW9uIChiLCBpaSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHRTZWxlY3RvcihhLCBiLCBpLCBpaSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sIGNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICBjb25jdXJyZW50ID0gcmVzdWx0U2VsZWN0b3I7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCBjb25jdXJyZW50KSk7XG4gIH07XG59XG5cbnZhciBNZXJnZU1hcE9wZXJhdG9yID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gIH1cblxuICBNZXJnZU1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VNYXBTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByb2plY3QsIHRoaXMuY29uY3VycmVudCkpO1xuICB9O1xuXG4gIHJldHVybiBNZXJnZU1hcE9wZXJhdG9yO1xufSgpO1xuXG52YXIgTWVyZ2VNYXBTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKE1lcmdlTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBNZXJnZU1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgX3RoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgX3RoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgX3RoaXMuYnVmZmVyID0gW107XG4gICAgX3RoaXMuYWN0aXZlID0gMDtcbiAgICBfdGhpcy5pbmRleCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgdGhpcy5fdHJ5TmV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmUrKztcblxuICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCk7XG4gIH07XG5cbiAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoKSB7XG4gICAgdmFyIGlubmVyU3Vic2NyaWJlciA9IG5ldyBTaW1wbGVJbm5lclN1YnNjcmliZXIodGhpcyk7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICBkZXN0aW5hdGlvbi5hZGQoaW5uZXJTdWJzY3JpYmVyKTtcbiAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSBpbm5lclN1YnNjcmliZShpc2gsIGlubmVyU3Vic2NyaWJlcik7XG5cbiAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24gIT09IGlubmVyU3Vic2NyaWJlcikge1xuICAgICAgZGVzdGluYXRpb24uYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAoaW5uZXJWYWx1ZSkge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgfTtcblxuICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB0aGlzLmFjdGl2ZS0tO1xuXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNZXJnZU1hcFN1YnNjcmliZXI7XG59KFNpbXBsZU91dGVyU3Vic2NyaWJlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9tZXJnZU1hcCxfdXRpbF9pZGVudGl0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gbWVyZ2VBbGwoY29uY3VycmVudCkge1xuICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7XG4gICAgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIHJldHVybiBtZXJnZU1hcChpZGVudGl0eSwgY29uY3VycmVudCk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKCt2YWx1ZSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgRU1QVFkgPSAvKkBfX1BVUkVfXyovbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbn0pO1xuXG5mdW5jdGlvbiBlbXB0eSQxKHNjaGVkdWxlcikge1xuICByZXR1cm4gc2NoZWR1bGVyID8gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSA6IEVNUFRZO1xufVxuXG5mdW5jdGlvbiBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIHRocm93RXJyb3IoZXJyb3IsIHNjaGVkdWxlcikge1xuICBpZiAoIXNjaGVkdWxlcikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaCQxLCAwLCB7XG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2gkMShfYSkge1xuICB2YXIgZXJyb3IgPSBfYS5lcnJvcixcbiAgICAgIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyO1xuICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsKCkge1xuICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tZXNzYWdlID0gJ2FyZ3VtZW50IG91dCBvZiByYW5nZSc7XG4gICAgdGhpcy5uYW1lID0gJ0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICByZXR1cm4gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsO1xufSgpO1xuXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGw7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gZmlsdGVyT3BlcmF0b3JGdW5jdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykpO1xuICB9O1xufVxuXG52YXIgRmlsdGVyT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICB9XG5cbiAgRmlsdGVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbHRlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMudGhpc0FyZykpO1xuICB9O1xuXG4gIHJldHVybiBGaWx0ZXJPcGVyYXRvcjtcbn0oKTtcblxudmFyIEZpbHRlclN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICBfdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRmlsdGVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyLF91dGlsX0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLF9vYnNlcnZhYmxlX2VtcHR5IFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0YWtlKGNvdW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHkkMSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRha2VPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFRha2VPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRha2VPcGVyYXRvcih0b3RhbCkge1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcblxuICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgVGFrZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnRvdGFsKSk7XG4gIH07XG5cbiAgcmV0dXJuIFRha2VPcGVyYXRvcjtcbn0oKTtcblxudmFyIFRha2VTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRha2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRha2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMudG90YWwgPSB0b3RhbDtcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGFrZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICB2YXIgY291bnQgPSArK3RoaXMuY291bnQ7XG5cbiAgICBpZiAoY291bnQgPD0gdG90YWwpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG5cbiAgICAgIGlmIChjb3VudCA9PT0gdG90YWwpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUYWtlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpYmVyLF9TdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGZpbmFsaXplKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spKTtcbiAgfTtcbn1cblxudmFyIEZpbmFsbHlPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbmFsbHlPcGVyYXRvcihjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIEZpbmFsbHlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluYWxseVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jYWxsYmFjaykpO1xuICB9O1xuXG4gIHJldHVybiBGaW5hbGx5T3BlcmF0b3I7XG59KCk7XG5cbnZhciBGaW5hbGx5U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhGaW5hbGx5U3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBGaW5hbGx5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLmFkZChuZXcgU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRmluYWxseVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGwgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGwoKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnb2JqZWN0IHVuc3Vic2NyaWJlZCc7XG4gICAgdGhpcy5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIE9iamVjdFVuc3Vic2NyaWJlZEVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICByZXR1cm4gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JJbXBsO1xufSgpO1xuXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGw7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgc3Vic2NyaWJlcikge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICBfdGhpcy5zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgICBfdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG5cbiAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3ViamVjdFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX09ic2VydmFibGUsX1N1YnNjcmliZXIsX1N1YnNjcmlwdGlvbixfdXRpbF9PYmplY3RVbnN1YnNjcmliZWRFcnJvcixfU3ViamVjdFN1YnNjcmlwdGlvbixfaW50ZXJuYWxfc3ltYm9sX3J4U3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcik7XG5cbnZhciBTdWJqZWN0ID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgX3RoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgX3RoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBfdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICB9O1xuXG4gIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICByZXR1cm4gc3ViamVjdDtcbiAgfTtcblxuICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICB0aGlzLnRocm93bkVycm9yID0gZXJyO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvcHlbaV0uZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3RyeVN1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG4gIH07XG5cbiAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgfTtcblxuICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZSk7XG5cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgX3RoaXMuc291cmNlID0gc291cmNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfVxuICB9O1xuXG4gIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG5cbiAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSxfdXRpbF9pc1NjaGVkdWxlcixfb3BlcmF0b3JzX21lcmdlQWxsLF9mcm9tQXJyYXkgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIG9ic2VydmFibGVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICB2YXIgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgdmFyIHNjaGVkdWxlciA9IG51bGw7XG4gIHZhciBsYXN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG5cbiAgaWYgKGlzU2NoZWR1bGVyKGxhc3QpKSB7XG4gICAgc2NoZWR1bGVyID0gb2JzZXJ2YWJsZXMucG9wKCk7XG5cbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID4gMSAmJiB0eXBlb2Ygb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7XG4gICAgICBjb25jdXJyZW50ID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykge1xuICAgIGNvbmN1cnJlbnQgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgfVxuXG4gIGlmIChzY2hlZHVsZXIgPT09IG51bGwgJiYgb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIG9ic2VydmFibGVzWzBdIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgfVxuXG4gIHJldHVybiBtZXJnZUFsbChjb25jdXJyZW50KShmcm9tQXJyYXkob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgaW5jbHVzaXZlKSB7XG4gIGlmIChpbmNsdXNpdmUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1c2l2ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSwgaW5jbHVzaXZlKSk7XG4gIH07XG59XG5cbnZhciBUYWtlV2hpbGVPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRha2VXaGlsZU9wZXJhdG9yKHByZWRpY2F0ZSwgaW5jbHVzaXZlKSB7XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgdGhpcy5pbmNsdXNpdmUgPSBpbmNsdXNpdmU7XG4gIH1cblxuICBUYWtlV2hpbGVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5pbmNsdXNpdmUpKTtcbiAgfTtcblxuICByZXR1cm4gVGFrZVdoaWxlT3BlcmF0b3I7XG59KCk7XG5cbnZhciBUYWtlV2hpbGVTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRha2VXaGlsZVN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVGFrZVdoaWxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCBpbmNsdXNpdmUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICBfdGhpcy5pbmNsdXNpdmUgPSBpbmNsdXNpdmU7XG4gICAgX3RoaXMuaW5kZXggPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRha2VXaGlsZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyspO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5leHRPckNvbXBsZXRlKHZhbHVlLCByZXN1bHQpO1xuICB9O1xuXG4gIFRha2VXaGlsZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHRPckNvbXBsZXRlID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVkaWNhdGVSZXN1bHQpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKEJvb2xlYW4ocHJlZGljYXRlUmVzdWx0KSkge1xuICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmluY2x1c2l2ZSkge1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRha2VXaGlsZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBUaW1lb3V0RXJyb3JJbXBsID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZW91dEVycm9ySW1wbCgpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZSA9ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCc7XG4gICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBUaW1lb3V0RXJyb3JJbXBsLnByb3RvdHlwZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIHJldHVybiBUaW1lb3V0RXJyb3JJbXBsO1xufSgpO1xuXG52YXIgVGltZW91dEVycm9yID0gVGltZW91dEVycm9ySW1wbDtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX3NjaGVkdWxlcl9hc3luYyxfdXRpbF9pc0RhdGUsX2lubmVyU3Vic2NyaWJlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuZnVuY3Rpb24gdGltZW91dFdpdGgoZHVlLCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSB7XG4gIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkge1xuICAgIHNjaGVkdWxlciA9IGFzeW5jO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICB2YXIgYWJzb2x1dGVUaW1lb3V0ID0gaXNEYXRlKGR1ZSk7XG4gICAgdmFyIHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyArZHVlIC0gc2NoZWR1bGVyLm5vdygpIDogTWF0aC5hYnMoZHVlKTtcbiAgICByZXR1cm4gc291cmNlLmxpZnQobmV3IFRpbWVvdXRXaXRoT3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSk7XG4gIH07XG59XG5cbnZhciBUaW1lb3V0V2l0aE9wZXJhdG9yID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZW91dFdpdGhPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICB0aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgIHRoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgIHRoaXMud2l0aE9ic2VydmFibGUgPSB3aXRoT2JzZXJ2YWJsZTtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgfVxuXG4gIFRpbWVvdXRXaXRoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRpbWVvdXRXaXRoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmFic29sdXRlVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzLndpdGhPYnNlcnZhYmxlLCB0aGlzLnNjaGVkdWxlcikpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lb3V0V2l0aE9wZXJhdG9yO1xufSgpO1xuXG52YXIgVGltZW91dFdpdGhTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRpbWVvdXRXaXRoU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUaW1lb3V0V2l0aFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGFic29sdXRlVGltZW91dCwgd2FpdEZvciwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuYWJzb2x1dGVUaW1lb3V0ID0gYWJzb2x1dGVUaW1lb3V0O1xuICAgIF90aGlzLndhaXRGb3IgPSB3YWl0Rm9yO1xuICAgIF90aGlzLndpdGhPYnNlcnZhYmxlID0gd2l0aE9ic2VydmFibGU7XG4gICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuXG4gICAgX3RoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUaW1lb3V0V2l0aFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0ID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB2YXIgd2l0aE9ic2VydmFibGUgPSBzdWJzY3JpYmVyLndpdGhPYnNlcnZhYmxlO1xuXG4gICAgc3Vic2NyaWJlci5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG5cbiAgICBzdWJzY3JpYmVyLmFkZChpbm5lclN1YnNjcmliZSh3aXRoT2JzZXJ2YWJsZSwgbmV3IFNpbXBsZUlubmVyU3Vic2NyaWJlcihzdWJzY3JpYmVyKSkpO1xuICB9O1xuXG4gIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbjtcblxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uLnNjaGVkdWxlKHRoaXMsIHRoaXMud2FpdEZvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKHRoaXMuYWN0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoVGltZW91dFdpdGhTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cblxuICAgIF9zdXBlci5wcm90b3R5cGUuX25leHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH07XG5cbiAgVGltZW91dFdpdGhTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgIHRoaXMud2l0aE9ic2VydmFibGUgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBUaW1lb3V0V2l0aFN1YnNjcmliZXI7XG59KFNpbXBsZU91dGVyU3Vic2NyaWJlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9zY2hlZHVsZXJfYXN5bmMsX3V0aWxfVGltZW91dEVycm9yLF90aW1lb3V0V2l0aCxfb2JzZXJ2YWJsZV90aHJvd0Vycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0aW1lb3V0KGR1ZSwgc2NoZWR1bGVyKSB7XG4gIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkge1xuICAgIHNjaGVkdWxlciA9IGFzeW5jO1xuICB9XG5cbiAgcmV0dXJuIHRpbWVvdXRXaXRoKGR1ZSwgdGhyb3dFcnJvcihuZXcgVGltZW91dEVycm9yKCkpLCBzY2hlZHVsZXIpO1xufVxuXG5sZXQgdXJsQWxwaGFiZXQgPSAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCc7XG5jb25zdCBQT09MX1NJWkVfTVVMVElQTElFUiA9IDEyODtcbmxldCBwb29sLCBwb29sT2Zmc2V0O1xuXG5sZXQgZmlsbFBvb2wgPSBieXRlcyA9PiB7XG4gIGlmICghcG9vbCB8fCBwb29sLmxlbmd0aCA8IGJ5dGVzKSB7XG4gICAgcG9vbCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcyAqIFBPT0xfU0laRV9NVUxUSVBMSUVSKTtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocG9vbCk7XG4gICAgcG9vbE9mZnNldCA9IDA7XG4gIH0gZWxzZSBpZiAocG9vbE9mZnNldCArIGJ5dGVzID4gcG9vbC5sZW5ndGgpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocG9vbCk7XG4gICAgcG9vbE9mZnNldCA9IDA7XG4gIH1cblxuICBwb29sT2Zmc2V0ICs9IGJ5dGVzO1xufTtcblxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgZmlsbFBvb2woc2l6ZSAtPSAwKTtcbiAgbGV0IGlkID0gJyc7XG5cbiAgZm9yIChsZXQgaSA9IHBvb2xPZmZzZXQgLSBzaXplOyBpIDwgcG9vbE9mZnNldDsgaSsrKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbcG9vbFtpXSAmIDYzXTtcbiAgfVxuXG4gIHJldHVybiBpZDtcbn07XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlLF91dGlsX2lzQXJyYXksX3V0aWxfaXNGdW5jdGlvbixfb3BlcmF0b3JzX21hcCBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gZnJvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zLCByZXN1bHRTZWxlY3Rvcikge1xuICBpZiAoaXNGdW5jdGlvbiQxKG9wdGlvbnMpKSB7XG4gICAgcmVzdWx0U2VsZWN0b3IgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zKS5waXBlKG1hcChmdW5jdGlvbiAoYXJncykge1xuICAgICAgcmV0dXJuIGlzQXJyYXkkMShhcmdzKSA/IHJlc3VsdFNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncykgOiByZXN1bHRTZWxlY3RvcihhcmdzKTtcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0dXBTdWJzY3JpcHRpb24odGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc3Vic2NyaWJlO1xuXG4gIGlmIChpc0V2ZW50VGFyZ2V0KHNvdXJjZU9iaikpIHtcbiAgICB2YXIgc291cmNlXzEgPSBzb3VyY2VPYmo7XG4gICAgc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcblxuICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNvdXJjZV8xLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgIHZhciBzb3VyY2VfMiA9IHNvdXJjZU9iajtcbiAgICBzb3VyY2VPYmoub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcblxuICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNvdXJjZV8yLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgIHZhciBzb3VyY2VfMyA9IHNvdXJjZU9iajtcbiAgICBzb3VyY2VPYmouYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcblxuICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNvdXJjZV8zLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChzb3VyY2VPYmogJiYgc291cmNlT2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VPYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9ialtpXSwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBldmVudCB0YXJnZXQnKTtcbiAgfVxuXG4gIHN1YnNjcmliZXIuYWRkKHVuc3Vic2NyaWJlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gIHJldHVybiBzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikge1xuICByZXR1cm4gc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmoub24gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5vZmYgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSB7XG4gIHJldHVybiBzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuY29uc3Qgc2ltdWxhdGlvbnMkID0gbmV3IFN1YmplY3QoKTtcblxuZnVuY3Rpb24gc2ltdWxhdGUoc3lzdGVtLCBuZXR3b3JrLCB0cmFuc2FjdGlvbikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcbiAgY29uc3QgaWQgPSBuYW5vaWQoKTsgLy8gc2VuZCBwYXlsb2FkIHRvIHNlcnZlclxuXG4gIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICBjYXRlZ29yeUNvZGU6ICdzaW11bGF0ZScsXG4gICAgZXZlbnRDb2RlOiAndHhTaW11bGF0aW9uJyxcbiAgICBldmVudElkOiBpZCxcbiAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzaW11bGF0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICAgIGV2ZW50SWRcbiAgICB9KSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRJZCA9PT0gaWQ7XG4gICAgfSksIHRha2UoMSkpLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe1xuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfSkgPT4gcmVzb2x2ZSh0cmFuc2FjdGlvbiksXG4gICAgICBlcnJvcjogKHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pID0+IHJlamVjdChlcnJvci5tZXNzYWdlKVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbXVsdGlTaW0odHJhbnNhY3Rpb25zKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuICBjb25zdCBpZCA9IG5hbm9pZCgpOyAvLyBzZW5kIHBheWxvYWQgdG8gc2VydmVyXG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGNhdGVnb3J5Q29kZTogJ3NpbXVsYXRlJyxcbiAgICBldmVudENvZGU6ICd0eFNpbXVsYXRpb24nLFxuICAgIGV2ZW50SWQ6IGlkLFxuICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzaW11bGF0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICAgIGV2ZW50SWRcbiAgICB9KSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRJZCA9PT0gaWQ7XG4gICAgfSksIHRha2UoMSkpLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe1xuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfSkgPT4gcmVzb2x2ZSh0cmFuc2FjdGlvbiksXG4gICAgICBlcnJvcjogKHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pID0+IHJlamVjdChlcnJvci5tZXNzYWdlKVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5zdWJzY3JpYmUoYWRkcmVzc09ySGFzaCkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcbiAgY29uc3QgYWRkcmVzcyA9IGlzQWRkcmVzcyh0aGlzLl9zeXN0ZW0sIGFkZHJlc3NPckhhc2gpO1xuICBjb25zdCB0eGlkID0gaXNUeGlkKHRoaXMuX3N5c3RlbSwgYWRkcmVzc09ySGFzaCk7IC8vIGNoZWNrIGlmIGl0IGlzIGFuIGFkZHJlc3Mgb3IgYSBoYXNoXG5cbiAgaWYgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzcyA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IGFkZHJlc3NPckhhc2gudG9Mb3dlckNhc2UoKSA6IGFkZHJlc3NPckhhc2g7IC8vIHJlbW92ZSBhZGRyZXNzIGZyb20gYWNjb3VudHNcblxuICAgIHRoaXMud2F0Y2hlZEFjY291bnRzID0gdGhpcy53YXRjaGVkQWNjb3VudHMuZmlsdGVyKGFjID0+IGFjLmFkZHJlc3MgIT09IG5vcm1hbGl6ZWRBZGRyZXNzKTsgLy8gcmVtb3ZlIGNvbmZpZ3VyYXRpb24gZnJvbSBtZW1vcnlcblxuICAgIHRoaXMuY29uZmlndXJhdGlvbnMuZGVsZXRlKG5vcm1hbGl6ZWRBZGRyZXNzKTsgLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBjYXRlZ29yeUNvZGU6ICdhY2NvdW50QWRkcmVzcycsXG4gICAgICBldmVudENvZGU6ICd1bndhdGNoJyxcbiAgICAgIGFjY291bnQ6IHtcbiAgICAgICAgYWRkcmVzczogbm9ybWFsaXplZEFkZHJlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eGlkKSB7XG4gICAgLy8gcmVtb3ZlIHRyYW5zYWN0aW9uIGZyb20gdHJhbnNhY3Rpb25zXG4gICAgdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zID0gdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zLmZpbHRlcih0eCA9PiB0eC5oYXNoICE9PSBhZGRyZXNzT3JIYXNoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8ge1xuICAgICAgaGFzaDogYWRkcmVzc09ySGFzaFxuICAgIH0gOiB7XG4gICAgICB0eGlkOiBhZGRyZXNzT3JIYXNoXG4gICAgfTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHsgLi4udHJhbnNhY3Rpb25JZCxcbiAgICAgIGlkOiBhZGRyZXNzT3JIYXNoLFxuICAgICAgc3RhdHVzOiAndW5zdWJzY3JpYmVkJ1xuICAgIH07IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgY2F0ZWdvcnlDb2RlOiAnYWN0aXZlVHJhbnNhY3Rpb24nLFxuICAgICAgZXZlbnRDb2RlOiAndW53YXRjaCcsXG4gICAgICB0cmFuc2FjdGlvblxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgdHJ5aW5nIHRvIHVuc3Vic2NyaWJlICR7YWRkcmVzc09ySGFzaH06IG5vdCBhIHZhbGlkIGFkZHJlc3Mgb3IgdHJhbnNhY3Rpb24gaWQvaGFzaGApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb24oY29uZmlnKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IGNhc2VkU2NvcGUgPSB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyBjb25maWcuc2NvcGUudG9Mb3dlckNhc2UoKSA6IGNvbmZpZy5zY29wZTsgLy8gcmVzb2x2ZSBwcmV2aW91cyBjb25maWd1cmF0aW9uIGlmIGV4aXN0c1xuXG4gIGNvbnN0IHByZXZpb3VzQ29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZ2V0KGNhc2VkU2NvcGUpO1xuICBwcmV2aW91c0NvbmZpZ3VyYXRpb24gJiYgcHJldmlvdXNDb25maWd1cmF0aW9uLnN1YnNjcmlwdGlvbiAmJiBwcmV2aW91c0NvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uLm5leHQoKTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YmplY3QoKTsgLy8gY3JlYXRlIGVtaXR0ZXIgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZW1pdHRlciA9IGNvbmZpZy53YXRjaEFkZHJlc3MgPyB7XG4gICAgZW1pdHRlcjogY3JlYXRlRW1pdHRlcigpXG4gIH0gOiB7fTtcbiAgdGhpcy5jb25maWd1cmF0aW9ucy5zZXQoY2FzZWRTY29wZSwgeyAuLi5jb25maWcsXG4gICAgLi4uZW1pdHRlcixcbiAgICBzdWJzY3JpcHRpb25cbiAgfSk7XG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGNhdGVnb3J5Q29kZTogJ2NvbmZpZ3MnLFxuICAgIGV2ZW50Q29kZTogJ3B1dCcsXG4gICAgY29uZmlnXG4gIH0pO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3Vic2NyaXB0aW9uLnBpcGUodGFrZSgxKSwgdGltZW91dCg1MDAwKSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICgpID0+IHJlc29sdmUoeyAuLi5lbWl0dGVyLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgY29uZmlnXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgPT09ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCcgPyBgQ29uZmlndXJhdGlvbiB3aXRoIHNjb3BlOiAke2NvbmZpZy5zY29wZX0gaGFzIGJlZW4gc2VudCB0byB0aGUgQmxvY2tuYXRpdmUgc2VydmVyLCBidXQgaGFzIG5vdCByZWNlaXZlZCBhIHJlcGx5IHdpdGhpbiA1IHNlY29uZHMuYCA6IGVycm9yLm1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlc29sdmUoYEVycm9yOiAke21lc3NhZ2V9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUoc3Vic2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBjaGFpbklkLFxuICAgIHR5cGVcbiAgfSA9IHN1YnNjcmlwdGlvbjtcblxuICBpZiAoIW5ldHdvcmtOYW1lKCdldGhlcmV1bScsIHBhcnNlSW50KGNoYWluSWQsIDE2KSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNoYWluSWQ6ICR7Y2hhaW5JZH0gaXMgYW4gdW5zdXBwb3J0ZWQgbmV0d29ya2ApO1xuICB9XG5cbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW2NoYWluSWRdKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uc1tjaGFpbklkXSA9IG5ldyB0aGlzLkJsb2NrbmF0aXZlKHtcbiAgICAgIHN5c3RlbTogJ2V0aGVyZXVtJyxcbiAgICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoY2hhaW5JZCwgMTYpLFxuICAgICAgZGFwcElkOiB0aGlzLmFwaUtleSxcbiAgICAgIHdzOiB0aGlzLndzLFxuICAgICAgYXBpVXJsOiB0aGlzLmFwaVVybCxcbiAgICAgIHRyYW5zYWN0aW9uSGFuZGxlcnM6IFsoe1xuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfSkgPT4ge1xuICAgICAgICB0aGlzLm9uVHJhbnNhY3Rpb24kLm5leHQodHJhbnNhY3Rpb24pO1xuICAgICAgfV0sXG4gICAgICBvbmVycm9yOiBlcnJvciA9PiB0aGlzLmVycm9ycyQubmV4dChlcnJvcilcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNkayA9IHRoaXMuY29ubmVjdGlvbnNbY2hhaW5JZF07XG5cbiAgaWYgKHR5cGUgPT09ICdhY2NvdW50Jykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlcnMgPSBbXSxcbiAgICAgIGFiaVxuICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgc2RrLmNvbmZpZ3VyYXRpb24oe1xuICAgICAgc2NvcGU6IGlkLFxuICAgICAgZmlsdGVycyxcbiAgICAgIC4uLihhYmkgPyB7XG4gICAgICAgIGFiaVxuICAgICAgfSA6IHt9KSxcbiAgICAgIHdhdGNoQWRkcmVzczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICAgIHdhdGNoZWRBZGRyZXNzXG4gICAgfSkgPT4gd2F0Y2hlZEFkZHJlc3MgPT09IGlkKSwgZmluYWxpemUoKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHRlclxuICAgIH0gPSBzZGsudHJhbnNhY3Rpb24oaWQpO1xuICAgIHJldHVybiBmcm9tRXZlbnQoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIC8vIEB0cy1pZ25vcmUgLSBzdHJpbmcgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWMgZXZlbnRjb2RlIHN0cmluZ1xuICAgIGVtaXR0ZXIsICdhbGwnKS5waXBlKCAvLyBhdXRvbWF0aWNhbGx5IGNvbXBsZXRlIHN0cmVhbSBvbiBhIGZpbmFsaXplZCBzdGF0dXNcbiAgICB0YWtlV2hpbGUoKHtcbiAgICAgIHN0YXR1c1xuICAgIH0pID0+IHN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgc3RhdHVzICE9PSAnZmFpbGVkJyAmJiBzdGF0dXMgIT09ICdkcm9wcGVkJywgdHJ1ZSksIC8vIGNsZWFudXAgc3Vic2NyaXB0aW9uIGFuZCBTREsgb24gY29tcGxldGlvblxuICAgIGZpbmFsaXplKCgpID0+IHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3Vic2NyaWJlJDEob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgaWQsXG4gICAgY2hhaW5JZCxcbiAgICB0aW1lb3V0ID0gMFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGltZSQgPSB0aW1lcih0aW1lb3V0KTtcbiAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCQgPSB0aGlzLnRyYW5zYWN0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICBoYXNoLFxuICAgIHdhdGNoZWRBZGRyZXNzXG4gIH0pID0+IGhhc2ggPT09IGlkIHx8IHdhdGNoZWRBZGRyZXNzID09PSBpZCkpO1xuICBtZXJnZSh0cmFuc2FjdGlvbkV2ZW50JCwgdGltZSQpLnBpcGUodGFrZSgxKSkgLy8gdGFrZSBqdXN0IGZpcnN0IGV2ZW50XG4gIC5zdWJzY3JpYmUocmVzID0+IHtcbiAgICAvLyBpZiBudW1iZXIsIHRoZW4gdGltZW91dCB3aXRoIG5vIHRyYW5zYWN0aW9uIGV2ZW50cywgc28gZ28gYWhlYWQgYW5kIHVuc3ViXG4gICAgaWYgKHR5cGVvZiByZXMgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCBzZGtDb25uZWN0aW9ucyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuY29ubmVjdGlvbnMpLmZpbHRlcigoW2NoYWluSWQsIHNka10pID0+IHNkayAhPT0gbnVsbCk7XG4gICAgICBzZGtDb25uZWN0aW9ucy5mb3JFYWNoKChbY29ubmVjdGlvbkNoYWluSWQsIHNka10pID0+IHtcbiAgICAgICAgLy8gaWYgY2hhaW5JZCBpcyBwYXNzZWQgYW5kIGl0IGRvZXNuJ3QgbWF0Y2gsIHRoZW4gbm8gdW5zdWIgKHJldHVybiBlYXJseSlcbiAgICAgICAgaWYgKGNoYWluSWQgJiYgY29ubmVjdGlvbkNoYWluSWQgIT09IGNoYWluSWQpIHJldHVybjtcbiAgICAgICAgc2RrLnVuc3Vic2NyaWJlKGlkKTsgLy8gaWYgbm8gcmVtYWluaW5nIHN1YnNjcmlwdGlvbnMsIGRlc3Ryb3kgY29ubmVjdGlvbiBhbmQgc2V0IHRvIG51bGxcblxuICAgICAgICBpZiAoIXNkay53YXRjaGVkQWNjb3VudHMubGVuZ3RoICYmICFzZGsud2F0Y2hlZFRyYW5zYWN0aW9ucy5sZW5ndGggJiYgIXNkay5jb25maWd1cmF0aW9ucy5zaXplKSB7XG4gICAgICAgICAgc2RrLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25DaGFpbklkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UgYSB0cmFuc2FjdGlvbiBldmVudCByZWNlaXZlZCwgc28gY2FsbCB1bnN1YiBhZ2FpbiBmb3IgYW5vdGhlciB0aW1lb3V0XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59IC8vKipFeHBlcmltZW50YWwgQVBJIHRoYXQgaXMgbm90IHlldCBmaW5hbGl6ZWQgYW5kIGlzIGluIEJFVEEqL1xuXG5cbmNsYXNzIE11bHRpQ2hhaW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBCbG9ja25hdGl2ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdzXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgYXBpS2V5XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgYXBpVXJsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgdGhpcy5hcGlVcmwgPSBhcGlVcmw7XG4gICAgdGhpcy53cyA9IHdzO1xuICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fTtcbiAgICB0aGlzLm9uVHJhbnNhY3Rpb24kID0gbmV3IFN1YmplY3QoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9ucyQgPSB0aGlzLm9uVHJhbnNhY3Rpb24kLmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuZXJyb3JzJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5CbG9ja25hdGl2ZSA9IEJsb2NrbmF0aXZlO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlJDEuYmluZCh0aGlzKTtcbiAgfVxuXG59XG5cbnZhciB2ZXJzaW9uID0gXCI0LjYuN1wiO1xuXG5mdW5jdGlvbiBzZW5kTWVzc2FnZShtc2cpIHtcbiAgaWYgKHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLmxlbmd0aCA+IFFVRVVFX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBRdWV1ZSBsaW1pdCBvZiAke1FVRVVFX0xJTUlUfSBtZXNzYWdlcyBoYXMgYmVlbiByZWFjaGVkLmApO1xuICB9XG5cbiAgdGhpcy5fcXVldWVkTWVzc2FnZXMucHVzaChjcmVhdGVFdmVudExvZy5iaW5kKHRoaXMpKG1zZykpO1xuXG4gIGlmICghdGhpcy5fcHJvY2Vzc2luZ1F1ZXVlKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICB0aGlzLl9wcm9jZXNzaW5nUXVldWUgPSB0cnVlO1xuXG4gIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbm5lY3Rpb25PcGVuLmJpbmQodGhpcykoKTtcbiAgfVxuXG4gIHdoaWxlICh0aGlzLl9xdWV1ZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gc21hbGwgd2FpdCB0byBhbGxvdyByZXNwb25zZSBmcm9tIHNlcnZlciB0byB0YWtlIGFmZmVjdFxuICAgIGF3YWl0IHdhaXQoMSk7XG5cbiAgICBpZiAodGhpcy5fd2FpdFRvUmV0cnkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhdmUgYmVlbiByYXRlIGxpbWl0ZWQgc28gd2FpdFxuICAgICAgYXdhaXQgdGhpcy5fd2FpdFRvUmV0cnk7XG4gICAgICB0aGlzLl93YWl0VG9SZXRyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbXNnID0gdGhpcy5fcXVldWVkTWVzc2FnZXMuc2hpZnQoKTtcblxuICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5fbGltaXRSdWxlcy5kdXJhdGlvbiAvIHRoaXMuX2xpbWl0UnVsZXMucG9pbnRzICogMTAwMDtcbiAgICBhd2FpdCB3YWl0KGRlbGF5KTtcblxuICAgIHRoaXMuX3NvY2tldC5zZW5kKG1zZyk7XG4gIH1cblxuICB0aGlzLl9wcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgdGhpcy5fbGltaXRSdWxlcyA9IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUztcbn1cblxuZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtc2cpIHtcbiAgY29uc3Qge1xuICAgIHN0YXR1cyxcbiAgICByZWFzb24sXG4gICAgZXZlbnQsXG4gICAgY29ubmVjdGlvbklkLFxuICAgIHNlcnZlclZlcnNpb24sXG4gICAgcmV0cnlNcyxcbiAgICBsaW1pdFJ1bGVzLFxuICAgIGJsb2NrZWRNc2csXG4gICAgZGlzcGF0Y2hUaW1lc3RhbXBcbiAgfSA9IEpTT04ucGFyc2UobXNnLmRhdGEpO1xuXG4gIGlmIChjb25uZWN0aW9uSWQpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX3N0b3JhZ2VLZXksIGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICB9IC8vIGhhbmRsZSBhbnkgZXJyb3JzIGZyb20gdGhlIHNlcnZlclxuXG5cbiAgaWYgKHN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ3JhdGVsaW1pdCcpICYmICFyZWFzb24ubWF0Y2goL0lQIChQZW5kaW5nU2ltdWxhdGlvbnxOb3RpZmljYXRpb24pIHJhdGVsaW1pdCByZWFjaGVkLykpIHtcbiAgICAgIHRoaXMuX3dhaXRUb1JldHJ5ID0gd2FpdChyZXRyeU1zKTtcbiAgICAgIHRoaXMuX2xpbWl0UnVsZXMgPSBsaW1pdFJ1bGVzOyAvLyBhZGQgYmxvY2tlZCBtc2cgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuXG4gICAgICBibG9ja2VkTXNnICYmIHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLnVuc2hpZnQoYmxvY2tlZE1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygndXBncmFkZSB5b3VyIHBsYW4nKSkge1xuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25vdCBhIHZhbGlkIEFQSSBrZXknKSkge1xuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25ldHdvcmsgbm90IHN1cHBvcnRlZCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygnbWF4aW11bSBhbGxvd2VkIGFtb3VudCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgYml0Y29pbiB0eGlkIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ2ludmFsaWQgdHhpZCcpKSB7XG4gICAgICBjb25zdCByZWFzb24gPSBgJHtldmVudC50cmFuc2FjdGlvbi50eGlkfSBpcyBhbiBpbnZhbGlkIHR4aWRgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgdHJhbnNhY3Rpb246IGV2ZW50LnRyYW5zYWN0aW9uLnR4aWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gdHJhbnNhY3Rpb24gaGFzaCBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGhhc2gnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQudHJhbnNhY3Rpb24uaGFzaH0gaXMgYW4gaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoYDtcblxuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBldmVudC50cmFuc2FjdGlvbi5oYXNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGdlbmVyYWwgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGFkZHJlc3MnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQuYWNjb3VudC5hZGRyZXNzfSBpcyBhbiBpbnZhbGlkIGFkZHJlc3NgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGJpdGNvaW4gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBCaXRjb2luJykpIHtcbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICBhY2NvdW50OiBldmVudC5hY2NvdW50LmFkZHJlc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBFdGhlcmV1bScpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudCAmJiBldmVudC5jYXRlZ29yeUNvZGUgPT09ICdzaW11bGF0ZScpIHtcbiAgICAgIHNpbXVsYXRpb25zJC5lcnJvcih7XG4gICAgICAgIGV2ZW50SWQ6IGV2ZW50LmV2ZW50SWQsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaGFuZGxlIGNvbmZpZyBlcnJvclxuXG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29uZmlnKSB7XG4gICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5nZXQoZXZlbnQuY29uZmlnLnNjb3BlKTtcblxuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdGhyb3cgZXJyb3IgdGhhdCBjb21lcyBiYWNrIGZyb20gdGhlIHNlcnZlciB3aXRob3V0IGZvcm1hdHRpbmcgdGhlIG1lc3NhZ2VcblxuXG4gICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudCAmJiBldmVudC5jb25maWcpIHtcbiAgICBjb25zdCBjYXNlZFNjb3BlID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gZXZlbnQuY29uZmlnLnNjb3BlLnRvTG93ZXJDYXNlKCkgOiBldmVudC5jb25maWcuc2NvcGU7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZ2V0KGNhc2VkU2NvcGUpO1xuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24pIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBldmVudElkLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBldmVudENvZGUsXG4gICAgICBjb250cmFjdENhbGwsXG4gICAgICB0aW1lU3RhbXAsXG4gICAgICBibG9ja2NoYWluOiB7XG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgbmV0d29ya1xuICAgICAgfVxuICAgIH0gPSBldmVudDsgLy8gZmxhdHRlbiBpbiB0byBvbmUgb2JqZWN0XG5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IHsgLi4udHJhbnNhY3Rpb24sXG4gICAgICBzZXJ2ZXJWZXJzaW9uLFxuICAgICAgZXZlbnRDb2RlLFxuICAgICAgdGltZVN0YW1wLFxuICAgICAgZGlzcGF0Y2hUaW1lc3RhbXAsXG4gICAgICBzeXN0ZW0sXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RDYWxsXG4gICAgfSA6IHsgLi4udHJhbnNhY3Rpb24sXG4gICAgICBzZXJ2ZXJWZXJzaW9uLFxuICAgICAgZXZlbnRDb2RlLFxuICAgICAgdGltZVN0YW1wLFxuICAgICAgZGlzcGF0Y2hUaW1lc3RhbXAsXG4gICAgICBzeXN0ZW0sXG4gICAgICBuZXR3b3JrXG4gICAgfTsgLy8gaWdub3JlIHNlcnZlciBlY2hvIGFuZCB1bnN1YnNjcmliZSBtZXNzYWdlc1xuXG4gICAgaWYgKHNlcnZlckVjaG8oZXZlbnRDb2RlKSB8fCB0cmFuc2FjdGlvbi5zdGF0dXMgPT09ICd1bnN1YnNjcmliZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyByZXBsYWNlIG9yaWdpbmFsSGFzaCB0byBtYXRjaCB3ZWJob29rIEFQSVxuXG5cbiAgICBpZiAobmV3U3RhdGUub3JpZ2luYWxIYXNoKSB7XG4gICAgICBuZXdTdGF0ZS5yZXBsYWNlSGFzaCA9IG5ld1N0YXRlLmhhc2g7XG4gICAgICBuZXdTdGF0ZS5oYXNoID0gbmV3U3RhdGUub3JpZ2luYWxIYXNoO1xuICAgICAgZGVsZXRlIG5ld1N0YXRlLm9yaWdpbmFsSGFzaDtcbiAgICB9IC8vIHJlcGxhY2Ugc3RhdHVzIHRvIG1hdGNoIHdlYmhvb2sgQVBJXG5cblxuICAgIGlmIChldmVudENvZGUgPT09ICd0eFNwZWVkVXAnICYmIG5ld1N0YXRlLnN0YXR1cyAhPT0gJ3NwZWVkdXAnKSB7XG4gICAgICBuZXdTdGF0ZS5zdGF0dXMgPSAnc3BlZWR1cCc7XG4gICAgfSAvLyByZXBsYWNlIHN0YXR1cyB0byBtYXRjaCB3ZWJob29rIEFQSVxuXG5cbiAgICBpZiAoZXZlbnRDb2RlID09PSAndHhDYW5jZWwnICYmIG5ld1N0YXRlLnN0YXR1cyAhPT0gJ2NhbmNlbCcpIHtcbiAgICAgIG5ld1N0YXRlLnN0YXR1cyA9ICdjYW5jZWwnO1xuICAgIH0gLy8gaGFuZGxlIGNoYW5nZSBvZiBoYXNoIGluIHNwZWVkdXAgYW5kIGNhbmNlbCBldmVudHNcblxuXG4gICAgaWYgKGV2ZW50Q29kZSA9PT0gJ3R4U3BlZWRVcCcgfHwgZXZlbnRDb2RlID09PSAndHhDYW5jZWwnKSB7XG4gICAgICB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMgPSB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMubWFwKHR4ID0+IHtcbiAgICAgICAgaWYgKHR4Lmhhc2ggPT09IG5ld1N0YXRlLnJlcGxhY2VIYXNoKSB7XG4gICAgICAgICAgLy8gcmVhc3NpZ24gaGFzaCBwYXJhbWV0ZXIgaW4gdHJhbnNhY3Rpb24gcXVldWUgdG8gbmV3IGhhc2ggb3IgdHhpZFxuICAgICAgICAgIHR4Lmhhc2ggPSB0cmFuc2FjdGlvbi5oYXNoIHx8IHRyYW5zYWN0aW9uLnR4aWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHg7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY2F0ZWdvcnlDb2RlID09PSAnc2ltdWxhdGUnKSB7XG4gICAgICBuZXdTdGF0ZS5jb250cmFjdENhbGwgPSBldmVudC50cmFuc2FjdGlvbi5jb250cmFjdENhbGw7XG4gICAgICBkZWxldGUgbmV3U3RhdGUuZGlzcGF0Y2hUaW1lc3RhbXA7XG4gICAgICBzaW11bGF0aW9ucyQubmV4dCh7XG4gICAgICAgIGV2ZW50SWQsXG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2F0Y2hlZEFkZHJlc3MgPSB0cmFuc2FjdGlvbi53YXRjaGVkQWRkcmVzcyAmJiB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyB0cmFuc2FjdGlvbi53YXRjaGVkQWRkcmVzcy50b0xvd2VyQ2FzZSgpIDogdHJhbnNhY3Rpb24ud2F0Y2hlZEFkZHJlc3M7XG5cbiAgICBpZiAod2F0Y2hlZEFkZHJlc3MpIHtcbiAgICAgIGNvbnN0IGFjY291bnRPYmogPSB0aGlzLndhdGNoZWRBY2NvdW50cy5maW5kKGFjID0+IGFjLmFkZHJlc3MgPT09IHdhdGNoZWRBZGRyZXNzKTtcbiAgICAgIGNvbnN0IGFjY291bnRFbWl0dGVyUmVzdWx0ID0gYWNjb3VudE9iaiA/IGxhc3QoYWNjb3VudE9iai5lbWl0dGVycy5tYXAoZW1pdHRlciA9PiBlbWl0dGVyLmVtaXQobmV3U3RhdGUpKSkgOiBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLmdldCh3YXRjaGVkQWRkcmVzcyk7XG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmVtaXR0ZXIgPyBjb25maWd1cmF0aW9uLmVtaXR0ZXIuZW1pdChuZXdTdGF0ZSkgfHwgYWNjb3VudEVtaXR0ZXJSZXN1bHQgOiBhY2NvdW50RW1pdHRlclJlc3VsdDtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbk9iaiA9IHRoaXMud2F0Y2hlZFRyYW5zYWN0aW9ucy5maW5kKHR4ID0+IHR4Lmhhc2ggPT09IG5ld1N0YXRlLmhhc2ggfHwgbmV3U3RhdGUudHhpZCk7XG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gdHJhbnNhY3Rpb25PYmogJiYgdHJhbnNhY3Rpb25PYmouZW1pdHRlci5lbWl0KG5ld1N0YXRlKTtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpOyAvLyByZXBsYWNlIHRoZSBlbWl0dGVyIGhhc2ggdG8gdGhlIHJlcGxhY2UgaGFzaCBvbiByZXBsYWNlbWVudCB0eHNcblxuXG4gICAgICBpZiAobmV3U3RhdGUuc3RhdHVzID09PSAnc3BlZWR1cCcgfHwgbmV3U3RhdGUuc3RhdHVzID09PSAnY2FuY2VsJykge1xuICAgICAgICB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMgPSB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMubWFwKHR4ID0+IHtcbiAgICAgICAgICBpZiAodHguaGFzaCA9PT0gbmV3U3RhdGUuaGFzaCB8fCBuZXdTdGF0ZS50eGlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi50eCxcbiAgICAgICAgICAgICAgaGFzaDogbmV3U3RhdGUucmVwbGFjZUhhc2hcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRMb2cobXNnKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgdGltZVN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZGFwcElkOiB0aGlzLl9kYXBwSWQsXG4gICAgdmVyc2lvbixcbiAgICBhcHBOYW1lOiB0aGlzLl9hcHBOYW1lLFxuICAgIGFwcFZlcnNpb246IHRoaXMuX2FwcFZlcnNpb24sXG4gICAgYmxvY2tjaGFpbjoge1xuICAgICAgc3lzdGVtOiB0aGlzLl9zeXN0ZW0sXG4gICAgICBuZXR3b3JrOiBuZXR3b3JrTmFtZSh0aGlzLl9zeXN0ZW0sIHRoaXMuX25ldHdvcmtJZCkgfHwgJ2xvY2FsJ1xuICAgIH0sXG4gICAgLi4ubXNnXG4gIH0sIG1zZy5jYXRlZ29yeUNvZGUgPT09ICdjb25maWdzJyA/IGpzb25QcmVzZXJ2ZVVuZGVmaW5lZCA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JDb25uZWN0aW9uT3BlbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgREVGQVVMVF9BUFBfTkFNRSA9ICd1bmtub3duJztcbmNvbnN0IERFRkFVTFRfQVBQX1ZFUlNJT04gPSAndW5rbm93bic7XG5jb25zdCBERUZBVUxUX1NZU1RFTSA9ICdldGhlcmV1bSc7XG5cbmNsYXNzIFNESyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgc3lzdGVtID0gREVGQVVMVF9TWVNURU0sXG4gICAgICBuYW1lID0gREVGQVVMVF9BUFBfTkFNRSxcbiAgICAgIGFwcFZlcnNpb24gPSBERUZBVUxUX0FQUF9WRVJTSU9OLFxuICAgICAgbmV0d29ya0lkLFxuICAgICAgdHJhbnNhY3Rpb25IYW5kbGVycyA9IFtdLFxuICAgICAgd3MsXG4gICAgICBvbm9wZW4sXG4gICAgICBvbmRvd24sXG4gICAgICBvbnJlb3BlbixcbiAgICAgIG9uZXJyb3IsXG4gICAgICBvbmNsb3NlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgYXBpVXJsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgZGFwcElkXG4gICAgfSA9IG9wdGlvbnM7IC8vIG92ZXJyaWRlIGRlZmF1bHQgdGltZW91dCB0byBhbGxvdyBmb3Igc2xvdyBjb25uZWN0aW9uc1xuXG4gICAgY29uc3QgdGltZW91dCA9IHtcbiAgICAgIGNvbm5lY3RUaW1lb3V0OiAxMDAwMFxuICAgIH07XG4gICAgY29uc3Qgc29ja2V0ID0gbmV3IFN0dXJkeVdlYlNvY2tldChhcGlVcmwgfHwgJ3dzczovL2FwaS5ibG9ja25hdGl2ZS5jb20vdjAnLCB3cyA/IHtcbiAgICAgIHdzQ29uc3RydWN0b3I6IHdzLFxuICAgICAgLi4udGltZW91dFxuICAgIH0gOiB7IC4uLnRpbWVvdXRcbiAgICB9KTtcbiAgICBzb2NrZXQub25vcGVuID0gb25PcGVuLmJpbmQodGhpcywgb25vcGVuKTtcbiAgICBzb2NrZXQub25kb3duID0gb25Eb3duLmJpbmQodGhpcywgb25kb3duKTtcbiAgICBzb2NrZXQub25yZW9wZW4gPSBvblJlb3Blbi5iaW5kKHRoaXMsIG9ucmVvcGVuKTtcbiAgICBzb2NrZXQub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpO1xuXG4gICAgc29ja2V0Lm9uZXJyb3IgPSBlcnJvciA9PiBvbmVycm9yICYmIG9uZXJyb3Ioe1xuICAgICAgbWVzc2FnZTogJ1RoZXJlIHdhcyBhIFdlYlNvY2tldCBlcnJvcicsXG4gICAgICBlcnJvclxuICAgIH0pO1xuXG4gICAgc29ja2V0Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9waW5nVGltZW91dCAmJiBjbGVhckludGVydmFsKHRoaXMuX3BpbmdUaW1lb3V0KTtcbiAgICAgIG9uY2xvc2UgJiYgb25jbG9zZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBzdG9yYWdlS2V5ID0gQ3J5cHRvRXMuU0hBMShgJHtkYXBwSWR9IC0gJHtuYW1lfWApLnRvU3RyaW5nKCk7XG4gICAgY29uc3Qgc3RvcmVkQ29ubmVjdGlvbklkID0gaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgdGhpcy5fc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy5fY29ubmVjdGlvbklkID0gc3RvcmVkQ29ubmVjdGlvbklkIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kYXBwSWQgPSBkYXBwSWQ7XG4gICAgdGhpcy5fc3lzdGVtID0gc3lzdGVtO1xuICAgIHRoaXMuX25ldHdvcmtJZCA9IG5ldHdvcmtJZDtcbiAgICB0aGlzLl9hcHBOYW1lID0gbmFtZTtcbiAgICB0aGlzLl9hcHBWZXJzaW9uID0gYXBwVmVyc2lvbjtcbiAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzID0gdHJhbnNhY3Rpb25IYW5kbGVycztcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UgPSBzZW5kTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3BpbmdUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX29uZXJyb3IgPSBvbmVycm9yO1xuICAgIHRoaXMuX3F1ZXVlZE1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5fbGltaXRSdWxlcyA9IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUztcbiAgICB0aGlzLl93YWl0VG9SZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlID0gcHJvY2Vzc1F1ZXVlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fc29ja2V0LndzLm9uKSB7XG4gICAgICB0aGlzLl9oZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLl9waW5nVGltZW91dCk7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgLy8gdGVybWluYXRlIGNvbm5lY3Rpb24gaWYgd2UgaGF2ZW4ndCBoZWFyZCB0aGUgc2VydmVyIHBpbmcgYWZ0ZXIgc2VydmVyIHRpbWVvdXQgcGx1cyBjb25zZXJ2YXRpdmUgbGF0ZW5jeSBkZWxheVxuICAgICAgICAgIC8vIFN0dXJkeSBXZWJzb2NrZXQgd2lsbCBoYW5kbGUgdGhlIG5ldyBjb25uZWN0aW9uIGxvZ2ljXG4gICAgICAgICAgdGhpcy5fc29ja2V0LndzLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9LCAzMDAwMCArIDEwMDApO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fc29ja2V0LndzLm9uKCdwaW5nJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9oZWFydGJlYXQgJiYgdGhpcy5faGVhcnRiZWF0KCk7XG4gICAgICB9KTtcbiAgICB9IC8vIHB1YmxpYyBBUElcblxuXG4gICAgdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zID0gW107XG4gICAgdGhpcy53YXRjaGVkQWNjb3VudHMgPSBbXTtcbiAgICB0aGlzLmNvbmZpZ3VyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNpbXVsYXRlID0gc2ltdWxhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm11bHRpU2ltID0gbXVsdGlTaW0uYmluZCh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcblxuICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTsgLy8gY2FsbCBvbmNsb3NlIG1hbnVhbGx5IGhlcmUgYXMgU3R1cmR5V2ViU29ja2V0IGRvZXNuJ3QgY3VycmVudGx5IHdvcmsgYXMgZXhwZWN0ZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcGhpbGlwc29uL3N0dXJkeS13ZWJzb2NrZXQvaXNzdWVzLzVcblxuICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UoKTtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG11bHRpY2hhaW4ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTXVsdGlDaGFpbihvcHRpb25zLCB0aGlzKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIG9uT3BlbihoYW5kbGVyKSB7XG4gIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIGNvbnN0IG1zZyA9IHtcbiAgICBjYXRlZ29yeUNvZGU6ICdpbml0aWFsaXplJyxcbiAgICBldmVudENvZGU6ICdjaGVja0RhcHBJZCcsXG4gICAgY29ubmVjdGlvbklkOiB0aGlzLl9jb25uZWN0aW9uSWRcbiAgfTsgLy8gc2VuZCB0aGlzIG1lc3NhZ2UgZGlyZWN0bHkgcmF0aGVyIHRoYW4gcHV0IGluIHF1ZXVlXG5cbiAgdGhpcy5fc29ja2V0LnNlbmQoY3JlYXRlRXZlbnRMb2cuYmluZCh0aGlzKShtc2cpKTtcblxuICB0aGlzLl9oZWFydGJlYXQgJiYgdGhpcy5faGVhcnRiZWF0KCk7XG4gIGhhbmRsZXIgJiYgaGFuZGxlcigpO1xufVxuXG5mdW5jdGlvbiBvbkRvd24oaGFuZGxlciwgY2xvc2VFdmVudCkge1xuICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIoY2xvc2VFdmVudCk7XG4gIH1cblxuICB0aGlzLl9waW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5fcGluZ1RpbWVvdXQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvblJlb3BlbihoYW5kbGVyKSB7XG4gIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIGNvbnN0IG1zZyA9IHtcbiAgICBjYXRlZ29yeUNvZGU6ICdpbml0aWFsaXplJyxcbiAgICBldmVudENvZGU6ICdjaGVja0RhcHBJZCcsXG4gICAgY29ubmVjdGlvbklkOiB0aGlzLl9jb25uZWN0aW9uSWRcbiAgfTtcblxuICB0aGlzLl9zb2NrZXQuc2VuZChjcmVhdGVFdmVudExvZy5iaW5kKHRoaXMpKG1zZykpOyAvLyByZS1yZWdpc3RlciBhbGwgY29uZmlndXJhdGlvbnMgb24gcmUtY29ubmVjdGlvblxuXG5cbiAgY29uc3QgY29uZmlndXJhdGlvbnMgPSBBcnJheS5mcm9tKHRoaXMuY29uZmlndXJhdGlvbnMudmFsdWVzKCkpOyAvLyByZWdpc3RlciBnbG9iYWwgY29uZmlnIGZpcnN0IGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZVxuXG4gIGNvbnN0IGdsb2JhbENvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLmdldCgnZ2xvYmFsJyk7XG5cbiAgaWYgKGdsb2JhbENvbmZpZ3VyYXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IGdsb2JhbENvbmZpZ3VyYXRpb247XG4gICAgICBhd2FpdCB0aGlzLmNvbmZpZ3VyYXRpb24oY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdFcnJvciByZS1zZW5kaW5nIGdsb2JhbCBjb25maWd1cmF0aW9uIHVwb24gcmVjb25uZWN0aW9uOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBhZGRyZXNzQ29uZmlndXJhdGlvbnMgPSBjb25maWd1cmF0aW9ucy5maWx0ZXIoKHtcbiAgICBzY29wZVxuICB9KSA9PiBzY29wZSAhPT0gJ2dsb2JhbCcpO1xuICBhZGRyZXNzQ29uZmlndXJhdGlvbnMuZm9yRWFjaChlbmhhbmNlZENvbmZpZyA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXR0ZXIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAuLi5jb25maWdcbiAgICB9ID0gZW5oYW5jZWRDb25maWc7XG5cbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBjYXRlZ29yeUNvZGU6ICdjb25maWdzJyxcbiAgICAgIGV2ZW50Q29kZTogJ3B1dCcsXG4gICAgICBjb25maWdcbiAgICB9KTtcbiAgfSk7IC8vIHJlLXJlZ2lzdGVyIGFsbCBhY2NvdW50cyB0byBiZSB3YXRjaGVkIGJ5IHNlcnZlciB1cG9uXG4gIC8vIHJlLWNvbm5lY3Rpb24gYXMgdGhleSBkb24ndCBnZXQgdHJhbnNmZXJyZWQgb3ZlciBhdXRvbWF0aWNhbGx5XG4gIC8vIHRvIHRoZSBuZXcgY29ubmVjdGlvbiBsaWtlIHR4IGhhc2hlcyBkb1xuXG4gIHRoaXMud2F0Y2hlZEFjY291bnRzLmZvckVhY2goYWNjb3VudCA9PiB7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgZXZlbnRDb2RlOiAnYWNjb3VudEFkZHJlc3MnLFxuICAgICAgY2F0ZWdvcnlDb2RlOiAnd2F0Y2gnLFxuICAgICAgYWNjb3VudDoge1xuICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyKCk7XG4gIH1cblxuICBpZiAodGhpcy5fc29ja2V0LndzICYmIHRoaXMuX3NvY2tldC53cy5vbikge1xuICAgIC8vIG5lZWQgdG8gcmUtcmVnaXN0ZXIgcGluZyBldmVudCBzaW5jZSBuZXcgY29ubmVjdGlvblxuICAgIHRoaXMuX3NvY2tldC53cy5vbigncGluZycsICgpID0+IHtcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdCAmJiB0aGlzLl9oZWFydGJlYXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2hlYXJ0YmVhdCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU0RLO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bnc-sdk/dist/cjs/index.js\n");

/***/ })

};
;